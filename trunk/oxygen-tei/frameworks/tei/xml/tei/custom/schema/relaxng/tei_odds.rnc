namespace a = "http://relaxng.org/ns/compatibility/annotations/1.0"
default namespace ns1 = "http://www.tei-c.org/ns/1.0"
namespace rng = "http://relaxng.org/ns/structure/1.0"
namespace s = "http://www.ascc.net/xml/schematron"
namespace sch = "http://purl.oclc.org/dsdl/schematron"
namespace teix = "http://www.tei-c.org/ns/Examples"
namespace xi = "http://www.w3.org/2001/XInclude"
namespace xlink = "http://www.w3.org/1999/xlink"

# Schema generated from ODD source 2011-03-05T14:55:54Z. 
# Edition: 1.9.0. Last updated on February 25th 2011.
# Edition Location: http://www.tei-c.org/Vault/P5/1.9.0/
#

# 
# This template file is freely available and you are
#           hereby authorised to copy, modify, and redistribute it in
#           any way without further reference or permissions.
# 
# When making such modifications, you are strongly
#           recommended to change the present text to include an
#           accurate statement of the licencing conditions applicable
#           to your modified text.
div {
  extrapattern = anyDoc?, pattern, anyDoc?
  pattern =
    element rng:element {
      attribute name { xsd:QName },
      extrapattern+,
      attribute ns { xsd:anyURI }?
    }
    | element rng:element {
        element rng:choice {
          attribute xml:base { xsd:anyURI }?,
          nameClass+
        },
        attribute ns { xsd:anyURI }?,
        extrapattern+
      }
    | element rng:element { nameClass, extrapattern+ }
    | element rng:attribute {
        attribute name { xsd:QName },
        attribute ns { xsd:anyURI }?,
        anyAttDoc?,
        extrapattern?
      }
    | element rng:attribute { nameClass, extrapattern? }
    | element rng:group { extrapattern+ }
    | element rng:interleave { extrapattern+ }
    | element rng:choice { extrapattern+ }
    | element rng:optional { extrapattern+ }
    | element rng:zeroOrMore { extrapattern+ }
    | element rng:oneOrMore { extrapattern+ }
    | element rng:list { extrapattern+ }
    | element rng:mixed { extrapattern+ }
    | element rng:ref {
        attribute name { xsd:NCName }
      }
    | element rng:parentRef {
        attribute name { xsd:NCName }
      }
    | element rng:empty { empty }
    | element rng:text { empty }
    | element rng:value {
        attribute type { xsd:NCName }?,
        xsd:string
      }
    | element rng:data {
        attribute type { xsd:NCName },
        param*,
        exceptExtrapattern?
      }
    | element rng:notAllowed { empty }
    | element rng:externalRef {
        attribute href { xsd:anyURI },
        empty
      }
    | element rng:grammar {
        attribute datatypeLibrary { xsd:anyURI }?,
        attribute ns { xsd:anyURI },
        grammarContent*
      }
  anyDoc =
    element a:* {
      attribute ns { xsd:anyURI }?,
      (anyDoc | text)*
    }
  anyAttDoc = attribute a:defaultValue { text }
  param =
    element rng:param {
      attribute name { xsd:NCName },
      xsd:string
    }
  exceptExtrapattern = element rng:except { extrapattern+ }
  grammarContent =
    \start
    | define
    | element rng:div { grammarContent* }
    | element rng:include {
        attribute href { xsd:anyURI },
        includeContent*
      }
  includeContent =
    \start
    | define
    | element rng:div { includeContent* }
  \start =
    element rng:start {
      attribute combine { method }?,
      extrapattern
    }
  define =
    element rng:define {
      attribute name { xsd:NCName },
      attribute combine { method }?,
      extrapattern+
    }
  method = "choice" | "interleave"
  nameClass =
    element rng:name {
      xsd:QName,
      attribute ns { xsd:anyURI }?
    }
    | element rng:anyName { exceptNameClass? }
    | element rng:nsName {
        attribute ns { xsd:anyURI }?,
        exceptNameClass?
      }
    | element rng:choice { nameClass+ }
  exceptNameClass = element rng:except { nameClass+ }
}
macro.paraContent =
  (text | model.gLike | model.phrase | model.inter | model.global)*
macro.limitedContent = (text | model.limitedPhrase | model.inter)*
macro.phraseSeq = (text | model.gLike | model.phrase | model.global)*
macro.phraseSeq.limited = (text | model.limitedPhrase | model.global)*
macro.specialPara =
  (text
   | model.gLike
   | model.phrase
   | model.inter
   | model.divPart
   | model.global)*
macro.xtext = (text | model.gLike)*
data.certainty = "high" | "medium" | "low" | "unknown"
data.probability = xsd:double { minInclusive = "0" maxInclusive = "1" }
data.numeric =
  xsd:double
  | xsd:token { pattern = "(\-?[\d]+/\-?[\d]+)" }
  | xsd:decimal
data.count = xsd:nonNegativeInteger
data.temporal.w3c =
  xsd:date
  | xsd:gYear
  | xsd:gMonth
  | xsd:gDay
  | xsd:gYearMonth
  | xsd:gMonthDay
  | xsd:time
  | xsd:dateTime
data.truthValue = xsd:boolean
data.xTruthValue = xsd:boolean | "unknown" | "inapplicable"
data.language = xsd:language
data.namespace = xsd:anyURI
data.outputMeasurement =
  xsd:token {
    pattern =
      "[\-+]?\d+(\.\d+)?(%|cm|mm|in|pt|pc|px|em|ex|gd|rem|vw|vh|vm)"
  }
data.pattern = xsd:token
data.pointer = xsd:anyURI
data.version = xsd:token { pattern = "[\d]+(\.[\d]+){0,2}" }
data.key = xsd:string
data.word = xsd:token { pattern = "(\p{L}|\p{N}|\p{P}|\p{S})+" }
data.code = xsd:anyURI
data.name = xsd:Name
data.enumerated = data.name
macro.anyXML =
  element * - (ns1:* | teix:egXML) {
    attribute * { text }*,
    (text | macro.anyXML)*
  }
macro.schemaPattern =
  (text | (pattern | define)+)
  | anySchematron*
anySchematron =
  element s:* {
    (attribute * { text }
     | anySchematron
     | text)*
  }
att.ascribed.attributes = att.ascribed.attribute.who
att.ascribed.attribute.who =
  
  ## indicates the person, or group of people, to whom the element content is ascribed.
  attribute who {
    list { data.pointer, data.pointer* }
  }?
att.canonical.attributes =
  att.canonical.attribute.key, att.canonical.attribute.ref
att.canonical.attribute.key =
  
  ## provides an externally-defined means of identifying the entity (or entities) being
  ##         named, using a coded value of some kind.
  attribute key { data.key }?
att.canonical.attribute.ref =
  
  ## (reference) provides an explicit means of locating a full definition for the entity being named by
  ##         means of one or more URIs.
  attribute ref {
    list { data.pointer, data.pointer* }
  }?
att.ranging.attributes =
  att.ranging.attribute.atLeast,
  att.ranging.attribute.atMost,
  att.ranging.attribute.min,
  att.ranging.attribute.max
att.ranging.attribute.atLeast =
  
  ## gives a minimum estimated value for the approximate measurement.
  attribute atLeast { data.numeric }?
att.ranging.attribute.atMost =
  
  ## gives a maximum estimated value for the approximate measurement.
  attribute atMost { data.numeric }?
att.ranging.attribute.min =
  
  ## where the measurement summarizes more than one observation
  ##       or a range, supplies the minimum value
  ##         observed.
  attribute min { data.numeric }?
att.ranging.attribute.max =
  
  ## where the measurement summarizes more than one observation
  ##       or a range, supplies the maximum value
  ##       observed.
  attribute max { data.numeric }?
att.dimensions.attributes =
  att.ranging.attributes,
  att.dimensions.attribute.unit,
  att.dimensions.attribute.quantity,
  att.dimensions.attribute.extent,
  att.dimensions.attribute.precision,
  att.dimensions.attribute.scope
att.dimensions.attribute.unit =
  
  ## names the unit used for the measurement
  ## Suggested values include: 1] cm(centimetres) ; 2] mm(millimetres) ; 3] in(inches) ; 4] lines; 5] chars(characters) 
  attribute unit {
    
    ## (centimetres) 
    "cm"
    | 
      ## (millimetres) 
      "mm"
    | 
      ## (inches) 
      "in"
    | 
      ## lines of text
      "lines"
    | 
      ## (characters) characters of text
      "chars"
    | xsd:Name
  }?
att.dimensions.attribute.quantity =
  
  ## specifies the length in the units specified
  attribute quantity { data.numeric }?
att.dimensions.attribute.extent =
  
  ## indicates the size of the object concerned using a project-specific vocabulary combining
  ##         quantity and units in a single string of words. 
  attribute extent {
    list { data.word, data.word* }
  }?
att.dimensions.attribute.precision =
  
  ## characterizes the precision of the values specified by the other attributes.
  attribute precision { data.certainty }?
att.dimensions.attribute.scope =
  
  ## where the measurement summarizes more than one observation, specifies the applicability
  ##         of this measurement.
  ## Sample values include: 1] all; 2] most; 3] range
  attribute scope { data.enumerated }?
att.breaking.attributes = att.breaking.attribute.break
att.breaking.attribute.break =
  
  ## indicates whether or not the  element
  ##	bearing this attribute should be considered to mark the end of
  ##	an orthographic token in the same way as whitespace.
  attribute break { data.enumerated }?
att.datable.w3c.attributes =
  att.datable.w3c.attribute.period,
  att.datable.w3c.attribute.when,
  att.datable.w3c.attribute.notBefore,
  att.datable.w3c.attribute.notAfter,
  att.datable.w3c.attribute.from,
  att.datable.w3c.attribute.to
att.datable.w3c.attribute.period =
  
  ## supplies a pointer to some location defining a named
  ##       period of time within which the datable item is understood to
  ##       have occurred.
  attribute period { data.pointer }?
att.datable.w3c.attribute.when =
  
  ## supplies the value of the date or time in a standard form,
  ##       e.g. yyyy-mm-dd.
  attribute when { data.temporal.w3c }?
att.datable.w3c.attribute.notBefore =
  
  ## specifies the earliest possible date for the event in
  ##	  standard form, e.g. yyyy-mm-dd.
  attribute notBefore { data.temporal.w3c }?
att.datable.w3c.attribute.notAfter =
  
  ## specifies the latest possible date for the event in
  ##	  standard form, e.g. yyyy-mm-dd.
  attribute notAfter { data.temporal.w3c }?
att.datable.w3c.attribute.from =
  
  ## indicates the starting point of the period in standard form, e.g. yyyy-mm-dd.
  attribute from { data.temporal.w3c }?
att.datable.w3c.attribute.to =
  
  ## indicates the ending point of the period in standard
  ##	  form, e.g. yyyy-mm-dd.
  attribute to { data.temporal.w3c }?
att.datable.attributes = att.datable.w3c.attributes
att.declarable.attributes = att.declarable.attribute.default
att.declarable.attribute.default =
  
  ## indicates whether or not this element is selected by default when
  ## its parent is selected.
  [ a:defaultValue = "false" ]
  attribute default {
    
    ## This element is selected if its parent is selected
    "true"
    | 
      ## This element can only be selected explicitly, unless it is the
      ## only one of its kind, in which case it is selected if its parent is selected.
      "false"
  }?
att.declaring.attributes = att.declaring.attribute.decls
att.declaring.attribute.decls =
  
  ## identifies one or more declarable elements within the
  ## header, which are understood to apply to the element bearing this
  ## attribute and its content.
  attribute decls {
    list { data.pointer, data.pointer* }
  }?
att.divLike.attributes =
  att.divLike.attribute.org,
  att.divLike.attribute.sample,
  att.divLike.attribute.part
att.divLike.attribute.org =
  
  ## (organization) specifies how the content of the division is organized.
  [ a:defaultValue = "uniform" ]
  attribute org {
    
    ## composite content: i.e. no claim is made about the
    ##		  sequence in which the immediate contents of this division
    ##		  are to be processed, or their inter-relationships.
    "composite"
    | 
      ## uniform content: i.e. the immediate contents of this
      ##		  element are regarded as forming a logical unit, to be
      ##		  processed in sequence.
      "uniform"
  }?
att.divLike.attribute.sample =
  
  ## indicates whether this division is a sample of the
  ##		original source and if so, from which part.
  [ a:defaultValue = "complete" ]
  attribute sample {
    
    ## division lacks material present at end in source.
    "initial"
    | 
      ## division lacks material at start and end.
      "medial"
    | 
      ## division lacks material at start.
      "final"
    | 
      ## position of sampled material within original unknown.
      "unknown"
    | 
      ## division is not a sample.
      "complete"
  }?
att.divLike.attribute.part =
  
  ## specifies whether or not the division is fragmented by
  ##		some other structural element, for example a speech which is
  ##		divided between two or more verse stanzas.
  [ a:defaultValue = "N" ]
  attribute part {
    
    ## (yes) the division is incomplete in some respect
    "Y"
    | 
      ## (no) either the division is complete, or no claim is made as to its completeness.
      "N"
    | 
      ## (initial) the initial part of an incomplete division
      "I"
    | 
      ## (medial) a medial part of an incomplete division
      "M"
    | 
      ## (final) the final part of an incomplete division
      "F"
  }?
att.docStatus.attributes = att.docStatus.attribute.status
att.docStatus.attribute.status =
  
  ## describes the status of a document either currently or, when
  ## associated with a dated element, at the time indicated.
  ## Sample values include: 1] approved; 2] candidate; 3] cleared; 4] deprecated; 5] draft; 6] embargoed; 7] expired; 8] frozen; 9] galley; 10] proposed; 11] published; 12] recommendation; 13] submitted; 14] unfinished; 15] withdrawn
  [ a:defaultValue = "draft" ] attribute status { data.enumerated }?
att.responsibility.attributes =
  att.responsibility.attribute.cert, att.responsibility.attribute.resp
att.responsibility.attribute.cert =
  
  ## (certainty) signifies the degree of certainty associated with the intervention or interpretation.
  attribute cert { data.certainty }?
att.responsibility.attribute.resp =
  
  ## (responsible party) indicates the agency responsible for the intervention or interpretation, for example an
  ##         editor or transcriber.
  attribute resp {
    list { data.pointer, data.pointer* }
  }?
att.editLike.attributes =
  att.dimensions.attributes,
  att.responsibility.attributes,
  att.editLike.attribute.evidence,
  att.editLike.attribute.source
att.editLike.attribute.evidence =
  
  ## indicates the nature of the evidence supporting the reliability or accuracy of the
  ##         intervention or interpretation.
  ## Suggested values include: 1] internal; 2] external; 3] conjecture
  attribute evidence {
    list {
      (
       ## there is internal evidence to support the intervention.
       "internal"
       | 
         ## there is external evidence to support the intervention.
         "external"
       | 
         ## the intervention or interpretation has been made by the editor, cataloguer, or
         ##             scholar on the basis of their expertise.
         "conjecture"
       | xsd:Name),
      (
       ## there is internal evidence to support the intervention.
       "internal"
       | 
         ## there is external evidence to support the intervention.
         "external"
       | 
         ## the intervention or interpretation has been made by the editor, cataloguer, or
         ##             scholar on the basis of their expertise.
         "conjecture"
       | xsd:Name)*
    }
  }?
att.editLike.attribute.source =
  
  ## contains a list of one or more pointers indicating sources
  ##       supporting the given  intervention or interpretation.
  attribute source {
    list { data.pointer, data.pointer* }
  }?
att.global.attributes =
  att.global.linking.attributes,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.rendition,
  att.global.attribute.xmlbase,
  att.global.attribute.xmlspace
att.global.attribute.xmlid =
  
  ## (identifier) provides a unique identifier for the element bearing the attribute.
  attribute xml:id { xsd:ID }?
att.global.attribute.n =
  
  ## (number) gives a number (or other label) for an element, which is not necessarily unique within
  ##         the document.
  attribute n {
    list { data.word, data.word* }
  }?
att.global.attribute.xmllang =
  
  ## (language) indicates the language of the element content using a tag generated
  ##         according to BCP 47
  ##          
  attribute xml:lang { data.language }?
att.global.attribute.rend =
  
  ## (rendition) indicates how the element in question was rendered or presented in the source text.
  attribute rend {
    list { data.word, data.word* }
  }?
att.global.attribute.rendition =
  
  ## points to a description of the rendering or presentation used for this element in the
  ##         source text.
  attribute rendition {
    list { data.pointer, data.pointer* }
  }?
att.global.attribute.xmlbase =
  
  ## provides a base URI reference with which applications can resolve relative URI
  ##         references into absolute URI references.
  attribute xml:base { data.pointer }?
att.global.attribute.xmlspace =
  
  ## signals an intention about how white space should be 
  ##       managed by  applications. 
  attribute xml:space {
    
    ## the processor should treat white space according to the
    ##	default XML white space handling rules
    "default"
    | 
      ## the processor should preserve unchanged any and all
      ##	white space in the source
      "preserve"
  }?
att.handFeatures.attributes =
  att.handFeatures.attribute.scribe,
  att.handFeatures.attribute.scribeRef,
  att.handFeatures.attribute.script,
  att.handFeatures.attribute.scriptRef,
  att.handFeatures.attribute.medium,
  att.handFeatures.attribute.scope
att.handFeatures.attribute.scribe =
  
  ## gives a name or other identifier for the scribe
  ## believed to be responsible for this hand.
  attribute scribe { data.name }?
att.handFeatures.attribute.scribeRef =
  
  ## points to a full description of the scribe concerned, typically supplied by a person element
  ##       elsewhere in the description.
  attribute scribeRef {
    list { data.pointer, data.pointer* }
  }?
att.handFeatures.attribute.script =
  
  ## characterizes the particular script or writing style used by
  ## this hand, for example secretary, copperplate, Chancery, Italian, etc.
  attribute script {
    list { data.name, data.name* }
  }?
att.handFeatures.attribute.scriptRef =
  
  ## points to a full description of the script or writing style used by
  ## this hand, typically supplied by a scriptNote element
  ##       elsewhere in the description.
  attribute scriptRef {
    list { data.pointer, data.pointer* }
  }?
att.handFeatures.attribute.medium =
  
  ## describes the tint or type of ink, e.g. brown, or other
  ## writing medium, e.g. pencil
  attribute medium { data.enumerated }?
att.handFeatures.attribute.scope =
  
  ## specifies how widely this  hand is used in the manuscript.
  attribute scope {
    
    ## only this hand is used throughout the manuscript
    "sole"
    | 
      ## this hand is used through most of the manuscript
      "major"
    | 
      ## this hand is used occasionally in the manuscript
      "minor"
  }?
att.internetMedia.attributes = att.internetMedia.attribute.mimeType
att.internetMedia.attribute.mimeType =
  
  ## (MIME media type) specifies the applicable multimedia internet mail extension (MIME) media type
  attribute mimeType { data.word }?
att.measurement.attributes =
  att.measurement.attribute.unit,
  att.measurement.attribute.quantity,
  att.measurement.attribute.commodity
att.measurement.attribute.unit =
  
  ## indicates the units used for the measurement, usually
  ##       using the standard symbol for the desired units.
  ## Suggested values include: 1] m(metre) ; 2] kg(kilogram) ; 3] s(second) ; 4] Hz(hertz) ; 5] Pa(pascal) ; 6] Ω(ohm) ; 7] L(litre) ; 8] t(tonne) ; 9] ha(hectare) ; 10] Å(ångström) ; 11] mL(millilitre) ; 12] cm(centimetre) ; 13] dB(decibel) ; 14] kbit(kilobit) ; 15] Kibit(kibibit) ; 16] kB(kilobyte) ; 17] KiB(kibibyte) ; 18] MB(megabyte) ; 19] MiB(mebibyte) 
  attribute unit {
    
    ## (metre) SI base unit of length
    "m"
    | 
      ## (kilogram) SI base unit of mass
      "kg"
    | 
      ## (second) SI base unit of time
      "s"
    | 
      ## (hertz) SI unit of frequency
      "Hz"
    | 
      ## (pascal) SI unit of pressure or stress
      "Pa"
    | 
      ## (ohm) SI unit of electric resistance
      "Ω"
    | 
      ## (litre) 1 dm³
      "L"
    | 
      ## (tonne) 10³ kg
      "t"
    | 
      ## (hectare) 1 hm²
      "ha"
    | 
      ## (ångström) 10⁻¹⁰ m
      "Å"
    | 
      ## (millilitre) 
      "mL"
    | 
      ## (centimetre) 
      "cm"
    | 
      ## (decibel) see remarks, below
      "dB"
    | 
      ## (kilobit) 10³ or 1000 bits
      "kbit"
    | 
      ## (kibibit) 2¹⁰ or 1024 bits
      "Kibit"
    | 
      ## (kilobyte) 10³ or 1000 bytes
      "kB"
    | 
      ## (kibibyte) 2¹⁰ or 1024 bytes
      "KiB"
    | 
      ## (megabyte) 10⁶ or 1 000 000 bytes
      "MB"
    | 
      ## (mebibyte) 2²⁰ or 1 048 576 bytes
      "MiB"
    | xsd:Name
  }?
att.measurement.attribute.quantity =
  
  ## specifies the number of the specified units that
  ##       comprise the measurement
  attribute quantity { data.numeric }?
att.measurement.attribute.commodity =
  
  ## indicates the substance that is being measured
  attribute commodity {
    list { data.word, data.word* }
  }?
att.naming.attributes =
  att.canonical.attributes,
  att.naming.attribute.role,
  att.naming.attribute.nymRef
att.naming.attribute.role =
  
  ## may be used to specify further information about the entity referenced by
  ## this name, for example the occupation of a person, or the status of a place. 
  attribute role { data.enumerated }?
att.naming.attribute.nymRef =
  
  ## (reference to the canonical name) provides a means of locating the canonical form
  ##       (nym) of the names associated with the object
  ##        named by
  ##       the element bearing it.
  attribute nymRef {
    list { data.pointer, data.pointer* }
  }?
att.placement.attributes = att.placement.attribute.place
att.placement.attribute.place =
  
  ## 
  ## Suggested values include: 1] below; 2] bottom; 3] margin; 4] top; 5] opposite; 6] overleaf; 7] above; 8] end; 9] inline; 10] inspace
  attribute place {
    list {
      (
       ## below the line
       "below"
       | 
         ## at the foot of the page
         "bottom"
       | 
         ## in the margin (left, right, or both)
         "margin"
       | 
         ## at the top of the page
         "top"
       | 
         ## on the opposite, i.e. facing, page
         "opposite"
       | 
         ## on the other side of the leaf
         "overleaf"
       | 
         ## above the line
         "above"
       | 
         ## at the end of e.g. chapter or volume.
         "end"
       | 
         ## within the body of the text.
         "inline"
       | 
         ##  in a predefined space, for example left by an earlier scribe.
         "inspace"
       | xsd:Name),
      (
       ## below the line
       "below"
       | 
         ## at the foot of the page
         "bottom"
       | 
         ## in the margin (left, right, or both)
         "margin"
       | 
         ## at the top of the page
         "top"
       | 
         ## on the opposite, i.e. facing, page
         "opposite"
       | 
         ## on the other side of the leaf
         "overleaf"
       | 
         ## above the line
         "above"
       | 
         ## at the end of e.g. chapter or volume.
         "end"
       | 
         ## within the body of the text.
         "inline"
       | 
         ##  in a predefined space, for example left by an earlier scribe.
         "inspace"
       | xsd:Name)*
    }
  }?
att.typed.attributes =
  att.typed.attribute.type, att.typed.attribute.subtype
att.typed.attribute.type =
  
  ## characterizes the element in some sense, using any convenient
  ##  classification scheme or typology.
  attribute type { data.enumerated }?
att.typed.attribute.subtype =
  
  ## provides a sub-categorization of the element, if needed
  attribute subtype { data.enumerated }?
att.pointing.attributes =
  att.pointing.attribute.target, att.pointing.attribute.evaluate
att.pointing.attribute.target =
  
  ## specifies the destination of the reference by supplying one or more URI References
  attribute target {
    list { data.pointer, data.pointer* }
  }?
att.pointing.attribute.evaluate =
  
  ## specifies the intended meaning when the target of a
  ##       pointer is itself a pointer.
  attribute evaluate {
    
    ## if the element pointed to is itself a pointer, then
    ##	  the target of that pointer will be taken, and so on, until
    ##	  an element is found which is not a pointer.
    "all"
    | 
      ## if the element pointed to is itself a pointer, then
      ##	  its target (whether a pointer or not) is taken as the target
      ##	  of this pointer.
      "one"
    | 
      ## no further evaluation of targets is carried out
      ##	  beyond that needed to find the element specified in the
      ##	  pointer's target.
      "none"
  }?
att.pointing.group.attributes =
  att.pointing.attributes,
  att.typed.attributes,
  att.pointing.group.attribute.domains,
  att.pointing.group.attribute.targFunc
att.pointing.group.attribute.domains =
  
  ## optionally specifies the identifiers of the elements
  ##       within which all elements indicated by the contents of this
  ##       element lie.
  attribute domains {
    list { data.pointer, data.pointer, data.pointer* }
  }?
att.pointing.group.attribute.targFunc =
  
  ## (target function) describes the function of each of the values of the
  ##       targets attribute of the enclosed link,
  ##       join, or alt tags.
  attribute targFunc {
    list { data.word, data.word, data.word* }
  }?
att.readFrom.attributes = att.readFrom.attribute.source
att.readFrom.attribute.source =
  
  ## specifies the source from which declarations and definitions for
  ## the components of the object being defined may be obtained. 
  attribute source { xsd:anyURI }?
att.segLike.attributes =
  att.segLike.attribute.function, att.segLike.attribute.part
att.segLike.attribute.function =
  
  ## characterizes the function of the segment.
  attribute function { data.enumerated }?
att.segLike.attribute.part =
  
  ## specifies whether or not the segment is fragmented by some other
  ## structural element, for example a clause which is divided between two
  ## or more sentences.
  [ a:defaultValue = "N" ]
  attribute part {
    
    ## (yes) the segment is incomplete in some respect
    "Y"
    | 
      ## (no) either the segment is complete, or no claim is made as to
      ## its completeness
      "N"
    | 
      ## (initial) the initial part of an incomplete segment
      "I"
    | 
      ## (medial) a medial part of an incomplete segment
      "M"
    | 
      ## (final) the final part of an incomplete segment
      "F"
  }?
att.sourced.attributes = att.sourced.attribute.ed
att.sourced.attribute.ed =
  
  ## (edition) supplies an arbitrary identifier for the source edition in which
  ##       the associated feature (for example, a  page, column, or line
  ##       break) occurs at this point in the text.
  attribute ed {
    list { data.code, data.code* }
  }?
att.spanning.attributes = att.spanning.attribute.spanTo
att.spanning.attribute.spanTo =
  
  ## indicates the end of a span initiated by the element
  ##	bearing this attribute.
  attribute spanTo { data.pointer }?
att.tableDecoration.attributes =
  att.tableDecoration.attribute.role,
  att.tableDecoration.attribute.rows,
  att.tableDecoration.attribute.cols
att.tableDecoration.attribute.role =
  
  ## indicates the kind of information held in this cell or
  ## in each cell of this row.
  ## Suggested values include: 1] label; 2] data
  [ a:defaultValue = "data" ]
  attribute role {
    
    ## labelling or descriptive information only.
    "label"
    | 
      ## data values.
      "data"
    | xsd:Name
  }?
att.tableDecoration.attribute.rows =
  
  ## indicates the number of rows occupied by this cell or row.
  [ a:defaultValue = "1" ] attribute rows { data.count }?
att.tableDecoration.attribute.cols =
  
  ## (columns) indicates the number of columns occupied by this cell or
  ##	row.
  [ a:defaultValue = "1" ] attribute cols { data.count }?
att.transcriptional.attributes =
  att.editLike.attributes,
  att.transcriptional.attribute.hand,
  att.transcriptional.attribute.status,
  att.transcriptional.attribute.seq
att.transcriptional.attribute.hand =
  
  ## signifies the hand of the agent which made the intervention.
  attribute hand { data.pointer }?
att.transcriptional.attribute.status =
  
  ## indicates the effect of the intervention, for example in
  ##       the case of a deletion, strikeouts
  ##       which include too much or too little text, or in the case of an
  ##       addition, an insertion which duplicates some of the text
  ##       already present.
  ## Sample values include: 1] duplicate; 2] duplicate-partial; 3] excessStart; 4] excessEnd; 5] shortStart; 6] shortEnd; 7] partial; 8] unremarkable
  [ a:defaultValue = "unremarkable" ]
  attribute status { data.enumerated }?
att.transcriptional.attribute.seq =
  
  ## (sequence) assigns a sequence number related to the order in which
  ##       the encoded features carrying this attribute are believed to have occurred.
  attribute seq { data.count }?
att.translatable.attributes = att.translatable.attribute.version
att.translatable.attribute.version =
  
  ## specifies the version name or number of the source from
  ##	which the translated version was derived
  attribute version { data.word }?
model.nameLike.agent = name
model.nameLike.agent_alternation = name
model.nameLike.agent_sequence = name
model.nameLike.agent_sequenceOptional = name?
model.nameLike.agent_sequenceOptionalRepeatable = name*
model.nameLike.agent_sequenceRepeatable = name+
model.segLike = seg
model.segLike_alternation = seg
model.segLike_sequence = seg
model.segLike_sequenceOptional = seg?
model.segLike_sequenceOptionalRepeatable = seg*
model.segLike_sequenceRepeatable = seg+
model.hiLike = hi
model.hiLike_alternation = hi
model.hiLike_sequence = hi
model.hiLike_sequenceOptional = hi?
model.hiLike_sequenceOptionalRepeatable = hi*
model.hiLike_sequenceRepeatable = hi+
model.emphLike =
  foreign
  | emph
  | distinct
  | mentioned
  | soCalled
  | gloss
  | term
  | title
  | code
  | ident
model.emphLike_alternation =
  foreign
  | emph
  | distinct
  | mentioned
  | soCalled
  | gloss
  | term
  | title
  | code
  | ident
model.emphLike_sequence =
  foreign,
  emph,
  distinct,
  mentioned,
  soCalled,
  gloss,
  term,
  title,
  code,
  ident
model.emphLike_sequenceOptional =
  foreign?,
  emph?,
  distinct?,
  mentioned?,
  soCalled?,
  gloss?,
  term?,
  title?,
  code?,
  ident?
model.emphLike_sequenceOptionalRepeatable =
  foreign*,
  emph*,
  distinct*,
  mentioned*,
  soCalled*,
  gloss*,
  term*,
  title*,
  code*,
  ident*
model.emphLike_sequenceRepeatable =
  foreign+,
  emph+,
  distinct+,
  mentioned+,
  soCalled+,
  gloss+,
  term+,
  title+,
  code+,
  ident+
model.highlighted = model.hiLike | model.emphLike
model.highlighted_alternation =
  model.hiLike_alternation | model.emphLike_alternation
model.highlighted_sequence =
  model.hiLike_sequence, model.emphLike_sequence
model.highlighted_sequenceOptional =
  model.hiLike_sequenceOptional?, model.emphLike_sequenceOptional?
model.highlighted_sequenceOptionalRepeatable =
  model.hiLike_sequenceOptionalRepeatable*,
  model.emphLike_sequenceOptionalRepeatable*
model.highlighted_sequenceRepeatable =
  model.hiLike_sequenceRepeatable+, model.emphLike_sequenceRepeatable+
model.dateLike = date | time
model.dateLike_alternation = date | time
model.dateLike_sequence = date, time
model.dateLike_sequenceOptional = date?, time?
model.dateLike_sequenceOptionalRepeatable = date*, time*
model.dateLike_sequenceRepeatable = date+, time+
model.measureLike = num | measure | measureGrp
model.measureLike_alternation = num | measure | measureGrp
model.measureLike_sequence = num, measure, measureGrp
model.measureLike_sequenceOptional = num?, measure?, measureGrp?
model.measureLike_sequenceOptionalRepeatable =
  num*, measure*, measureGrp*
model.measureLike_sequenceRepeatable = num+, measure+, measureGrp+
model.egLike = eg | egXML
model.egLike_alternation = eg | egXML
model.egLike_sequence = eg, egXML
model.egLike_sequenceOptional = eg?, egXML?
model.egLike_sequenceOptionalRepeatable = eg*, egXML*
model.egLike_sequenceRepeatable = eg+, egXML+
model.graphicLike = graphic | binaryObject | formula
model.graphicLike_alternation = graphic | binaryObject | formula
model.graphicLike_sequence = graphic, binaryObject, formula
model.graphicLike_sequenceOptional = graphic?, binaryObject?, formula?
model.graphicLike_sequenceOptionalRepeatable =
  graphic*, binaryObject*, formula*
model.graphicLike_sequenceRepeatable = graphic+, binaryObject+, formula+
model.pPart.editorial = choice | abbr | expan
model.pPart.editorial_alternation = choice | abbr | expan
model.pPart.editorial_sequence = choice, abbr, expan
model.pPart.editorial_sequenceOptional = choice?, abbr?, expan?
model.pPart.editorial_sequenceOptionalRepeatable =
  choice*, abbr*, expan*
model.pPart.editorial_sequenceRepeatable = choice+, abbr+, expan+
model.pPart.transcriptional =
  sic | corr | reg | orig | add | del | unclear
model.pPart.transcriptional_alternation =
  sic | corr | reg | orig | add | del | unclear
model.pPart.transcriptional_sequence =
  sic, corr, reg, orig, add, del, unclear
model.pPart.transcriptional_sequenceOptional =
  sic?, corr?, reg?, orig?, add?, del?, unclear?
model.pPart.transcriptional_sequenceOptionalRepeatable =
  sic*, corr*, reg*, orig*, add*, del*, unclear*
model.pPart.transcriptional_sequenceRepeatable =
  sic+, corr+, reg+, orig+, add+, del+, unclear+
model.pPart.edit = model.pPart.editorial | model.pPart.transcriptional
model.pPart.edit_alternation =
  model.pPart.editorial_alternation
  | model.pPart.transcriptional_alternation
model.pPart.edit_sequence =
  model.pPart.editorial_sequence, model.pPart.transcriptional_sequence
model.pPart.edit_sequenceOptional =
  model.pPart.editorial_sequenceOptional?,
  model.pPart.transcriptional_sequenceOptional?
model.pPart.edit_sequenceOptionalRepeatable =
  model.pPart.editorial_sequenceOptionalRepeatable*,
  model.pPart.transcriptional_sequenceOptionalRepeatable*
model.pPart.edit_sequenceRepeatable =
  model.pPart.editorial_sequenceRepeatable+,
  model.pPart.transcriptional_sequenceRepeatable+
model.ptrLike = ptr | ref
model.ptrLike_alternation = ptr | ref
model.ptrLike_sequence = ptr, ref
model.ptrLike_sequenceOptional = ptr?, ref?
model.ptrLike_sequenceOptionalRepeatable = ptr*, ref*
model.ptrLike_sequenceRepeatable = ptr+, ref+
model.global.meta =
  index | link | linkGrp | timeline | join | joinGrp | alt | altGrp
model.global.meta_alternation =
  index | link | linkGrp | timeline | join | joinGrp | alt | altGrp
model.global.meta_sequence =
  index, link, linkGrp, timeline, join, joinGrp, alt, altGrp
model.global.meta_sequenceOptional =
  index?, link?, linkGrp?, timeline?, join?, joinGrp?, alt?, altGrp?
model.global.meta_sequenceOptionalRepeatable =
  index*, link*, linkGrp*, timeline*, join*, joinGrp*, alt*, altGrp*
model.global.meta_sequenceRepeatable =
  index+, link+, linkGrp+, timeline+, join+, joinGrp+, alt+, altGrp+
model.milestoneLike = milestone | pb | lb | cb | anchor
model.milestoneLike_alternation = milestone | pb | lb | cb | anchor
model.milestoneLike_sequence = milestone, pb, lb, cb, anchor
model.milestoneLike_sequenceOptional =
  milestone?, pb?, lb?, cb?, anchor?
model.milestoneLike_sequenceOptionalRepeatable =
  milestone*, pb*, lb*, cb*, anchor*
model.milestoneLike_sequenceRepeatable =
  milestone+, pb+, lb+, cb+, anchor+
model.gLike = g
model.oddDecl =
  moduleSpec | specGrp | elementSpec | classSpec | macroSpec | listRef
model.oddDecl_alternation =
  moduleSpec | specGrp | elementSpec | classSpec | macroSpec | listRef
model.oddDecl_sequence =
  moduleSpec, specGrp, elementSpec, classSpec, macroSpec, listRef
model.oddDecl_sequenceOptional =
  moduleSpec?, specGrp?, elementSpec?, classSpec?, macroSpec?, listRef?
model.oddDecl_sequenceOptionalRepeatable =
  moduleSpec*, specGrp*, elementSpec*, classSpec*, macroSpec*, listRef*
model.oddDecl_sequenceRepeatable =
  moduleSpec+, specGrp+, elementSpec+, classSpec+, macroSpec+, listRef+
model.oddRef = classRef | elementRef | macroRef | moduleRef | specGrpRef
model.oddRef_alternation =
  classRef | elementRef | macroRef | moduleRef | specGrpRef
model.oddRef_sequence =
  classRef, elementRef, macroRef, moduleRef, specGrpRef
model.oddRef_sequenceOptional =
  classRef?, elementRef?, macroRef?, moduleRef?, specGrpRef?
model.oddRef_sequenceOptionalRepeatable =
  classRef*, elementRef*, macroRef*, moduleRef*, specGrpRef*
model.oddRef_sequenceRepeatable =
  classRef+, elementRef+, macroRef+, moduleRef+, specGrpRef+
model.phrase.xml = att | gi | tag | val
model.phrase.xml_alternation = att | gi | tag | val
model.phrase.xml_sequence = att, gi, tag, val
model.phrase.xml_sequenceOptional = att?, gi?, tag?, val?
model.phrase.xml_sequenceOptionalRepeatable = att*, gi*, tag*, val*
model.phrase.xml_sequenceRepeatable = att+, gi+, tag+, val+
model.specDescLike = specList | specDesc
model.specDescLike_alternation = specList | specDesc
model.specDescLike_sequence = specList, specDesc
model.specDescLike_sequenceOptional = specList?, specDesc?
model.specDescLike_sequenceOptionalRepeatable = specList*, specDesc*
model.specDescLike_sequenceRepeatable = specList+, specDesc+
model.biblLike = bibl | biblStruct | biblFull
model.biblLike_alternation = bibl | biblStruct | biblFull
model.biblLike_sequence = bibl, biblStruct, biblFull
model.biblLike_sequenceOptional = bibl?, biblStruct?, biblFull?
model.biblLike_sequenceOptionalRepeatable =
  bibl*, biblStruct*, biblFull*
model.biblLike_sequenceRepeatable = bibl+, biblStruct+, biblFull+
model.headLike = head
model.headLike_alternation = head
model.headLike_sequence = head
model.headLike_sequenceOptional = head?
model.headLike_sequenceOptionalRepeatable = head*
model.headLike_sequenceRepeatable = head+
model.labelLike = desc | label
model.labelLike_alternation = desc | label
model.labelLike_sequence = desc, label
model.labelLike_sequenceOptional = desc?, label?
model.labelLike_sequenceOptionalRepeatable = desc*, label*
model.labelLike_sequenceRepeatable = desc+, label+
model.listLike = \list | listBibl
model.listLike_alternation = \list | listBibl
model.listLike_sequence = \list, listBibl
model.listLike_sequenceOptional = \list?, listBibl?
model.listLike_sequenceOptionalRepeatable = \list*, listBibl*
model.listLike_sequenceRepeatable = \list+, listBibl+
model.noteLike = note
model.noteLike_alternation = note
model.noteLike_sequence = note
model.noteLike_sequenceOptional = note?
model.noteLike_sequenceOptionalRepeatable = note*
model.noteLike_sequenceRepeatable = note+
model.lLike = l
model.lLike_alternation = l
model.lLike_sequence = l
model.lLike_sequenceOptional = l?
model.lLike_sequenceOptionalRepeatable = l*
model.lLike_sequenceRepeatable = l+
model.pLike = p | ab
model.pLike_alternation = p | ab
model.pLike_sequence = p, ab
model.pLike_sequenceOptional = p?, ab?
model.pLike_sequenceOptionalRepeatable = p*, ab*
model.pLike_sequenceRepeatable = p+, ab+
model.stageLike = stage
model.stageLike_alternation = stage
model.stageLike_sequence = stage
model.stageLike_sequenceOptional = stage?
model.stageLike_sequenceOptionalRepeatable = stage*
model.stageLike_sequenceRepeatable = stage+
model.entryPart =
  superEntry
  | hom
  | sense
  | form
  | orth
  | pron
  | hyph
  | syll
  | gen
  | number
  | case
  | per
  | tns
  | mood
  | iType
  | gramGrp
  | pos
  | subc
  | colloc
  | def
  | etym
  | usg
  | lbl
  | xr
  | re
model.entryPart.top =
  cit | dictScrap | form | gramGrp | def | etym | usg | xr | re
model.global.edit = gap
model.global.edit_alternation = gap
model.global.edit_sequence = gap
model.global.edit_sequenceOptional = gap?
model.global.edit_sequenceOptionalRepeatable = gap*
model.global.edit_sequenceRepeatable = gap+
model.divPart =
  model.lLike | model.pLike | lg | sp | floatingText | schemaSpec
model.divPart_alternation =
  model.lLike_alternation
  | model.pLike_alternation
  | lg
  | sp
  | floatingText
  | schemaSpec
model.divPart_sequence =
  model.lLike_sequence,
  model.pLike_sequence,
  lg,
  sp,
  floatingText,
  schemaSpec
model.divPart_sequenceOptional =
  model.lLike_sequenceOptional?,
  model.pLike_sequenceOptional?,
  lg?,
  sp?,
  floatingText?,
  schemaSpec?
model.divPart_sequenceOptionalRepeatable =
  model.lLike_sequenceOptionalRepeatable*,
  model.pLike_sequenceOptionalRepeatable*,
  lg*,
  sp*,
  floatingText*,
  schemaSpec*
model.divPart_sequenceRepeatable =
  model.lLike_sequenceRepeatable+,
  model.pLike_sequenceRepeatable+,
  lg+,
  sp+,
  floatingText+,
  schemaSpec+
model.publicationStmtPart =
  address
  | date
  | publisher
  | pubPlace
  | distributor
  | authority
  | idno
  | availability
model.glossLike = desc | gloss | equiv | altIdent
model.quoteLike = quote | cit
model.quoteLike_alternation = quote | cit
model.quoteLike_sequence = quote, cit
model.quoteLike_sequenceOptional = quote?, cit?
model.quoteLike_sequenceOptionalRepeatable = quote*, cit*
model.quoteLike_sequenceRepeatable = quote+, cit+
model.qLike = model.quoteLike | said | q
model.qLike_alternation = model.quoteLike_alternation | said | q
model.qLike_sequence = model.quoteLike_sequence, said, q
model.qLike_sequenceOptional =
  model.quoteLike_sequenceOptional?, said?, q?
model.qLike_sequenceOptionalRepeatable =
  model.quoteLike_sequenceOptionalRepeatable*, said*, q*
model.qLike_sequenceRepeatable =
  model.quoteLike_sequenceRepeatable+, said+, q+
model.respLike =
  author | editor | respStmt | meeting | sponsor | funder | principal
model.respLike_alternation =
  author | editor | respStmt | meeting | sponsor | funder | principal
model.respLike_sequence =
  author, editor, respStmt, meeting, sponsor, funder, principal
model.respLike_sequenceOptional =
  author?, editor?, respStmt?, meeting?, sponsor?, funder?, principal?
model.respLike_sequenceOptionalRepeatable =
  author*, editor*, respStmt*, meeting*, sponsor*, funder*, principal*
model.respLike_sequenceRepeatable =
  author+, editor+, respStmt+, meeting+, sponsor+, funder+, principal+
model.divWrapper =
  meeting
  | byline
  | dateline
  | argument
  | epigraph
  | salute
  | docAuthor
  | docDate
model.divWrapper_alternation =
  meeting
  | byline
  | dateline
  | argument
  | epigraph
  | salute
  | docAuthor
  | docDate
model.divWrapper_sequence =
  meeting,
  byline,
  dateline,
  argument,
  epigraph,
  salute,
  docAuthor,
  docDate
model.divWrapper_sequenceOptional =
  meeting?,
  byline?,
  dateline?,
  argument?,
  epigraph?,
  salute?,
  docAuthor?,
  docDate?
model.divWrapper_sequenceOptionalRepeatable =
  meeting*,
  byline*,
  dateline*,
  argument*,
  epigraph*,
  salute*,
  docAuthor*,
  docDate*
model.divWrapper_sequenceRepeatable =
  meeting+,
  byline+,
  dateline+,
  argument+,
  epigraph+,
  salute+,
  docAuthor+,
  docDate+
model.divTopPart = model.headLike | opener
model.divTopPart_alternation = model.headLike_alternation | opener
model.divTopPart_sequence = model.headLike_sequence, opener
model.divTopPart_sequenceOptional =
  model.headLike_sequenceOptional?, opener?
model.divTopPart_sequenceOptionalRepeatable =
  model.headLike_sequenceOptionalRepeatable*, opener*
model.divTopPart_sequenceRepeatable =
  model.headLike_sequenceRepeatable+, opener+
model.divTop = model.divWrapper | model.divTopPart
model.pLike.front =
  head
  | byline
  | argument
  | epigraph
  | docTitle
  | titlePart
  | docAuthor
  | docEdition
  | docImprint
  | docDate
model.divBottomPart = trailer | closer | signed | postscript
model.divBottomPart_alternation = trailer | closer | signed | postscript
model.divBottomPart_sequence = trailer, closer, signed, postscript
model.divBottomPart_sequenceOptional =
  trailer?, closer?, signed?, postscript?
model.divBottomPart_sequenceOptionalRepeatable =
  trailer*, closer*, signed*, postscript*
model.divBottomPart_sequenceRepeatable =
  trailer+, closer+, signed+, postscript+
model.divBottom = model.divWrapper | model.divBottomPart
model.titlepagePart =
  graphic
  | binaryObject
  | byline
  | argument
  | epigraph
  | docTitle
  | titlePart
  | docAuthor
  | imprimatur
  | docEdition
  | docImprint
  | docDate
model.msQuoteLike = title
model.msQuoteLike_alternation = title
model.msQuoteLike_sequence = title
model.msQuoteLike_sequenceOptional = title?
model.msQuoteLike_sequenceOptionalRepeatable = title*
model.msQuoteLike_sequenceRepeatable = title+
model.choicePart =
  sic | corr | reg | orig | unclear | abbr | expan | seg
model.imprintPart = publisher | biblScope | pubPlace | distributor
model.imprintPart_alternation =
  publisher | biblScope | pubPlace | distributor
model.imprintPart_sequence = publisher, biblScope, pubPlace, distributor
model.imprintPart_sequenceOptional =
  publisher?, biblScope?, pubPlace?, distributor?
model.imprintPart_sequenceOptionalRepeatable =
  publisher*, biblScope*, pubPlace*, distributor*
model.imprintPart_sequenceRepeatable =
  publisher+, biblScope+, pubPlace+, distributor+
model.catDescPart = notAllowed
model.addressLike = email | address
model.addressLike_alternation = email | address
model.addressLike_sequence = email, address
model.addressLike_sequenceOptional = email?, address?
model.addressLike_sequenceOptionalRepeatable = email*, address*
model.addressLike_sequenceRepeatable = email+, address+
model.nameLike = model.nameLike.agent | rs | idno | lang
model.nameLike_alternation =
  model.nameLike.agent_alternation | rs | idno | lang
model.nameLike_sequence = model.nameLike.agent_sequence, rs, idno, lang
model.nameLike_sequenceOptional =
  model.nameLike.agent_sequenceOptional?, rs?, idno?, lang?
model.nameLike_sequenceOptionalRepeatable =
  model.nameLike.agent_sequenceOptionalRepeatable*, rs*, idno*, lang*
model.nameLike_sequenceRepeatable =
  model.nameLike.agent_sequenceRepeatable+, rs+, idno+, lang+
model.global =
  model.global.meta
  | model.milestoneLike
  | model.noteLike
  | model.global.edit
  | figure
model.biblPart =
  model.respLike
  | model.imprintPart
  | series
  | relatedItem
  | edition
  | extent
model.frontPart = divGen | titlePage
model.addrPart = model.nameLike | addrLine | street | postCode | postBox
model.pPart.data =
  model.dateLike
  | model.measureLike
  | model.addressLike
  | model.nameLike
model.pPart.data_alternation =
  model.dateLike_alternation
  | model.measureLike_alternation
  | model.addressLike_alternation
  | model.nameLike_alternation
model.pPart.data_sequence =
  model.dateLike_sequence,
  model.measureLike_sequence,
  model.addressLike_sequence,
  model.nameLike_sequence
model.pPart.data_sequenceOptional =
  model.dateLike_sequenceOptional?,
  model.measureLike_sequenceOptional?,
  model.addressLike_sequenceOptional?,
  model.nameLike_sequenceOptional?
model.pPart.data_sequenceOptionalRepeatable =
  model.dateLike_sequenceOptionalRepeatable*,
  model.measureLike_sequenceOptionalRepeatable*,
  model.addressLike_sequenceOptionalRepeatable*,
  model.nameLike_sequenceOptionalRepeatable*
model.pPart.data_sequenceRepeatable =
  model.dateLike_sequenceRepeatable+,
  model.measureLike_sequenceRepeatable+,
  model.addressLike_sequenceRepeatable+,
  model.nameLike_sequenceRepeatable+
model.inter =
  model.egLike
  | model.oddDecl
  | model.oddRef
  | model.biblLike
  | model.labelLike
  | model.listLike
  | model.stageLike
  | model.qLike
  | table
model.inter_alternation =
  model.egLike_alternation
  | model.oddDecl_alternation
  | model.oddRef_alternation
  | model.biblLike_alternation
  | model.labelLike_alternation
  | model.listLike_alternation
  | model.stageLike_alternation
  | model.qLike_alternation
  | table
model.inter_sequence =
  model.egLike_sequence,
  model.oddDecl_sequence,
  model.oddRef_sequence,
  model.biblLike_sequence,
  model.labelLike_sequence,
  model.listLike_sequence,
  model.stageLike_sequence,
  model.qLike_sequence,
  table
model.inter_sequenceOptional =
  model.egLike_sequenceOptional?,
  model.oddDecl_sequenceOptional?,
  model.oddRef_sequenceOptional?,
  model.biblLike_sequenceOptional?,
  model.labelLike_sequenceOptional?,
  model.listLike_sequenceOptional?,
  model.stageLike_sequenceOptional?,
  model.qLike_sequenceOptional?,
  table?
model.inter_sequenceOptionalRepeatable =
  model.egLike_sequenceOptionalRepeatable*,
  model.oddDecl_sequenceOptionalRepeatable*,
  model.oddRef_sequenceOptionalRepeatable*,
  model.biblLike_sequenceOptionalRepeatable*,
  model.labelLike_sequenceOptionalRepeatable*,
  model.listLike_sequenceOptionalRepeatable*,
  model.stageLike_sequenceOptionalRepeatable*,
  model.qLike_sequenceOptionalRepeatable*,
  table*
model.inter_sequenceRepeatable =
  model.egLike_sequenceRepeatable+,
  model.oddDecl_sequenceRepeatable+,
  model.oddRef_sequenceRepeatable+,
  model.biblLike_sequenceRepeatable+,
  model.labelLike_sequenceRepeatable+,
  model.listLike_sequenceRepeatable+,
  model.stageLike_sequenceRepeatable+,
  model.qLike_sequenceRepeatable+,
  table+
model.common = model.divPart | model.inter | model.entryLike
model.phrase =
  model.segLike
  | model.highlighted
  | model.graphicLike
  | model.pPart.edit
  | model.ptrLike
  | model.phrase.xml
  | model.specDescLike
  | model.pPart.data
  | model.ptrLike.form
model.limitedPhrase =
  model.emphLike
  | model.pPart.editorial
  | model.ptrLike
  | model.phrase.xml
  | model.pPart.data
model.divLike = \div
model.divGenLike = divGen
model.div1Like = div1
model.div2Like = div2
model.div3Like = div3
model.div4Like = div4
model.div5Like = div5
model.div6Like = div6
model.div7Like = div7
model.applicationLike = application
model.teiHeaderPart = encodingDesc | profileDesc
model.sourceDescPart = notAllowed
model.encodingDescPart =
  projectDesc
  | samplingDecl
  | editorialDecl
  | tagsDecl
  | refsDecl
  | classDecl
  | appInfo
  | geoDecl
  | charDecl
model.editorialDeclPart =
  correction
  | normalization
  | quotation
  | hyphenation
  | segmentation
  | stdVals
  | interpretation
model.profileDescPart = creation | langUsage | textClass
model.resourceLike = notAllowed
p =
  
  ## (paragraph) marks paragraphs in prose.
  element p {
    macro.paraContent,
    att.global.attributes,
    att.declaring.attributes,
    empty
  }
foreign =
  
  ## (foreign) identifies a word or phrase as belonging to some language other than that of the
  ##                 surrounding text. 
  element foreign { macro.phraseSeq, att.global.attributes, empty }
emph =
  
  ## (emphasized) marks words or phrases which are stressed or emphasized for
  ##         linguistic or rhetorical effect.
  element emph { macro.paraContent, att.global.attributes, empty }
hi =
  
  ## (highlighted) marks a word or phrase as graphically distinct from the
  ##         surrounding text, for reasons concerning which no claim is
  ##         made. 
  element hi { macro.paraContent, att.global.attributes, empty }
distinct =
  
  ## identifies any word or phrase which is regarded as linguistically distinct, for example as
  ##         archaic, technical, dialectal, non-preferred, etc., or as forming part of a sublanguage. 
  element distinct {
    macro.phraseSeq,
    att.global.attributes,
    
    ## specifies the sublanguage or register to which the word or phrase is being
    ##                 assigned
    attribute type { data.enumerated }?,
    
    ## specifies how the phrase is distinct diachronically
    attribute time { data.code }?,
    
    ## specifies how the phrase is distinct diatopically
    attribute space { data.code }?,
    
    ## specifies how the phrase is distinct diastatically
    attribute social { data.code }?,
    empty
  }
said =
  
  ## (speech or thought) indicates passages thought or spoken aloud, whether explicitly indicated in the source or
  ##     not, whether directly or indirectly reported, whether by real people or fictional characters.
  element said {
    macro.specialPara,
    att.global.attributes,
    att.ascribed.attributes,
    
    ## may be used to indicate whether the quoted matter is regarded as having been vocalized
    ##         or signed.
    [ a:defaultValue = "unknown" ]
    attribute aloud { data.xTruthValue }?,
    
    ## may be used to indicate whether the quoted matter is regarded as direct or indirect
    ##         speech.
    [ a:defaultValue = "true" ] attribute direct { data.xTruthValue }?,
    empty
  }
quote =
  
  ## (quotation) contains a phrase or passage attributed by the narrator or author to some agency external
  ##         to the text.
  element quote {
    macro.specialPara,
    att.global.attributes,
    att.typed.attributes,
    empty
  }
q =
  
  ## (separated from the surrounding text with quotation marks) contains material which is marked as (ostensibly) being somehow different than the
  ##     surrounding text, for any one of a variety of reasons including, but not limited to: direct
  ##     speech or thought, technical terms or jargon, authorial distance, quotations from elsewhere, and
  ##     passages that are mentioned but not used.
  element q {
    macro.specialPara,
    att.global.attributes,
    att.ascribed.attributes,
    
    ## may be used to indicate whether the offset passage is spoken or thought, or to
    ##         characterize it more finely.
    ## Suggested values include: 1] spoken; 2] thought; 3] written; 4] soCalled; 5] foreign(foreign words) ; 6] distinct(linguistically distinct) ; 7] term(technical term) ; 8] emph(rhetorically emphasized) ; 9] mentioned
    attribute type {
      
      ## representation of speech
      "spoken"
      | 
        ## representation of thought, e.g. internal monologue
        "thought"
      | 
        ## quotation from a written source
        "written"
      | 
        ## authorial distance
        "soCalled"
      | 
        ## (foreign words) 
        "foreign"
      | 
        ## (linguistically distinct) 
        "distinct"
      | 
        ## (technical term) 
        "term"
      | 
        ## (rhetorically emphasized) 
        "emph"
      | 
        ## refering to itself, not its normal referant
        "mentioned"
      | xsd:Name
    }?,
    empty
  }
cit =
  
  ## (cited quotation) contains a quotation from some other document, together with a bibliographic reference to
  ##     its source. In a dictionary it may contain an example text with at least one occurrence of the
  ##     word form, used in the sense being described, or a translation of the headword, or an example. 
  element cit {
    (model.qLike
     | model.egLike
     | model.biblLike
     | model.ptrLike
     | model.global
     | model.entryPart)+,
    att.global.attributes,
    att.typed.attributes,
    empty
  }
mentioned =
  
  ## marks words or phrases mentioned, not used.
  element mentioned { macro.phraseSeq, att.global.attributes, empty }
soCalled =
  
  ## contains a word or phrase for which the author or narrator indicates a disclaiming of
  ##     responsibility, for example by the use of scare quotes or italics.
  element soCalled { macro.phraseSeq, att.global.attributes, empty }
desc =
  
  ## (description) contains a brief description of the object documented by its parent element, including its
  ##     intended usage, purpose, or application where this is appropriate.
  element desc {
    macro.limitedContent,
    att.global.attributes,
    att.translatable.attributes,
    empty
  }
gloss =
  
  ## identifies a phrase or word used to provide a gloss or definition for some other word or
  ##     phrase.
  element gloss {
    macro.phraseSeq,
    att.global.attributes,
    att.declaring.attributes,
    att.translatable.attributes,
    att.typed.attributes,
    att.pointing.attributes,
    
    ## (canonical reference) identifies the associated term element using a canonical reference from a
    ##         scheme defined in a refsDecl element in the TEI header
    attribute cRef { data.pointer }?,
    empty
  }
term =
  
  ## contains a single-word, multi-word, or symbolic designation which is regarded as a technical
  ##     term.
  element term {
    macro.phraseSeq,
    att.global.attributes,
    att.declaring.attributes,
    att.pointing.attributes,
    att.typed.attributes,
    att.canonical.attributes,
    
    ## identifies the associated gloss element using a canonical reference from a
    ##           scheme defined in a refsDecl element in the TEI header
    attribute cRef { data.pointer }?,
    
    ## supplies the sort key for this term in an index.
    attribute sortKey { data.word }?,
    empty
  }
sic =
  
  ## (latin for thus or so
  ##   ) contains text reproduced although apparently incorrect or inaccurate.
  element sic {
    macro.paraContent,
    att.global.attributes,
    att.responsibility.attributes,
    empty
  }
corr =
  
  ## (correction) contains the correct form of a passage apparently erroneous in the copy text.
  element corr {
    macro.paraContent,
    att.global.attributes,
    att.editLike.attributes,
    att.typed.attributes,
    empty
  }
choice =
  
  ## groups a number of alternative encodings for the same point in
  ##         a text.
  element choice {
    (model.choicePart | choice)*, att.global.attributes, empty
  }
reg =
  
  ## (regularization) contains a reading which has been regularized or normalized in some sense.
  element reg {
    macro.paraContent,
    att.global.attributes,
    att.editLike.attributes,
    att.typed.attributes,
    empty
  }
orig =
  
  ## (original form) contains a reading which is marked as following the original, rather than being normalized
  ##         or corrected.
  element orig {
    macro.paraContent,
    att.global.attributes,
    att.responsibility.attributes,
    empty
  }
gap =
  
  ## (gap) indicates a point where material has been omitted in a transcription, whether for editorial
  ##     reasons described in the TEI header, as part of sampling practice, or because the material is
  ##     illegible, invisible, or inaudible.
  element gap {
    model.glossLike*,
    att.global.attributes,
    att.editLike.attributes,
    
    ## gives the reason for omission. Sample values include sampling,
    ##         inaudible, irrelevant, cancelled.
    attribute reason {
      list { data.word, data.word* }
    }?,
    
    ## in the case of text omitted from the transcription because of deliberate deletion by an
    ##         identifiable hand, signifies the hand which made the deletion.
    attribute hand { data.pointer }?,
    
    ## In the case of text omitted because of damage, categorizes the cause of the damage, if
    ##         it can be identified.
    ## Sample values include: 1] rubbing; 2] mildew; 3] smoke
    attribute agent { data.enumerated }?,
    empty
  }
add =
  
  ## (addition) contains letters, words, or phrases inserted in the text by an
  ##         author, scribe, annotator, or corrector.
  element add {
    macro.paraContent,
    att.global.attributes,
    att.transcriptional.attributes,
    att.placement.attributes,
    att.typed.attributes,
    empty
  }
del =
  
  ## (deletion) contains a letter, word, or passage deleted, marked as deleted, or otherwise indicated as
  ##     superfluous or spurious in the copy text by an author, scribe, annotator, or corrector.
  element del {
    macro.paraContent,
    att.global.attributes,
    att.transcriptional.attributes,
    att.typed.attributes,
    empty
  }
unclear =
  
  ## contains a word, phrase, or passage which cannot be transcribed with certainty because it
  ##         is illegible or inaudible in the source.
  element unclear {
    macro.paraContent,
    att.global.attributes,
    att.editLike.attributes,
    
    ## indicates why the material is hard to transcribe.
    attribute reason {
      list { data.word, data.word* }
    }?,
    
    ## Where the difficulty in transcription arises from action (partial deletion, etc.)
    ##                 assignable to an identifiable hand, signifies the hand responsible for the action.
    attribute hand { data.pointer }?,
    
    ## Where the difficulty in transcription arises from damage, categorizes the cause of
    ##                 the damage, if it can be identified.
    ## Sample values include: 1] rubbing; 2] mildew; 3] smoke
    attribute agent { data.enumerated }?,
    empty
  }
name =
  
  ## (name, proper noun) contains a proper noun or noun phrase.
  element name {
    macro.phraseSeq,
    att.global.attributes,
    att.naming.attributes,
    att.typed.attributes,
    empty
  }
rs =
  
  ## (referencing string) contains a general purpose name or referring string.
  element rs {
    macro.phraseSeq,
    att.global.attributes,
    att.naming.attributes,
    
    ## indicates more specifically the object referred to by the referencing string.
    ##                 Values might include person, place, ship,
    ##                     element etc.
    attribute type { data.enumerated }?,
    empty
  }
email =
  
  ## (electronic mail address) contains an e-mail address identifying a location to which
  ##         e-mail messages can be delivered.
  ##     
  element email { macro.phraseSeq, att.global.attributes, empty }
address =
  
  ## contains a postal  address, for example of a
  ##         publisher, an organization, or an individual.
  element address {
    (model.global*, (model.addrPart, model.global*)+),
    att.global.attributes,
    empty
  }
addrLine =
  
  ## (address line) contains one line of a postal address.
  element addrLine { macro.phraseSeq, att.global.attributes, empty }
street =
  
  ## a full street address including any name or number identifying a
  ##         building as well as the name of the street or route on which it is
  ##         located.
  element street { macro.phraseSeq, att.global.attributes, empty }
postCode =
  
  ## (postal code) contains a numerical or alphanumeric code used as part of a postal address to simplify
  ##         sorting or delivery of mail. 
  element postCode { text, att.global.attributes, empty }
postBox =
  
  ## (postal box or post office box) contains a number or other identifier for some postal delivery point other than a street
  ##     address. 
  element postBox { text, att.global.attributes, empty }
num =
  
  ## (number) contains a number, written in any form.
  element num {
    macro.phraseSeq,
    att.global.attributes,
    att.ranging.attributes,
    
    ## indicates the type of numeric value.
    ## Suggested values include: 1] cardinal; 2] ordinal; 3] fraction; 4] percentage
    attribute type {
      
      ## absolute number, e.g. 21, 21.5
      "cardinal"
      | 
        ## ordinal number, e.g. 21st
        "ordinal"
      | 
        ## fraction, e.g. one half or three-quarters
        "fraction"
      | 
        ## a percentage
        "percentage"
      | xsd:Name
    }?,
    
    ## supplies the value of the number in standard form.
    attribute value { data.numeric }?,
    empty
  }
measure =
  
  ## contains a word or phrase referring to some quantity of an object or commodity, usually
  ##         comprising a number, a unit, and a commodity name.
  element measure {
    macro.phraseSeq,
    att.global.attributes,
    att.measurement.attributes,
    
    ## specifies the type of measurement in any convenient typology.
    attribute type { data.enumerated }?,
    empty
  }
measureGrp =
  
  ## (measure group) contains a group of dimensional specifications which relate to the same object, for example
  ##     the height and width of a manuscript page.
  element measureGrp {
    (text | model.gLike | model.measureLike)*,
    att.global.attributes,
    att.measurement.attributes,
    att.typed.attributes,
    empty
  }
date =
  
  ## contains a date in any format.
  element date {
    (text | model.gLike | model.phrase | model.global)*,
    att.global.attributes,
    att.datable.attributes,
    att.editLike.attributes,
    att.typed.attributes,
    
    ## indicates the system or calendar to which the date represented by the content of this
    ##         element belongs.
    ## Suggested values include: 1] Gregorian; 2] Julian; 3] Islamic; 4] Hebrew; 5] Revolutionary; 6] Iranian; 7] Coptic; 8] Chinese
    attribute calendar {
      
      ## Gregorian calendar
      "Gregorian"
      | 
        ## Julian calendar
        "Julian"
      | 
        ## Islamic or Muslim (hijri) lunar calendar
        "Islamic"
      | 
        ## Hebrew or Jewish lunisolar calendar
        "Hebrew"
      | 
        ## French Revolutionary calendar
        "Revolutionary"
      | 
        ## Iranian or Persian (Jalaali) solar calendar
        "Iranian"
      | 
        ## Coptic or Alexandrian calendar
        "Coptic"
      | 
        ## Chinese lunisolar calendar
        "Chinese"
      | xsd:Name
    }?,
    empty
  }
time =
  
  ## contains a phrase defining a time of day in any format.
  element time {
    (text | model.gLike | model.phrase | model.global)*,
    att.global.attributes,
    att.datable.attributes,
    att.editLike.attributes,
    att.typed.attributes,
    empty
  }
abbr =
  
  ## (abbreviation) contains an abbreviation of any sort.
  element abbr {
    macro.phraseSeq,
    att.global.attributes,
    att.responsibility.attributes,
    
    ## allows the encoder to classify the abbreviation according to some convenient
    ##                 typology.
    ## Sample values include: 1] suspension; 2] contraction; 3] brevigraph; 4] superscription; 5] acronym; 6] title; 7] organization; 8] geographic
    attribute type { data.enumerated }?,
    empty
  }
expan =
  
  ## (expansion) contains the expansion of an abbreviation.
  element expan {
    macro.phraseSeq,
    att.global.attributes,
    att.editLike.attributes,
    empty
  }
ptr =
  
  ## (pointer) defines a pointer to another location.
  element ptr {
    empty
    >> sch:pattern [
         id = "ptr-constraint-ptrAtts"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "tei:ptr"
           "\x{a}" ~
           "               "
           sch:report [
             test = "@target and @cRef"
             "Only one of the\x{a}" ~
             "	attributes 'target' and 'cRef' may be supplied."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    att.global.attributes,
    att.pointing.attributes,
    att.typed.attributes,
    att.declaring.attributes,
    
    ## (canonical reference) specifies the destination of the pointer by supplying a canonical reference from a
    ##         scheme defined in a refsDecl element in the TEI header
    attribute cRef {
      list { data.word, data.word* }
    }?,
    empty
  }
ref =
  
  ## (reference) defines a reference to another location, possibly modified by additional text or comment.
  element ref {
    macro.paraContent
    >> sch:pattern [
         id = "ref-constraint-refAtts"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "tei:ref"
           "\x{a}" ~
           "               "
           sch:report [
             test = "@target and @cRef"
             "Only one of the\x{a}" ~
             "	attributes 'target' and 'cRef' may be supplied."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    att.global.attributes,
    att.pointing.attributes,
    att.typed.attributes,
    att.declaring.attributes,
    
    ## (canonical reference) specifies the destination of the reference by supplying a canonical reference from a
    ##         scheme defined in a refsDecl element in the TEI header
    attribute cRef {
      list { data.word, data.word* }
    }?,
    empty
  }
\list =
  
  ## (list) contains any sequence of items organized as a list.
  element list {
    ((model.divTop | model.global)*,
     ((item, model.global*)+
      | (headLabel?,
         headItem?,
         (label, model.global*, item, model.global*)+)),
     (model.divBottom, model.global*)*),
    att.global.attributes,
    
    ## describes the form of the list.
    ## Suggested values include: 1] ordered; 2] bulleted; 3] simple; 4] gloss
    [ a:defaultValue = "simple" ]
    attribute type {
      
      ## list items are numbered or lettered. 
      "ordered"
      | 
        ## list items are marked with a bullet or other typographic device. 
        "bulleted"
      | 
        ## list items are not numbered or bulleted. 
        "simple"
      | 
        ## each list item glosses some term or concept, which is given by a label element
        ##             preceding the list item.
        "gloss"
      | xsd:Name
    }?,
    empty
  }
item =
  
  ## contains one component of a list.
  element item { macro.specialPara, att.global.attributes, empty }
label =
  
  ## contains the label associated with an item in a list; in glossaries, marks the term being
  ##     defined.
  element label { macro.phraseSeq, att.global.attributes, empty }
head =
  
  ## (heading) contains any type of heading, for example the title of a section, or the heading of a list,
  ##     glossary, manuscript description, etc.
  element head {
    macro.paraContent,
    att.global.attributes,
    att.typed.attributes,
    empty
  }
headLabel =
  
  ## (heading for list labels) contains the heading for the label or term column in a glossary list or similar structured
  ##         list.
  element headLabel { macro.phraseSeq, att.global.attributes, empty }
headItem =
  
  ## (heading for list items) contains the heading for the item or gloss column in a glossary list or similar structured
  ##         list.
  element headItem { macro.phraseSeq, att.global.attributes, empty }
note =
  
  ## contains a note or annotation.
  element note {
    macro.specialPara,
    att.global.attributes,
    att.placement.attributes,
    att.pointing.attributes,
    att.responsibility.attributes,
    att.typed.attributes,
    
    ## indicates whether the copy text shows the exact place of reference for the note.
    [ a:defaultValue = "true" ] attribute anchored { data.truthValue }?,
    
    ## points to the end of the span to which the note is attached, if the note is not embedded
    ##         in the text at that point.
    attribute targetEnd {
      list { data.pointer, data.pointer* }
    }?,
    empty
  }
index =
  
  ## (index entry) marks a location to be indexed for whatever purpose.
  element index {
    (term, index?)*,
    att.global.attributes,
    att.spanning.attributes,
    
    ## supplies a name to specify which index (of several) the index entry belongs to.
    attribute indexName { data.name }?,
    empty
  }
graphic =
  
  ## indicates the location of an inline graphic, illustration, or figure.
  element graphic {
    model.glossLike*,
    att.global.attributes,
    att.internetMedia.attributes,
    att.declaring.attributes,
    
    ## The display width of the image
    attribute width { data.outputMeasurement }?,
    
    ## The display height of the image
    attribute height { data.outputMeasurement }?,
    
    ## A scale factor to be applied to the image to make it the desired display size
    attribute scale { data.numeric }?,
    
    ## (uniform resource locator) A URL which refers to the image itself.
    attribute url { data.pointer },
    empty
  }
binaryObject =
  
  ## provides encoded binary data representing an inline graphic or other object.
  element binaryObject {
    text,
    att.global.attributes,
    att.internetMedia.attributes,
    
    ## The display width of the object
    attribute width { data.outputMeasurement }?,
    
    ## The display height of the object
    attribute height { data.outputMeasurement }?,
    
    ## A scale factor to be applied to the object to make it the desired display size
    attribute scale { data.numeric }?,
    
    ## The encoding used to encode the binary data. If not specified, this is assumed to be
    ##           Base64.
    attribute encoding {
      list { data.word, data.word* }
    }?,
    empty
  }
milestone =
  
  ## marks a boundary point separating any kind of section of a text, typically but not
  ##     necessarily indicating a point at which some part of a standard reference system changes, where
  ##     the change is not represented by a structural element.
  element milestone {
    empty,
    att.global.attributes,
    att.typed.attributes,
    att.sourced.attributes,
    att.spanning.attributes,
    att.breaking.attributes,
    
    ## provides a conventional name for the kind of section changing at this milestone.
    ## Suggested values include: 1] page; 2] column; 3] line; 4] book; 5] poem; 6] canto; 7] speaker; 8] stanza; 9] act; 10] scene; 11] section; 12] absent; 13] unnumbered
    attribute unit {
      
      ## physical page breaks (synonymous with the pb element).
      "page"
      | 
        ## column breaks.
        "column"
      | 
        ## line breaks (synonymous with the lb element).
        "line"
      | 
        ## any units termed book, liber, etc.
        "book"
      | 
        ## individual poems in a collection.
        "poem"
      | 
        ## cantos or other major sections of a poem.
        "canto"
      | 
        ## changes of speaker or narrator.
        "speaker"
      | 
        ## stanzas within a poem, book, or canto.
        "stanza"
      | 
        ## acts within a play.
        "act"
      | 
        ## scenes within a play or act.
        "scene"
      | 
        ## sections of any kind.
        "section"
      | 
        ## passages not present in the reference edition.
        "absent"
      | 
        ## passages present in the text, but not to be included as part of the reference.
        "unnumbered"
      | xsd:Name
    },
    empty
  }
pb =
  
  ## (page break) marks the boundary between one page of a text and the next in a standard reference system.
  element pb {
    empty,
    att.global.attributes,
    att.typed.attributes,
    att.sourced.attributes,
    att.spanning.attributes,
    att.breaking.attributes,
    empty
  }
lb =
  
  ## (line break) marks the start of a new (typographic) line in some edition or version of a text.
  element lb {
    empty,
    att.global.attributes,
    att.typed.attributes,
    att.sourced.attributes,
    att.spanning.attributes,
    att.breaking.attributes,
    empty
  }
cb =
  
  ## (column break) marks the boundary between one column of a text and the next
  ##         in a standard reference system.
  element cb {
    empty,
    att.global.attributes,
    att.typed.attributes,
    att.sourced.attributes,
    att.spanning.attributes,
    att.breaking.attributes,
    empty
  }
analytic =
  
  ## (analytic level) contains bibliographic elements describing an item (e.g. an article or poem) published
  ##     within a monograph or journal and not as an independent publication.
  element analytic {
    (author | editor | respStmt | title | ref | date)*,
    att.global.attributes,
    empty
  }
monogr =
  
  ## (monographic level) contains bibliographic elements describing an item (e.g. a book or journal) published as an
  ##     independent item (i.e. as a separate physical object).
  element monogr {
    ((((author | editor | respStmt),
       (author | editor | respStmt)*,
       title+,
       (idno | editor | respStmt)*)
      | ((title | ref)+, (idno | author | editor | respStmt)*))?,
     (model.noteLike | meeting)*,
     (edition, (idno | editor | respStmt)*)*,
     imprint,
     (imprint | extent | biblScope)*),
    att.global.attributes,
    empty
  }
series =
  
  ## (series information) contains information about the series in which a book or other bibliographic item has
  ##     appeared.
  element series {
    (text
     | model.gLike
     | title
     | ref
     | editor
     | respStmt
     | biblScope
     | model.global)*,
    att.global.attributes,
    empty
  }
author =
  
  ## in a bibliographic reference, contains the name(s) of the
  ##   author(s), personal or corporate, of a work; for example in the same
  ##   form as that provided by a recognized bibliographic name authority. 
  element author {
    macro.phraseSeq, att.global.attributes, att.naming.attributes, empty
  }
editor =
  
  ## secondary statement of responsibility for a bibliographic item, for example the name of an
  ##     individual, institution or organization, (or of several such) acting as editor, compiler,
  ##     translator, etc. 
  element editor {
    macro.phraseSeq, att.global.attributes, att.naming.attributes, empty
  }
respStmt =
  
  ## (statement of responsibility) supplies a statement of responsibility for the intellectual content of a text, edition,
  ##     recording, or series, where the specialized elements for authors, editors, etc. do not suffice
  ##     or do not apply.
  element respStmt {
    ((resp+, model.nameLike.agent+) | (model.nameLike.agent+, resp+)),
    att.global.attributes,
    empty
  }
resp =
  
  ## (responsibility) contains a phrase describing the nature of a person's intellectual responsibility.
  element resp {
    macro.phraseSeq.limited,
    att.global.attributes,
    att.canonical.attributes,
    empty
  }
title =
  
  ## contains a title for any kind of work.
  element title {
    macro.paraContent,
    att.global.attributes,
    att.canonical.attributes,
    
    ## indicates the bibliographic level for a title, that is, whether
    ##                                         it identifies an article, book, journal, series, or
    ##                                         unpublished material.
    attribute level {
      
      ## (analytic) analytic title (article, poem, or other item
      ##                                                   published as part of a larger item) 
      "a"
      | 
        ## (monographic) monographic title (book, collection, or
        ##                                                   other item published as a distinct item,
        ##                                                   including single volumes of multi-volume
        ##                                                   works) 
        "m"
      | 
        ## (journal) journal title 
        "j"
      | 
        ## (series) series title 
        "s"
      | 
        ## (unpublished) title of unpublished material (including
        ##                                                   theses and dissertations unless
        ##                                                   published by a commercial press)
        "u"
    }?,
    
    ## classifies the title according to some convenient typology.
    ## Sample values include: 1] main; 2] sub(subordinate) ; 3] alt(alternate) ; 4] short; 5] desc(descriptive) 
    attribute type { data.enumerated }?,
    empty
  }
meeting =
  
  ## contains the formalized descriptive title for a meeting or conference, for use in a
  ##     bibliographic description for an item derived from such a meeting, or as a heading or preamble
  ##     to publications emanating from it.
  element meeting { macro.limitedContent, att.global.attributes, empty }
imprint =
  
  ## groups information relating to the publication or distribution
  ##         of a bibliographic item.
  element imprint {
    ((model.imprintPart | model.dateLike), model.global*)+,
    att.global.attributes,
    empty
  }
publisher =
  
  ## provides the name of the organization responsible for the publication or distribution of a
  ##         bibliographic item.
  element publisher { macro.phraseSeq, att.global.attributes, empty }
biblScope =
  
  ## (scope of citation) defines the scope of a bibliographic reference, for example as a
  ##         list of page numbers, or a named subdivision of a larger work.
  element biblScope {
    macro.phraseSeq,
    att.global.attributes,
    
    ## identifies the type of information conveyed by the element, e.g.
    ##                 columns, pages, volume.
    ## Suggested values include: 1] vol(volume) ; 2] issue; 3] pp(pages) ; 4] ll (lines) ; 5] chap(chapter) ; 6] part
    attribute type {
      
      ## (volume) the element contains a volume number.
      "vol"
      | 
        ## the element contains an issue number, or volume and
        ##                         issue numbers.
        "issue"
      | 
        ## (pages) the element contains a page number or page range.
        "pp"
      | 
        ##  (lines) the element contains a line number or line range.
        "ll"
      | 
        ## (chapter) the element contains a chapter indication (number
        ##                         and/or title)
        "chap"
      | 
        ## the element identifies a part of a book or collection.
        "part"
      | xsd:Name
    }?,
    
    ## specifies the starting point of the range of units indicated by the type attribute.
    attribute from { data.word }?,
    
    ## specifies the end-point of the range of units indicated by the type attribute.
    attribute to { data.word }?,
    empty
  }
pubPlace =
  
  ## (publication place) contains the name of the place where a bibliographic item was published.
  element pubPlace {
    macro.phraseSeq, att.global.attributes, att.naming.attributes, empty
  }
bibl =
  
  ## (bibliographic citation) contains a loosely-structured bibliographic citation of which the sub-components may or may
  ##     not be explicitly tagged. 
  element bibl {
    (text
     | model.gLike
     | model.highlighted
     | model.pPart.data
     | model.pPart.edit
     | model.segLike
     | model.ptrLike
     | model.biblPart
     | model.global)*,
    att.global.attributes,
    att.declarable.attributes,
    att.typed.attributes,
    empty
  }
biblStruct =
  
  ## (structured bibliographic citation) contains a structured bibliographic citation, in which only bibliographic sub-elements
  ##     appear and in a specified order. 
  element biblStruct {
    (analytic*,
     (monogr, series*)+,
     (model.noteLike | idno | relatedItem)*),
    att.global.attributes,
    att.declarable.attributes,
    att.typed.attributes,
    empty
  }
listBibl =
  
  ## (citation list) contains a list of bibliographic citations of any kind. 
  element listBibl {
    (model.headLike*,
     (model.biblLike | model.milestoneLike | listBibl)+),
    att.global.attributes,
    att.declarable.attributes,
    att.typed.attributes,
    empty
  }
relatedItem =
  
  ## contains or references some other bibliographic item which is related to the present one in
  ##     some specified manner, for example as a constituent or alternative version of it.
  element relatedItem {
    ((model.biblLike | model.ptrLike)?)
    >> sch:pattern [
         id = "relatedItem-constraint-targetorcontent11"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "tei:relatedItem"
           "\x{a}" ~
           "               "
           sch:report [
             test = "@target and count( child::* ) > 0"
             "If the 'target' attribute is used, the\x{a}" ~
             "        relatedItem element must be empty"
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ]
    >> sch:pattern [
         id = "relatedItem-constraint-targetorcontent11"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "tei:relatedItem"
           "\x{a}" ~
           "               "
           sch:assert [
             test = "@target or child::*"
             "A relatedItem element should have either a 'target' attribute\x{a}" ~
             "        or a child element to indicate the related bibliographic item"
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    att.global.attributes,
    att.typed.attributes,
    
    ## points to the related bibliographic element by means of an
    ##       absolute or relative URI reference
    attribute target { data.pointer }?,
    empty
  }
l =
  
  ## (verse line) contains a single, possibly incomplete, line of verse.
  element l {
    macro.paraContent,
    att.global.attributes,
    
    ## specifies whether or not the line is metrically complete. 
    [ a:defaultValue = "N" ]
    attribute part {
      
      ## (yes) the line is metrically incomplete
      "Y"
      | 
        ## (no) either the line is complete, or no claim is made as to its completeness
        "N"
      | 
        ## (initial) the initial part of an incomplete line
        "I"
      | 
        ## (medial) a medial part of an incomplete line
        "M"
      | 
        ## (final) the final part of an incomplete line
        "F"
    }?,
    empty
  }
lg =
  
  ## (line group) contains a group of verse lines functioning as a formal unit, e.g. a stanza, refrain,
  ##         verse paragraph, etc.
  element lg {
    ((model.divTop | model.global)*,
     (model.lLike | lg),
     (model.lLike | lg | model.global)*,
     (model.divBottom, model.global*)*),
    att.global.attributes,
    att.divLike.attributes,
    att.typed.attributes,
    att.declaring.attributes,
    empty
  }
sp =
  
  ## (speech) An individual speech in a performance text, or a passage presented as such in a prose or
  ##     verse text.
  element sp {
    (model.global*,
     (speaker, model.global*)?,
     ((model.lLike | lg | model.pLike | model.stageLike | model.qLike),
      model.global*)+),
    att.global.attributes,
    att.ascribed.attributes,
    empty
  }
speaker =
  
  ## A specialized form of heading or label, giving the name of one or more speakers in a
  ##         dramatic text or fragment.
  element speaker { macro.phraseSeq, att.global.attributes, empty }
stage =
  
  ## (stage direction) contains any kind of stage direction within a dramatic text or fragment.
  element stage {
    macro.specialPara,
    att.global.attributes,
    
    ## indicates the kind of stage direction.
    ## Suggested values include: 1] setting; 2] entrance; 3] exit; 4] business; 5] novelistic; 6] delivery; 7] modifier; 8] location; 9] mixed
    attribute type {
      
      ## describes a setting.
      "setting"
      | 
        ## describes an entrance.
        "entrance"
      | 
        ## describes an exit.
        "exit"
      | 
        ## describes stage business.
        "business"
      | 
        ## is a narrative, motivating stage direction.
        "novelistic"
      | 
        ## describes how a character speaks.
        "delivery"
      | 
        ## gives some detail about a character.
        "modifier"
      | 
        ## describes a location.
        "location"
      | 
        ## more than one of the above
        "mixed"
      | xsd:Name
    }?,
    empty
  }
divGen =
  
  ## (automatically generated text division) indicates the location at which a textual division generated
  ##         automatically by a text-processing application is to appear.
  element divGen {
    model.headLike*,
    att.global.attributes,
    
    ## specifies what type of generated text division (e.g. index,
    ##                 table of contents, etc.) is to appear.
    ## Sample values include: 1] index; 2] toc; 3] figlist; 4] tablist
    attribute type { data.enumerated }?,
    empty
  }
teiHeader =
  
  ## (TEI Header) supplies the descriptive and declarative information making up an electronic title page
  ##     prefixed to every TEI-conformant text.
  element teiHeader {
    (fileDesc, model.teiHeaderPart*, revisionDesc?),
    att.global.attributes,
    
    ## specifies the kind of document to which the header is attached, for example whether it
    ##         is a corpus or individual text.
    ## Sample values include: 1] text; 2] corpus
    [ a:defaultValue = "text" ] attribute type { data.enumerated }?,
    empty
  }
fileDesc =
  
  ## (file description) contains a full bibliographic description of an electronic file.
  element fileDesc {
    ((titleStmt,
      editionStmt?,
      extent?,
      publicationStmt,
      seriesStmt?,
      notesStmt?),
     sourceDesc+),
    att.global.attributes,
    empty
  }
titleStmt =
  
  ## (title statement) groups information about the title of a work and those responsible for its intellectual
  ##     content.
  element titleStmt {
    (title+, model.respLike*), att.global.attributes, empty
  }
sponsor =
  
  ## specifies the name of a sponsoring organization or institution.
  element sponsor {
    macro.phraseSeq.limited, att.global.attributes, empty
  }
funder =
  
  ## (funding body) specifies the name of an individual, institution, or organization responsible for the
  ##     funding of a project or text.
  element funder {
    macro.phraseSeq.limited, att.global.attributes, empty
  }
principal =
  
  ## (principal researcher) supplies the name of the principal researcher responsible for the
  ## creation of an electronic text.
  element principal {
    macro.phraseSeq.limited, att.global.attributes, empty
  }
editionStmt =
  
  ## (edition statement) groups information relating to one edition of a text.
  element editionStmt {
    (model.pLike+ | (edition, respStmt*)),
    att.global.attributes,
    empty
  }
edition =
  
  ## (edition) describes the particularities of one edition of a text.
  element edition { macro.phraseSeq, att.global.attributes, empty }
extent =
  
  ## describes the approximate size of a text as stored on some carrier medium, whether digital
  ##     or non-digital, specified in any convenient units.
  element extent { macro.phraseSeq, att.global.attributes, empty }
publicationStmt =
  
  ## (publication statement) groups information concerning the publication or distribution of an electronic or other
  ##     text. 
  element publicationStmt {
    (model.pLike+ | model.publicationStmtPart+),
    att.global.attributes,
    empty
  }
distributor =
  
  ## supplies the name of a person or other agency responsible for the
  ## distribution of a text.
  element distributor { macro.phraseSeq, att.global.attributes, empty }
authority =
  
  ## (release authority) supplies the name of a person or other agency responsible for
  ##   making an electronic file available, other than a publisher or
  ##   distributor.
  element authority {
    macro.phraseSeq.limited, att.global.attributes, empty
  }
idno =
  
  ## (identifier) supplies any form of identifier used to identify some object,
  ##   such as a bibliographic item, a person, a title, an organization,
  ##   etc. in a standardized way.
  element idno {
    macro.xtext,
    att.global.attributes,
    
    ## categorizes the identifier, for example as an ISBN, Social
    ##       Security number, etc. 
    attribute type { data.enumerated }?,
    empty
  }
availability =
  
  ## supplies information about the availability of a text, for example any restrictions on its
  ##     use or distribution, its copyright status, etc.
  element availability {
    model.pLike+,
    att.global.attributes,
    att.declarable.attributes,
    
    ## supplies a code identifying the current availability of the text. 
    [ a:defaultValue = "unknown" ]
    attribute status {
      
      ## the text is freely available. 
      "free"
      | 
        ## the status of the text is unknown. 
        "unknown"
      | 
        ## the text is not freely available. 
        "restricted"
    }?,
    empty
  }
seriesStmt =
  
  ## (series statement) groups information about the series, if any, to which a publication belongs.
  element seriesStmt {
    (model.pLike+
     | (title+, (idno | respStmt)*)),
    att.global.attributes,
    empty
  }
notesStmt =
  
  ## (notes statement) collects together any notes providing information about a text additional to that recorded
  ##     in other parts of the bibliographic description.
  element notesStmt { model.noteLike+, att.global.attributes, empty }
sourceDesc =
  
  ## (source description) describes the source from which an electronic text was derived or generated, typically a
  ##     bibliographic description in the case of a digitized text, or a phrase such as "born digital"
  ##     for a text which has no previous existence.
  element sourceDesc {
    (model.pLike+
     | (model.biblLike | model.sourceDescPart | model.listLike)+),
    att.global.attributes,
    att.declarable.attributes,
    empty
  }
biblFull =
  
  ## (fully-structured bibliographic citation) contains a fully-structured bibliographic citation, in which all components of the TEI file
  ##     description are present.
  element biblFull {
    ((titleStmt,
      editionStmt?,
      extent?,
      publicationStmt,
      seriesStmt?,
      notesStmt?),
     sourceDesc*),
    att.global.attributes,
    att.declarable.attributes,
    empty
  }
encodingDesc =
  
  ## (encoding description) documents the relationship between an electronic text and the
  ## source or sources from which it was derived.
  element encodingDesc {
    (model.encodingDescPart | model.pLike)+,
    att.global.attributes,
    empty
  }
projectDesc =
  
  ## (project description) describes in detail the aim or purpose for which an electronic file was encoded, together
  ##     with any other relevant information concerning the process by which it was assembled or
  ##     collected.
  element projectDesc {
    model.pLike+,
    att.global.attributes,
    att.declarable.attributes,
    empty
  }
samplingDecl =
  
  ## (sampling declaration) contains a prose description of the rationale and methods used in sampling texts in the
  ##     creation of a corpus or collection.
  element samplingDecl {
    model.pLike+,
    att.global.attributes,
    att.declarable.attributes,
    empty
  }
editorialDecl =
  
  ## (editorial practice declaration) provides details of editorial principles and practices applied
  ## during the encoding of a text.
  element editorialDecl {
    (model.pLike | model.editorialDeclPart)+,
    att.global.attributes,
    att.declarable.attributes,
    empty
  }
correction =
  
  ## (correction principles) states how and under what circumstances corrections have been made in the text.
  element correction {
    model.pLike+,
    att.global.attributes,
    att.declarable.attributes,
    
    ## indicates the degree of correction applied to the text. 
    [ a:defaultValue = "unknown" ]
    attribute status {
      
      ## the text has been thoroughly checked and proofread. 
      "high"
      | 
        ## the text has been checked at least once. 
        "medium"
      | 
        ## the text has not been checked. 
        "low"
      | 
        ## the correction status of the text is unknown. 
        "unknown"
    }?,
    
    ## indicates the method adopted to indicate corrections within the text. 
    [ a:defaultValue = "silent" ]
    attribute method {
      
      ## corrections have been made silently 
      "silent"
      | 
        ## corrections have been represented using markup
        "markup"
    }?,
    empty
  }
normalization =
  
  ## indicates the extent of normalization or regularization of the original source carried out
  ##     in converting it to electronic form.
  element normalization {
    model.pLike+,
    att.global.attributes,
    att.declarable.attributes,
    
    ## indicates the authority for any normalization carried out. 
    attribute source { data.pointer }?,
    
    ## indicates the method adopted to indicate normalizations within the text. 
    [ a:defaultValue = "silent" ]
    attribute method {
      
      ## normalization made silently 
      "silent"
      | 
        ## normalization represented using markup 
        "markup"
    }?,
    empty
  }
quotation =
  
  ## specifies editorial practice adopted with respect to quotation marks in the original. 
  element quotation {
    model.pLike+,
    att.global.attributes,
    att.declarable.attributes,
    
    ## (quotation marks) indicates whether or not quotation marks have been retained as content within the text. 
    [ a:defaultValue = "all" ]
    attribute marks {
      
      ## no quotation marks have been retained 
      "none"
      | 
        ## some quotation marks have been retained 
        "some"
      | 
        ## all quotation marks have been retained 
        "all"
    }?,
    
    ## specifies how quotation marks are indicated within the text.
    [ a:defaultValue = "unknown" ] attribute form { text }?,
    empty
  }
hyphenation =
  
  ## summarizes the way in which hyphenation in a source text has been treated in an encoded
  ##     version of it.
  element hyphenation {
    model.pLike+,
    att.global.attributes,
    att.declarable.attributes,
    
    ## (end-of-line) indicates whether or not end-of-line hyphenation has been retained in a text.
    [ a:defaultValue = "some" ]
    attribute eol {
      
      ## all end-of-line hyphenation has been retained, even though the lineation of the
      ##             original may not have been. 
      "all"
      | 
        ## end-of-line hyphenation has been retained in some cases. 
        "some"
      | 
        ## all soft end-of-line hyphenation has been removed: any remaining end-od-line
        ##             hyphenation should be retained. 
        "hard"
      | 
        ## all end-of-line hyphenation has been removed: any remaining hyphenation occurred
        ##             within the line. 
        "none"
    }?,
    empty
  }
segmentation =
  
  ## describes the principles according to which the text has been segmented, for example into
  ##     sentences, tone-units, graphemic strata, etc.
  element segmentation {
    model.pLike+,
    att.global.attributes,
    att.declarable.attributes,
    empty
  }
stdVals =
  
  ## (standard values) specifies the format used when standardized date or number values are supplied.
  element stdVals {
    model.pLike+,
    att.global.attributes,
    att.declarable.attributes,
    empty
  }
interpretation =
  
  ## describes the scope of any analytic or interpretive information added to the text in
  ##     addition to the transcription. 
  element interpretation {
    model.pLike+,
    att.global.attributes,
    att.declarable.attributes,
    empty
  }
tagsDecl =
  
  ## (tagging declaration) provides detailed information about the tagging applied to a document.
  element tagsDecl {
    (rendition*, \namespace*), att.global.attributes, empty
  }
tagUsage =
  
  ## supplies information about the usage of a specific element within a text. 
  element tagUsage {
    macro.limitedContent,
    att.global.attributes,
    
    ## (element name) the name (generic identifier) of the element indicated by the tag.
    attribute gi { data.name },
    
    ## specifies the number of occurrences of this element within the text.
    attribute occurs { data.count }?,
    
    ## (with unique identifier) specifies the number of occurrences of this element within the text which bear a
    ##         distinct value for the global xml:id attribute. 
    attribute withId { data.count }?,
    
    ## specifies the identifier of a rendition element which defines how this element
    ##         is to be rendered.
    attribute render { data.pointer }?,
    empty
  }
\namespace =
  
  ## supplies the formal name of the namespace to which the elements documented by its children
  ##     belong. 
  element namespace {
    tagUsage+,
    att.global.attributes,
    
    ## the full formal name of the namespace concerned.
    attribute name { data.namespace },
    empty
  }
rendition =
  
  ## supplies information about the rendition or appearance of one or more elements in the source
  ##     text.
  element rendition {
    macro.limitedContent,
    att.global.attributes,
    
    ## identifies the language used to describe the rendition.
    attribute scheme {
      
      ## Cascading Stylesheet Language
      "css"
      | 
        ## Extensible Stylesheet Language Formatting Objects
        "xslfo"
      | 
        ## Informal free text description
        "free"
      | 
        ## A user-defined rendition description language
        "other"
    }?,
    
    ## where CSS is used, provides a way of defining
    ## pseudo-elements, that is, styling rules
    ## applicable to specific sub-portions of an element.
    attribute scope { text }?,
    empty
  }
refsDecl =
  
  ## (references declaration) specifies how canonical references are constructed for this
  ##   text.
  element refsDecl {
    (model.pLike+ | cRefPattern+ | refState+),
    att.global.attributes,
    att.declarable.attributes,
    empty
  }
cRefPattern =
  
  ## (canonical reference pattern) specifies an expression and replacement pattern for transforming a canonical reference into
  ##     a URI. 
  element cRefPattern {
    model.pLike*,
    att.global.attributes,
    
    ## specifies a regular expression against which the values of cRef attributes
    ##         can be matched.
    attribute matchPattern { data.pattern },
    
    ## specifies a replacement pattern which, once subpattern substitution
    ##         has been performed, provides a URI.
    attribute replacementPattern { text },
    empty
  }
refState =
  
  ## (reference state) specifies one component of a canonical reference defined by the milestone method.
  element refState {
    empty,
    att.global.attributes,
    att.sourced.attributes,
    
    ## indicates what kind of state is changing at this milestone.
    ## Suggested values include: 1] page; 2] column; 3] line; 4] book; 5] poem; 6] canto; 7] stanza; 8] act; 9] scene; 10] section; 11] absent
    attribute unit {
      
      ## page breaks in the reference edition. 
      "page"
      | 
        ## column breaks. 
        "column"
      | 
        ## line breaks. 
        "line"
      | 
        ## any units termed book, liber, etc. 
        "book"
      | 
        ## individual poems in a collection. 
        "poem"
      | 
        ## cantos or other major sections of a poem. 
        "canto"
      | 
        ## stanzas within a poem, book, or canto. 
        "stanza"
      | 
        ## acts within a play. 
        "act"
      | 
        ## scenes within a play or act. 
        "scene"
      | 
        ## sections of any kind. 
        "section"
      | 
        ## passages not present in the reference edition.
        "absent"
      | xsd:Name
    },
    
    ## specifies the fixed length of the reference component.
    attribute length { data.count }?,
    
    ## (delimiter) supplies a delimiting string following the reference component.
    attribute delim { text }?,
    empty
  }
classDecl =
  
  ## (classification declarations) contains one or more taxonomies defining any classificatory
  ## codes used elsewhere in the text.
  element classDecl { taxonomy+, att.global.attributes, empty }
taxonomy =
  
  ## defines a typology used to classify texts either implicitly, by means of a bibliographic
  ##     citation, or explicitly by a structured taxonomy.
  element taxonomy {
    (model.glossLike* | category+ | (model.biblLike, category*)),
    att.global.attributes,
    empty
  }
category =
  
  ## contains an individual descriptive category, possibly nested within a superordinate
  ##     category, within a user-defined taxonomy.
  element category {
    ((catDesc+ | model.glossLike*), category*),
    att.global.attributes,
    empty
  }
catDesc =
  
  ## (category description) describes some category within a taxonomy or text typology, either in the form of a brief
  ##     prose description or in terms of the situational parameters used by the TEI formal textDesc.
  element catDesc {
    (text | model.limitedPhrase | model.catDescPart)*,
    att.global.attributes,
    empty
  }
appInfo =
  
  ## (application information) records information about an application which has
  ##   edited the TEI file. 
  element appInfo {
    model.applicationLike+, att.global.attributes, empty
  }
application =
  
  ## provides information about an application which has acted upon the document.
  element application {
    (model.labelLike+, (model.ptrLike* | model.pLike*)),
    att.global.attributes,
    att.typed.attributes,
    att.datable.attributes,
    
    ## Supplies an identifier for the application, independent of its version number or display
    ##         name.
    attribute ident { data.name },
    
    ## Supplies a version number for the application, independent of its identifier or display
    ##         name.
    attribute version {
      xsd:token {
        pattern = "[\d]+[a-z]*[\d]*(\.[\d]+[a-z]*[\d]*){0,3}"
      }
    },
    empty
  }
profileDesc =
  
  ## (text-profile description) provides a detailed description of non-bibliographic aspects of a text, specifically the
  ##     languages and sublanguages used, the situation in which it was produced, the participants and
  ##     their setting.
  element profileDesc {
    model.profileDescPart*, att.global.attributes, empty
  }
creation =
  
  ## contains information about the creation of a text.
  element creation {
    macro.phraseSeq.limited, att.global.attributes, empty
  }
langUsage =
  
  ## (language usage) describes the languages, sublanguages, registers, dialects, etc.
  ## represented within a text.
  element langUsage {
    language+, att.global.attributes, att.declarable.attributes, empty
  }
language =
  
  ## characterizes a single language or sublanguage used within a text.
  element language {
    macro.phraseSeq.limited,
    att.global.attributes,
    
    ## (identifier) Supplies a language code constructed as defined in BCP 47 which is used to identify the
    ##         language documented by this element, and which is referenced by the global
    ##         xml:lang attribute.
    attribute ident { data.language },
    
    ## specifies the approximate percentage (by volume) of the text which uses this language. 
    attribute usage {
      xsd:nonNegativeInteger { maxInclusive = "100" }
    }?,
    empty
  }
textClass =
  
  ## (text classification) groups information which describes the nature or topic of a text in terms of a standard
  ##     classification scheme, thesaurus, etc.
  element textClass {
    (classCode | catRef | keywords)*,
    att.global.attributes,
    att.declarable.attributes,
    empty
  }
keywords =
  
  ## contains a list of keywords or phrases identifying the topic or nature of a text.
  element keywords {
    (term+ | \list),
    att.global.attributes,
    
    ## identifies the controlled vocabulary within which the set of keywords concerned is
    ##         defined. 
    attribute scheme { data.pointer },
    empty
  }
classCode =
  
  ## (classification code) contains the classification code used for this text in some standard classification system.
  element classCode {
    macro.phraseSeq.limited,
    att.global.attributes,
    
    ## identifies the classification system or taxonomy in use.
    attribute scheme { data.pointer },
    empty
  }
catRef =
  
  ## (category reference) specifies one or more defined categories within some taxonomy or text typology.
  element catRef {
    empty,
    att.global.attributes,
    att.pointing.attributes,
    
    ## identifies the classification scheme within which the set of categories concerned is
    ##         defined 
    attribute scheme { data.pointer }?,
    empty
  }
revisionDesc =
  
  ## (revision description) summarizes the revision history for a file.
  element revisionDesc {
    (\list | change+),
    att.global.attributes,
    att.docStatus.attributes,
    empty
  }
change =
  
  ## summarizes a particular change or correction made to a particular version of an electronic
  ##     text which is shared between several researchers.
  element change {
    (text | model.limitedPhrase | model.inter | model.global)*,
    att.global.attributes,
    att.ascribed.attributes,
    att.datable.attributes,
    att.docStatus.attributes,
    empty
  }
geoDecl =
  
  ## (geographic coordinates declaration) documents the notation and the datum used for geographic coordinates expressed as content of
  ##     the geo element elsewhere within the document.
  element geoDecl {
    macro.phraseSeq,
    att.global.attributes,
    att.declarable.attributes,
    
    ## supplies a commonly used code name for the datum employed.
    ## Suggested values include: 1] WGS84(World Geodetic System) ; 2] MGRS(Military Grid Reference System) ; 3] OSGB36(ordnance survey great britain) ; 4] ED50(European Datum coordinate system) 
    [ a:defaultValue = "WGS84" ]
    attribute datum {
      
      ## (World Geodetic System) a pair of numbers to be interpreted as latitude followed by longitude according to
      ##             the World Geodetic System.
      "WGS84"
      | 
        ## (Military Grid Reference System) the values supplied are geospatial entity object codes, based on
        "MGRS"
      | 
        ## (ordnance survey great britain) the value supplied is to be interpreted as a British National Grid Reference.
        "OSGB36"
      | 
        ## (European Datum coordinate system) the value supplied is to be interpreted as latitude followed by longitude according
        ##             to the European Datum coordinate system.
        "ED50"
      | xsd:Name
    }?,
    empty
  }
g =
  
  ## (character or glyph) represents a non-standard character or glyph.
  element g {
    text,
    att.global.attributes,
    att.typed.attributes,
    
    ## points to a description of the character or glyph intended.
    attribute ref { data.pointer }?,
    empty
  }
char =
  
  ## (character) provides descriptive information about a character. 
  element char {
    (charName?,
     model.glossLike*,
     charProp*,
     mapping*,
     figure*,
     model.graphicLike*,
     model.noteLike*),
    att.global.attributes,
    empty
  }
charName =
  
  ## (character name) contains the name of a character, expressed following Unicode conventions. 
  element charName { text, att.global.attributes, empty }
charProp =
  
  ## (character property) provides a name and value for some property of the parent character or glyph. 
  element charProp {
    ((unicodeName | localName), value),
    att.global.attributes,
    att.typed.attributes,
    empty
  }
charDecl =
  
  ## (character declarations) provides information about nonstandard characters and glyphs. 
  element charDecl {
    (desc?, (char | glyph)+),
    att.global.attributes,
    empty
  }
glyph =
  
  ## (character glyph) provides descriptive information about a character glyph. 
  element glyph {
    (glyphName?,
     model.glossLike*,
     charProp*,
     mapping*,
     figure*,
     model.graphicLike*,
     model.noteLike*),
    att.global.attributes,
    empty
  }
glyphName =
  
  ## (character glyph name) contains the name of a glyph, expressed following Unicode conventions for character names. 
  element glyphName { text, att.global.attributes, empty }
localName =
  
  ## (locally-defined property name) contains a locally defined name for some property. 
  element localName { text, att.global.attributes, empty }
mapping =
  
  ## (character mapping) contains one or more
  ##	 characters which are related to the parent character or glyph
  ##	 in some respect, as specified by the type
  ##	 attribute.
  ##
  element mapping {
    macro.xtext, att.global.attributes, att.typed.attributes, empty
  }
unicodeName =
  
  ## (unicode property name) contains the name of a registered Unicode normative or informative property. 
  element unicodeName {
    text,
    att.global.attributes,
    
    ## specifies the version number of the Unicode Standard in which this property name is
    ##         defined.
    attribute version { data.version }?,
    empty
  }
value =
  
  ## (value) contains a single value for some property, attribute, or other
  ##   analysis.
  element value { macro.xtext, att.global.attributes, empty }
TEI =
  
  ## (TEI document) contains a single TEI-conformant document,
  ## comprising a TEI header and a text, either in isolation or as part of a
  ## teiCorpus element.
  element TEI {
    (teiHeader,
     ((model.resourceLike+, \text?) | \text))
    >> sch:ns [ prefix = "tei" uri = "http://www.tei-c.org/ns/1.0" ]
    >> sch:ns [
         prefix = "rng"
         uri = "http://relaxng.org/ns/structure/1.0"
       ],
    att.global.attributes,
    
    ## specifies the version number of the TEI Guidelines against
    ##       which this document is valid.
    attribute version { data.version }?,
    empty
  }
\text =
  
  ## contains a single text of any kind, whether unitary or composite, for example a poem or
  ##     drama, a collection of essays, a novel, a dictionary, or a corpus sample.
  element text {
    (model.global*,
     (front, model.global*)?,
     (body | group),
     model.global*,
     (back, model.global*)?),
    att.global.attributes,
    att.declaring.attributes,
    att.typed.attributes,
    empty
  }
body =
  
  ## (text body) contains the whole body of a single unitary text, excluding any front or back matter.
  element body {
    (model.global*,
     (model.divTop, (model.global | model.divTop)*)?,
     (model.divGenLike, (model.global | model.divGenLike)*)?,
     ((model.divLike, (model.global | model.divGenLike)*)+
      | (model.div1Like, (model.global | model.divGenLike)*)+
      | ((model.common, model.global*)+,
         ((model.divLike, (model.global | model.divGenLike)*)+
          | (model.div1Like, (model.global | model.divGenLike)*)+)?)),
     (model.divBottom, model.global*)*),
    att.global.attributes,
    att.declaring.attributes,
    empty
  }
group =
  
  ## contains the body of a composite text, grouping together a sequence of distinct texts (or
  ##     groups of such texts) which are regarded as a unit for some purpose, for example the collected
  ##     works of an author, a sequence of prose essays, etc.
  element group {
    ((model.divTop | model.global)*,
     ((\text | group), (\text | group | model.global)*),
     model.divBottom*),
    att.global.attributes,
    att.declaring.attributes,
    empty
  }
floatingText =
  
  ## contains a single text of any kind, whether unitary or composite, which interrupts the text
  ##     containing it at any point and after which the surrounding text resumes.
  element floatingText {
    (model.global*,
     (front, model.global*)?,
     (body | group),
     model.global*,
     (back, model.global*)?),
    att.global.attributes,
    att.declaring.attributes,
    att.typed.attributes,
    empty
  }
\div =
  
  ## (text division) contains a subdivision of the front, body, or back of a text.
  element div {
    ((model.divTop | model.global)*,
     ((((model.divLike | model.divGenLike), model.global*)+
       | ((model.common, model.global*)+,
          ((model.divLike | model.divGenLike), model.global*)*)),
      (model.divBottom, model.global*)*)?),
    att.global.attributes,
    att.divLike.attributes,
    att.typed.attributes,
    att.declaring.attributes,
    empty
  }
div1 =
  
  ## (level-1 text division) contains a first-level subdivision of the front, body, or back of a text.
  element div1 {
    ((model.divTop | model.global)*,
     ((((model.div2Like | model.divGenLike), model.global*)+
       | ((model.common, model.global*)+,
          ((model.div2Like | model.divGenLike), model.global*)*)),
      (model.divBottom, model.global*)*)?),
    att.global.attributes,
    att.divLike.attributes,
    att.typed.attributes,
    att.declaring.attributes,
    empty
  }
div2 =
  
  ## (level-2 text division) contains a second-level subdivision of the front, body, or back of a
  ##  text.
  element div2 {
    ((model.divTop | model.global)*,
     ((((model.div3Like | model.divGenLike), model.global*)+
       | ((model.common, model.global*)+,
          ((model.div3Like | model.divGenLike), model.global*)*)),
      (model.divBottom, model.global*)*)?),
    att.global.attributes,
    att.divLike.attributes,
    att.typed.attributes,
    att.declaring.attributes,
    empty
  }
div3 =
  
  ## (level-3 text division) contains a third-level subdivision of the front, body, or back of a text.
  element div3 {
    ((model.divTop | model.global)*,
     ((((model.div4Like | model.divGenLike), model.global*)+
       | ((model.common, model.global*)+,
          ((model.div4Like | model.divGenLike), model.global*)*)),
      (model.divBottom, model.global*)*)?),
    att.global.attributes,
    att.divLike.attributes,
    att.typed.attributes,
    att.declaring.attributes,
    empty
  }
div4 =
  
  ## (level-4 text division) contains a fourth-level subdivision of the front, body, or back of a text.
  element div4 {
    ((model.divTop | model.global)*,
     ((((model.div5Like | model.divGenLike), model.global*)+
       | ((model.common, model.global*)+,
          ((model.div5Like | model.divGenLike), model.global*)*)),
      (model.divBottom, model.global*)*)?),
    att.global.attributes,
    att.divLike.attributes,
    att.typed.attributes,
    att.declaring.attributes,
    empty
  }
div5 =
  
  ## (level-5 text division) contains a fifth-level subdivision of the front, body, or back of a text.
  element div5 {
    ((model.divTop | model.global)*,
     ((((model.div6Like | model.divGenLike), model.global*)+
       | ((model.common, model.global*)+,
          ((model.div6Like | model.divGenLike), model.global*)*)),
      (model.divBottom, model.global*)*)?),
    att.global.attributes,
    att.divLike.attributes,
    att.typed.attributes,
    att.declaring.attributes,
    empty
  }
div6 =
  
  ## (level-6 text division) contains a sixth-level subdivision of the front, body, or back of a text.
  element div6 {
    ((model.divTop | model.global)*,
     ((((model.div7Like | model.divGenLike), model.global*)+
       | ((model.common, model.global*)+,
          ((model.div7Like | model.divGenLike), model.global*)*)),
      (model.divBottom, model.global*)*)?),
    att.global.attributes,
    att.divLike.attributes,
    att.typed.attributes,
    att.declaring.attributes,
    empty
  }
div7 =
  
  ## (level-7 text division) contains the smallest possible subdivision of the front, body or back of a text, larger than
  ##     a paragraph.
  element div7 {
    ((model.divTop | model.global)*,
     ((model.common, model.global*)+,
      (model.divBottom, model.global*)*)?),
    att.global.attributes,
    att.divLike.attributes,
    att.typed.attributes,
    att.declaring.attributes,
    empty
  }
trailer =
  
  ## contains a closing title or footer appearing at the end of a division of a text. 
  element trailer { macro.phraseSeq, att.global.attributes, empty }
byline =
  
  ## contains the primary statement of responsibility given for a work
  ## on its title page or at the head or end of the work.
  element byline {
    (text | model.gLike | model.phrase | docAuthor | model.global)*,
    att.global.attributes,
    empty
  }
dateline =
  
  ## contains a brief description of the place, date, time, etc. of production of a letter,
  ##     newspaper story, or other work, prefixed or suffixed to it as a kind of heading or trailer. 
  element dateline { macro.phraseSeq, att.global.attributes, empty }
argument =
  
  ## A formal list or prose description of the topics addressed by
  ##	a subdivision of a text.
  element argument {
    ((model.global | model.headLike)*, (model.common, model.global*)+),
    att.global.attributes,
    empty
  }
epigraph =
  
  ## contains a quotation, anonymous or attributed, appearing at the start of a section or
  ##     chapter, or on a title page. 
  element epigraph {
    (model.common | model.global)*, att.global.attributes, empty
  }
opener =
  
  ## groups together dateline, byline, salutation, and similar phrases appearing as a preliminary
  ##     group at the start of a division, especially of a letter.
  element opener {
    (text
     | model.gLike
     | model.phrase
     | argument
     | byline
     | dateline
     | epigraph
     | salute
     | signed
     | model.global)*,
    att.global.attributes,
    empty
  }
closer =
  
  ## groups together salutations, datelines, and similar phrases appearing as a final group at
  ##     the end of a division, especially of a letter.
  element closer {
    (text
     | model.gLike
     | signed
     | dateline
     | salute
     | model.phrase
     | model.global)*,
    att.global.attributes,
    empty
  }
salute =
  
  ## (salutation) contains a salutation or greeting prefixed to a foreword, dedicatory epistle, or other
  ##     division of a text, or the salutation in the closing of a letter, preface, etc.
  element salute { macro.phraseSeq, att.global.attributes, empty }
signed =
  
  ## (signature) contains the closing salutation, etc., appended to a foreword,
  ## dedicatory epistle, or other division of a text. 
  element signed { macro.phraseSeq, att.global.attributes, empty }
postscript =
  
  ## contains a postscript, e.g. to a letter.
  element postscript {
    (model.common | model.global)*, att.global.attributes, empty
  }
titlePage =
  
  ## (title page) contains the title page of a text, appearing within the front or back matter. 
  element titlePage {
    (model.global*,
     model.titlepagePart,
     (model.titlepagePart | model.global)*),
    att.global.attributes,
    
    ## classifies the title page according to any convenient typology.
    attribute type { data.enumerated }?,
    empty
  }
docTitle =
  
  ## (document title) contains the title of a document, including all its
  ## constituents, as given on a title page.
  element docTitle {
    (model.global*, (titlePart, model.global*)+),
    att.global.attributes,
    att.canonical.attributes,
    empty
  }
titlePart =
  
  ## contains a subsection or division of the title of a work, as
  ## indicated on a title page.
  element titlePart {
    macro.paraContent,
    att.global.attributes,
    
    ## specifies the role of this subdivision of the title.
    ## Suggested values include: 1] main; 2] sub(subordinate) ; 3] alt(alternate) ; 4] short; 5] desc(descriptive) 
    [ a:defaultValue = "main" ]
    attribute type {
      
      ## main title of the work
      ##         
      "main"
      | 
        ## (subordinate) subtitle  of the work
        ##         
        "sub"
      | 
        ## (alternate) alternative title  of the work
        ##         
        "alt"
      | 
        ## abbreviated form of title
        "short"
      | 
        ## (descriptive) descriptive paraphrase of the work 
        ##    
        "desc"
      | xsd:Name
    }?,
    empty
  }
docAuthor =
  
  ## (document author) contains the name of the author of the document, as given on the
  ## title page (often but not always contained in a byline).
  element docAuthor {
    macro.phraseSeq,
    att.global.attributes,
    att.canonical.attributes,
    empty
  }
imprimatur =
  
  ## contains a formal statement authorizing the publication of a work, sometimes required to
  ##     appear on a title page or its verso.
  element imprimatur { macro.paraContent, att.global.attributes, empty }
docEdition =
  
  ## (document edition) contains an edition statement as presented on a title page of a
  ## document.
  element docEdition { macro.paraContent, att.global.attributes, empty }
docImprint =
  
  ## (document imprint) contains the imprint statement (place and date of publication,
  ## publisher name), as given
  ## (usually) at the foot of a title page.
  element docImprint {
    (text
     | model.gLike
     | model.phrase
     | pubPlace
     | docDate
     | publisher
     | model.global)*,
    att.global.attributes,
    empty
  }
docDate =
  
  ## (document date) contains the date of a document, as given
  ## (usually) on a title page.
  element docDate {
    macro.phraseSeq,
    att.global.attributes,
    
    ## gives the value of the date in standard form, i.e. YYYY-MM-DD.
    attribute when { data.temporal.w3c }?,
    empty
  }
front =
  
  ## (front matter) contains any prefatory matter (headers,
  ## title page, prefaces, dedications, etc.)
  ## found  at the start of a document, before the main body.
  element front {
    ((model.frontPart | model.pLike.front | model.global)*,
     ((model.div1Like,
       (model.frontPart | model.div1Like | model.global)*)
      | (model.divLike,
         (model.frontPart | model.divLike | model.global)*))?,
     (model.divBottomPart, (model.divBottomPart | model.global)*)?),
    att.global.attributes,
    att.declaring.attributes,
    empty
  }
back =
  
  ## (back matter) contains any appendixes, etc. following the main part of a text.
  element back {
    ((model.frontPart | model.pLike.front | model.global)*,
     ((model.div1Like,
       (model.frontPart | model.div1Like | model.global)*)
      | (model.divLike,
         (model.frontPart | model.divLike | model.global)*))?,
     (model.divBottomPart, (model.divBottomPart | model.global)*)?),
    att.global.attributes,
    att.declaring.attributes,
    empty
  }
att =
  
  ## (attribute) contains the name of an attribute appearing within running text.
  element att {
    text,
    att.global.attributes,
    
    ## supplies an identifier for the scheme in which this name is defined.
    ## Sample values include: 1] TEI(text encoding initiative) ; 2] DBK(docbook) ; 3] XX(unknown) 
    [ a:defaultValue = "TEI" ] attribute scheme { data.enumerated }?,
    empty
  }
code =
  
  ## contains literal code from some formal language such as a
  ## programming language.
  element code {
    text,
    att.global.attributes,
    
    ## (formal language) a name identifying the formal language in which  the
    ##	code is expressed
    attribute lang { data.word }?,
    empty
  }
eg =
  
  ## (example) contains any kind of illustrative example. 
  element eg { text, att.global.attributes, empty }
egXML =
  
  ## (example of XML) contains a single well-formed XML fragment demonstrating the use of some XML element or
  ##     attribute, in which the egXML element itself functions as the root element. 
  element teix:egXML {
    (text | macro.anyXML)*,
    att.global.attributes,
    
    ## indicates the intended validity of the example with respect to
    ## a schema.
    [ a:defaultValue = "true" ]
    attribute valid {
      
      ## the example is intended to be fully valid,
      ## assuming that its root element can be used as the root element in the
      ## schema concerned.
      "true"
      | 
        ## the example could be transformed into
        ## a valid document by inserting any number of valid attributes and child
        ## elements anywhere within it; it is valid against a version of the
        ## schema concerned in which every data, list, element, or attribute
        ## element has been made optional.
        "feasible"
      | 
        ## the example is not intended to be valid,
        ## and contains deliberate errors.
        "false"
    }?,
    empty
  }
gi =
  
  ## (element name) contains the name (generic identifier) of an element.
  element gi {
    text,
    att.global.attributes,
    
    ## supplies the name of the scheme in which this name is defined.
    ## Sample values include: 1] TEI(text encoding initiative) ; 2] DBK(docbook) ; 3] XX(unknown) ; 4] Schematron; 5] HTML
    [ a:defaultValue = "TEI" ] attribute scheme { data.enumerated }?,
    empty
  }
ident =
  
  ## (identifier) contains an identifier or name for an object of some kind in a formal language.
  element ident {
    text, att.global.attributes, att.typed.attributes, empty
  }
tag =
  
  ## contains text of a complete start- or end-tag, possibly including attribute specifications,
  ##     but excluding the opening and closing markup delimiter characters.
  element tag {
    text,
    att.global.attributes,
    
    ## indicates the type of XML tag intended
    attribute type {
      
      ## a start-tag, with delimiters < and > is intended
      "start"
      | 
        ## an end-tag, with delimiters </ and > is intended
        "end"
      | 
        ## a empty tag, with delimiters < and /> is intended
        "empty"
      | 
        ## a pi (processing instruction), with delimiters <? and ?> is intended
        "pi"
      | 
        ## a comment, with delimiters <!-- and --> is intended
        "comment"
      | 
        ## a marked-section, with delimiters <[CDATA[ and ]]> is intended
        "ms"
    }?,
    
    ## supplies the name of the schema in which this tag is defined.
    [ a:defaultValue = "TEI" ]
    attribute scheme {
      
      ## (text encoding initiative) This tag is defined as part of the TEI scheme.
      "TEI"
      | 
        ## (docbook) this tag is part of the Docbook scheme.
        "DBK"
      | 
        ## (unknown) this tag is part of an unknown scheme.
        "XX"
    }?,
    empty
  }
val =
  
  ## (value) contains a single attribute value.
  element val { text, att.global.attributes, empty }
specList =
  
  ## (specification list) marks where a list of descriptions is to be inserted into the prose documentation.
  element specList { specDesc+, att.global.attributes, empty }
specDesc =
  
  ## (specification description) indicates that a description of the specified element or class should be included at this
  ##     point within a document.
  element specDesc {
    empty,
    att.global.attributes,
    
    ## (identifier) supplies the identifier of the documentary element or class for which a description is
    ##         to be obtained.
    attribute key { data.name }?,
    
    ## (attributes) supplies attribute names for which descriptions should additionally be obtained.
    attribute atts {
      list { data.name* }
    }?,
    empty
  }
classRef =
  
  ## points to the specification for an attribute or model class which is to be included in a schema
  element classRef {
    empty,
    att.global.attributes,
    att.readFrom.attributes,
    
    ## the identifier used for the required class within the
    ##	source indicated.
    attribute key { xsd:NCName },
    empty
  }
elementRef =
  
  ## points to the specification for some element which is to be included in a schema
  element elementRef {
    empty,
    att.global.attributes,
    att.readFrom.attributes,
    
    ## the identifier used for the required element within the
    ##	source indicated.
    attribute key { xsd:NCName },
    empty
  }
macroRef =
  
  ## points to the specification for some pattern which is to be included in a schema
  element macroRef {
    empty,
    att.global.attributes,
    att.readFrom.attributes,
    
    ## the identifier used for the required pattern within the
    ##	source indicated.
    attribute key { xsd:NCName },
    empty
  }
moduleRef =
  
  ## (module reference) references a module which is to be incorporated into a schema.
  element moduleRef {
    (content?)
    >> sch:pattern [
         id = "moduleRef-constraint-modref"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "tei:moduleRef"
           "\x{a}" ~
           "               "
           sch:report [
             test = "* and @key"
             "\x{a}" ~
             "	  child elements of moduleRef are only allowed when an external module\x{a}" ~
             "	  is being loaded\x{a}" ~
             "	"
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    att.global.attributes,
    att.readFrom.attributes,
    (
     ## supplies a list of the elements which are to be copied from the
     ## specified module into the schema being defined.
     attribute include {
       list { xsd:NCName* }
     }?
     | 
       ## supplies a list of the elements which are not to be copied from the
       ## specified module into the schema being defined.
       attribute except {
         list { xsd:NCName* }
       }?),
    (
     ## the name of a TEI module
     attribute key { xsd:NCName }?
     | 
       ## (uniform resource locator) refers to a non-TEI module of RELAX NG code by external location 
       attribute url { data.pointer }?),
    empty
  }
moduleSpec =
  
  ## (module specification) documents the structure, content, and purpose of a single
  ## module, i.e. a named and externally visible group of declarations.
  element moduleSpec {
    (model.glossLike*, exemplum*, remarks?, listRef*),
    att.global.attributes,
    att.identified.attributes,
    
    ## type of module to be generated
    attribute type { text }?,
    empty
  }
schemaSpec =
  
  ## (schema specification) generates a TEI-conformant schema and documentation for it.
  element schemaSpec {
    (model.glossLike*,
     (model.oddRef | model.oddDecl)*,
     constraintSpec*),
    att.global.attributes,
    att.identified.attributes,
    att.readFrom.attributes,
    
    ## specifies entry points to the schema, i.e. which elements
    ##       may be used as the root of documents conforming to
    ##       it. 
    [ a:defaultValue = "TEI" ]
    attribute start {
      list { data.name, data.name* }
    }?,
    
    ## (namespace) specifies the default namespace (if any) applicable to 
    ##       components of the schema.
    [ a:defaultValue = "http://www.tei-c.org/ns/1.0" ]
    attribute ns { data.namespace }?,
    
    ## specifies a default prefix which will be prepended to all patterns
    ##       relating to TEI elements, unless otherwise stated. This allows for external schemas to be mixed in
    ##       which have elements of the same names as the TEI.
    ##       
    attribute prefix { "" | data.name }?,
    
    ## (target language) specifies which language to use when creating
    ##       the objects in a schema if names for elements or attributes are available in more
    ##       than one language, .
    attribute targetLang { data.language }?,
    
    ## (documentation language) specifies which languages to
    ##       use when creating documentation if  the description for an element, attribute, class or macro
    ##       is available in more than one language, .
    attribute docLang {
      list { data.language, data.language* }
    }?,
    empty
  }
specGrp =
  
  ## (specification group) contains any convenient grouping of specifications for use within
  ##   the current module.
  element specGrp {
    (model.oddDecl | model.oddRef | model.divPart)*,
    att.global.attributes,
    empty
  }
specGrpRef =
  
  ## (reference to a specification group) indicates that the declarations contained by the specGrp referenced should be
  ##     inserted at this point.
  element specGrpRef {
    empty,
    att.global.attributes,
    
    ## points at the specification group which logically belongs here.
    attribute target { data.pointer },
    empty
  }
stringVal =
  
  ## contains the intended expansion for the entity documented by a macroSpec element,
  ##     enclosed by quotation marks.
  element stringVal { text, att.global.attributes, empty }
elementSpec =
  
  ## (element specification) documents the structure, content, and purpose of a single element type.
  element elementSpec {
    (model.glossLike*,
     classes?,
     content?,
     valList?,
     constraintSpec*,
     attList?,
     exemplum*,
     remarks*,
     listRef*),
    att.global.attributes,
    att.identified.attributes,
    
    ## (namespace) specifies the namespace to which this element belongs
    [ a:defaultValue = "http://www.tei-c.org/ns/1.0" ]
    attribute ns { data.namespace }?,
    
    ## specifies a default prefix which will be prepended to all patterns
    ##       relating to the element, unless otherwise stated. 
    ##       
    attribute prefix { "" | data.name }?,
    empty
  }
classSpec =
  
  ## (class specification) contains reference information for a TEI element class; 
  ## that is a group of 
  ##   elements which appear together in  content models, or 
  ##   which share some common attribute, or both.
  element classSpec {
    (model.glossLike*,
     classes?,
     constraintSpec*,
     attList?,
     exemplum*,
     remarks*,
     listRef*),
    att.global.attributes,
    att.identified.attributes,
    
    ## indicates whether this is a model class or an attribute class
    attribute type {
      
      ## (content model) members of this class appear in the same  content models
      "model"
      | 
        ## (attributes) members of this class share common attributes
        "atts"
    },
    
    ## indicates which alternation and sequence instantiations
    ##	of a model class may be referenced. By default, all variations
    ##	are permitted.
    attribute generate {
      list {
        (
         ## members of the class are alternatives
         "alternation"
         | 
           ## members of the class are to be provided in sequence
           "sequence"
         | 
           ## members of the class may be provided, in sequence,
           ##	    but are optional
           "sequenceOptional"
         | 
           ## members of the class may be provided one or more
           ##	    times, in sequence, but are optional. 
           "sequenceOptionalRepeatable"
         | 
           ## members of the class may be provided one or more times, in sequence
           "sequenceRepeatable"),
        (
         ## members of the class are alternatives
         "alternation"
         | 
           ## members of the class are to be provided in sequence
           "sequence"
         | 
           ## members of the class may be provided, in sequence,
           ##	    but are optional
           "sequenceOptional"
         | 
           ## members of the class may be provided one or more
           ##	    times, in sequence, but are optional. 
           "sequenceOptionalRepeatable"
         | 
           ## members of the class may be provided one or more times, in sequence
           "sequenceRepeatable")?,
        (
         ## members of the class are alternatives
         "alternation"
         | 
           ## members of the class are to be provided in sequence
           "sequence"
         | 
           ## members of the class may be provided, in sequence,
           ##	    but are optional
           "sequenceOptional"
         | 
           ## members of the class may be provided one or more
           ##	    times, in sequence, but are optional. 
           "sequenceOptionalRepeatable"
         | 
           ## members of the class may be provided one or more times, in sequence
           "sequenceRepeatable")?,
        (
         ## members of the class are alternatives
         "alternation"
         | 
           ## members of the class are to be provided in sequence
           "sequence"
         | 
           ## members of the class may be provided, in sequence,
           ##	    but are optional
           "sequenceOptional"
         | 
           ## members of the class may be provided one or more
           ##	    times, in sequence, but are optional. 
           "sequenceOptionalRepeatable"
         | 
           ## members of the class may be provided one or more times, in sequence
           "sequenceRepeatable")?,
        (
         ## members of the class are alternatives
         "alternation"
         | 
           ## members of the class are to be provided in sequence
           "sequence"
         | 
           ## members of the class may be provided, in sequence,
           ##	    but are optional
           "sequenceOptional"
         | 
           ## members of the class may be provided one or more
           ##	    times, in sequence, but are optional. 
           "sequenceOptionalRepeatable"
         | 
           ## members of the class may be provided one or more times, in sequence
           "sequenceRepeatable")?
      }
    }?,
    empty
  }
macroSpec =
  
  ## (macro specification) documents the function and implementation of a pattern. 
  element macroSpec {
    (model.glossLike*,
     (stringVal | content)*,
     constraintSpec*,
     exemplum*,
     remarks*,
     listRef*),
    att.global.attributes,
    att.identified.attributes,
    
    ## indicates which type of entity should be generated, when an ODD
    ##	processor is generating a module using XML DTD syntax.
    attribute type {
      
      ## (parameter entity) 
      "pe"
      | 
        ## (datatype entity) 
        "dt"
    }?,
    empty
  }
remarks =
  
  ## contains any commentary or discussion about the usage of an element, attribute, class, or
  ##     entity not otherwise documented within the containing element.
  element remarks {
    model.pLike+,
    att.global.attributes,
    att.translatable.attributes,
    empty
  }
listRef =
  
  ## (list of references) supplies a list of significant references to places where this element is discussed, in the
  ##     current document or elsewhere.
  element listRef { ptr+, att.global.attributes, empty }
exemplum =
  
  ## groups an example demonstrating the use of an element along with optional paragraphs of
  ##     commentary.
  element exemplum {
    (model.pLike*, (egXML | eg), model.pLike*),
    att.global.attributes,
    att.typed.attributes,
    att.translatable.attributes,
    empty
  }
classes =
  
  ## specifies all the classes of which the documented element or
  ## class is a member or subclass.
  element classes {
    memberOf*,
    att.global.attributes,
    
    ## specifies the effect of this declaration on its parent
    ##     module.
    [ a:defaultValue = "replace" ]
    attribute mode {
      
      ## this declaration changes the declaration of the same
      ##     name in the current definition
      "change"
      | 
        ## this declaration replaces the declaration of the same
        ##     name in the current definition
        "replace"
    }?,
    empty
  }
memberOf =
  
  ## specifies class membership of the parent element or class.
  element memberOf {
    macro.xtext,
    att.global.attributes,
    
    ## specifies the identifier for a class of which the documented element or class is a
    ##         member or subclass
    attribute key { data.name }?,
    
    ## specifies the effect of this declaration on its parent module.
    [ a:defaultValue = "add" ]
    attribute mode {
      
      ## this declaration is added to the current definitions
      "add"
      | 
        ## this declaration and all of its children are removed from the current setup
        "delete"
    }?,
    empty
  }
equiv =
  
  ## (equivalent) specifies a component which is considered equivalent to the parent element, either by
  ##     co-reference, or by external link.
  element equiv {
    empty,
    att.global.attributes,
    att.internetMedia.attributes,
    
    ## names the underlying concept of which the parent is a representation
    attribute name { data.name }?,
    
    ## (uniform resource identifier) references the underlying concept of which the parent is a representation by means of
    ##         some external identifier
    attribute uri { data.pointer }?,
    
    ## references an external script which contains a method to transform instances of this
    ##         element to canonical TEI 
    attribute filter { data.pointer }?,
    empty
  }
altIdent =
  
  ## (alternate identifier) supplies the recommended XML name for an element, class,
  ##   attribute, etc. in some language.
  element altIdent {
    text, att.global.attributes, att.typed.attributes, empty
  }
content =
  
  ## (content model) contains the text of a declaration for the schema
  ## documented.
  element content {
    macro.schemaPattern*,
    att.global.attributes,
    
    ## controls whether or not pattern names generated in the
    ## corresponding RELAXNG schema source are automatically prefixed to
    ## avoid potential nameclashes. 
    [ a:defaultValue = "true" ]
    attribute autoPrefix {
      
      ## Each name referenced in e.g. a rng:ref
      ##	  element within a content model is automatically prefixed by
      ##	  the value of the prefix attribute on the current
      ##	  schemaSpec
      ##                
      "true"
      | 
        ## No prefixes are added: 
        ##  any prefix required by the value of the prefix attribute on the current
        ##	  schemaSpec must therefore be supplied explicitly, as appropriate. 
        "false"
    }?,
    empty
  }
constraint =
  
  ##  (constraint rules) the formal rules of a constraint
  element constraint {
    (text | macro.anyXML), att.global.attributes, empty
  }
constraintSpec =
  
  ##  (constraint on schema) contains  a constraint, expressed in some formal syntax,
  ##   which cannot be expressed in the structural content model
  element constraintSpec {
    model.glossLike*,
    (constraint?)
    >> sch:ns [
         prefix = "s"
         uri = "http://www.ascc.net/xml/schematron"
       ]
    >> sch:pattern [
         id = "constraintSpec-constraint-sch"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "tei:constraintSpec"
           "\x{a}" ~
           "               "
           sch:report [
             test =
               "tei:constraint/s:* and    not(@scheme='schematron')"
             "\x{a}" ~
             "	Rules in the Schematron 1.* language must be inside\x{a}" ~
             "	a constraint with a value of 'schematron' on the scheme attribute\x{a}" ~
             "      "
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ]
    >> sch:ns [
         prefix = "sch"
         uri = "http://purl.oclc.org/dsdl/schematron"
       ]
    >> sch:pattern [
         id = "constraintSpec-constraint-isosch"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "tei:constraintSpec"
           "\x{a}" ~
           "               "
           sch:report [
             test =
               "tei:constraint/sch:* and    not(@scheme='isoschematron')"
             "\x{a}" ~
             "	Rules in the ISO Schematron language must be inside\x{a}" ~
             "	a constraint with a value of 'isoschematron' on the scheme attribute\x{a}" ~
             "      "
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    att.global.attributes,
    att.identified.attributes,
    att.typed.attributes,
    
    ## supplies the name of the language in which the constraints
    ##       are defined
    attribute scheme {
      
      ##  (Schematron) 
      "schematron"
      | 
        ##  (ISO Schematron) 
        "isoschematron"
      | 
        ##  (XSLT) 
        "xsl"
      | 
        ##  (private constraint language) 
        "private"
    },
    empty
  }
attList =
  
  ## contains documentation for all the attributes associated with this element, as a series of
  ##       attDef elements.
  element attList {
    (attRef | attDef | attList)+,
    att.global.attributes,
    
    ## (organization) specifies whether all the attributes in the list are available (org="group") or only one
    ##         of them (org="choice")
    [ a:defaultValue = "group" ]
    attribute org {
      
      ## grouped
      "group"
      | 
        ## alternated
        "choice"
    }?,
    empty
  }
attDef =
  
  ## (attribute definition) contains the definition of a single attribute.
  element attDef {
    (model.glossLike*,
     datatype?,
     constraintSpec*,
     defaultVal?,
     (valList | valDesc+)?,
     exemplum*,
     remarks*),
    att.global.attributes,
    att.identified.attributes,
    
    ## specifies the optionality of an attribute or element. 
    [ a:defaultValue = "opt" ]
    attribute usage {
      
      ## (required) 
      "req"
      | 
        ## (mandatory when applicable ) 
        "mwa"
      | 
        ## (recommended ) 
        "rec"
      | 
        ## (recommended when applicable ) 
        "rwa"
      | 
        ## (optional ) 
        "opt"
    }?,
    
    ## (namespace) specifies the namespace to which this attribute belongs
    [ a:defaultValue = "http://www.tei-c.org/ns/1.0" ]
    attribute ns { data.namespace }?,
    empty
  }
attRef =
  
  ## (attribute pointer) points to the definition of an attribute or group of attributes.
  element attRef {
    empty,
    att.global.attributes,
    
    ## the name of the pattern defining the attribute(s)
    attribute name { data.word },
    empty
  }
datatype =
  
  ## specifies the declared value for an attribute, by referring to
  ##   any datatype defined by the chosen schema language.
  element datatype {
    macro.schemaPattern*,
    att.global.attributes,
    
    ## (minimum number of occurences) indicates the minimum number of times this datatype may
    ##       occur in the specification of the attribute being defined
    [ a:defaultValue = "1" ] attribute minOccurs { data.count }?,
    
    ## (maximum number of occurences) indicates the maximum number of times this datatype may
    ##       occur in the specification of the attribute being defined
    [ a:defaultValue = "1" ]
    attribute maxOccurs { data.count | "unbounded" }?,
    empty
  }
defaultVal =
  
  ## (default value) specifies the default declared value for an attribute.
  element defaultVal { text, att.global.attributes, empty }
valDesc =
  
  ## (value description) specifies any semantic or syntactic constraint on the value that
  ## an attribute may take, additional to the information carried by the
  ## datatype element.
  element valDesc {
    macro.phraseSeq.limited,
    att.global.attributes,
    att.translatable.attributes,
    att.combinable.attributes,
    empty
  }
valItem =
  
  ## documents a single attribute-value within a list of possible
  ##   or mandatory items.
  element valItem {
    model.glossLike*,
    att.global.attributes,
    att.combinable.attributes,
    
    ## specifies the attribute value concerned.
    attribute ident { text },
    empty
  }
valList =
  
  ## (value list) contains one or more valItem elements defining possible values for an attribute.
  element valList {
    valItem*,
    att.global.attributes,
    att.combinable.attributes,
    
    ## specifies the extensibility of the list of attribute values specified. 
    [ a:defaultValue = "open" ]
    attribute type {
      
      ## only the values specified are permitted.
      "closed"
      | 
        ## (semi-open) all the values specified should be supported, but other values are legal and
        ##             software should have appropriate fallback processing for them. 
        "semi"
      | 
        ## the values specified are sample values only.
        "open"
    }?,
    empty
  }
att.combinable.attributes = att.combinable.attribute.mode
att.combinable.attribute.mode =
  
  ## specifies the effect of this declaration on its parent
  ##     object.
  [ a:defaultValue = "add" ]
  attribute mode {
    
    ## this declaration is added to the current definitions
    "add"
    | 
      ## if present already, the whole of the declaration 
      ##	  for this object is  removed from the current setup
      "delete"
    | 
      ## this declaration changes the declaration of the same
      ##     name in the current definition
      "change"
    | 
      ## this declaration replaces the declaration of the same
      ##     name in the current definition
      "replace"
  }?
att.identified.attributes =
  att.combinable.attributes,
  att.identified.attribute.ident,
  att.identified.attribute.predeclare,
  att.identified.attribute.module,
  att.identified.attribute.status
att.identified.attribute.ident =
  
  ## Supplies the identifier by which this element may be referenced.
  attribute ident { data.name }
att.identified.attribute.predeclare =
  
  ## Says whether this object should be predeclared in the
  ##       tei infrastructure module.
  [ a:defaultValue = "false" ] attribute predeclare { data.truthValue }?
att.identified.attribute.module =
  
  ## Supplies a name for the module in which this object is to
  ##       be declared.
  attribute module { xsd:NCName }?
att.identified.attribute.status =
  
  ## indicates the current status of the object identified with
  ## respect to the current version of the TEI Guidelines.
  [ a:defaultValue = "stable" ]
  attribute status {
    
    ## the item is not recommended for use,
    ## and may be withdrawn at a future release.
    "deprecated"
    | 
      ## the item is new and still under
      ## review.
      "unstable"
    | 
      ## the item has changed significantly since the
      ## preceding version.
      "changed"
    | 
      ## the item has not recently changed and is
      ## not expected to do so except for correction of any errors.
      "stable"
  }?
model.entryLike = superEntry | entry | entryFree
model.entryLike_alternation = superEntry | entry | entryFree
model.entryLike_sequence = superEntry, entry, entryFree
model.entryLike_sequenceOptional = superEntry?, entry?, entryFree?
model.entryLike_sequenceOptionalRepeatable =
  superEntry*, entry*, entryFree*
model.entryLike_sequenceRepeatable = superEntry+, entry+, entryFree+
att.entryLike.attributes =
  att.entryLike.attribute.type, att.entryLike.attribute.sortKey
att.entryLike.attribute.type =
  
  ## indicates type of entry, in dictionaries with multiple types.
  ## Suggested values include: 1] main; 2] hom(homograph) ; 3] xref(cross reference) ; 4] affix; 5] abbr(abbreviation) ; 6] supplemental; 7] foreign
  [ a:defaultValue = "main" ]
  attribute type {
    
    ## a main entry (default).
    "main"
    | 
      ## (homograph) groups information relating to one homograph within an entry.
      "hom"
    | 
      ## (cross reference) a reduced entry whose only function is to point to another main
      ##             entry (e.g. for forms of an irregular verb or for variant spellings:
      ##             was pointing to be, or
      ##             esthete to aesthete).
      "xref"
    | 
      ## an entry for a prefix, infix, or suffix.
      "affix"
    | 
      ## (abbreviation) an entry for an abbreviation.
      "abbr"
    | 
      ## a supplemental entry (for use in dictionaries which issue supplements to their main
      ##             work in which they include updated information about entries).
      "supplemental"
    | 
      ## an entry for a foreign word in a monolingual dictionary.
      "foreign"
    | xsd:Name
  }?
att.entryLike.attribute.sortKey =
  
  ## contains a (sortable) character sequence reflecting the entry's alphabetical position in
  ##         the printed dictionary.
  attribute sortKey { data.word }?
att.lexicographic.attributes =
  att.lexicographic.attribute.expand,
  att.lexicographic.attribute.norm,
  att.lexicographic.attribute.split,
  att.lexicographic.attribute.value,
  att.lexicographic.attribute.orig,
  att.lexicographic.attribute.location,
  att.lexicographic.attribute.mergedIn,
  att.lexicographic.attribute.opt
att.lexicographic.attribute.expand =
  
  ## gives an expanded form of information presented more concisely in the dictionary
  attribute expand { text }?
att.lexicographic.attribute.norm =
  
  ## (normalized) gives a normalized form of information given by the source text in a
  ##                 non-normalized form
  attribute norm { text }?
att.lexicographic.attribute.split =
  
  ## gives the list of split values for a merged form
  attribute split { text }?
att.lexicographic.attribute.value =
  
  ## gives a value which lacks any realization in the printed source text.
  attribute value { text }?
att.lexicographic.attribute.orig =
  
  ## (original) gives the original string or is the empty string when the element does not appear
  ##                 in the source text.
  attribute orig { text }?
att.lexicographic.attribute.location =
  
  ## provides a reference to an anchor element elsewhere in the document
  ##                 indicating the original location of this component.
  attribute location { data.pointer }?
att.lexicographic.attribute.mergedIn =
  
  ## gives a reference to another element, where the original appears as a merged form.
  attribute mergedIn { data.pointer }?
att.lexicographic.attribute.opt =
  
  ## (optional) indicates whether the element is optional or not
  [ a:defaultValue = "false" ] attribute opt { xsd:boolean }?
superEntry =
  
  ## groups successive entries for a set of homographs.
  element superEntry {
    ((form?, entry+) | dictScrap),
    att.global.attributes,
    att.entryLike.attributes,
    empty
  }
entry =
  
  ## contains a reasonably well-structured dictionary entry.
  element entry {
    (hom | sense | model.entryPart.top | model.global)+,
    att.global.attributes,
    att.entryLike.attributes,
    empty
  }
entryFree =
  
  ## (unstructured entry) contains a dictionary entry which does not necessarily conform to the constraints imposed
  ##         by the entry element.
  element entryFree {
    (text
     | model.gLike
     | model.entryPart
     | model.phrase
     | model.inter
     | model.global)*,
    att.global.attributes,
    att.entryLike.attributes,
    att.lexicographic.attributes,
    empty
  }
hom =
  
  ## (homograph) groups information relating to one homograph within an entry.
  element hom {
    (sense | model.entryPart.top | model.global)*,
    att.global.attributes,
    att.lexicographic.attributes,
    empty
  }
sense =
  
  ## groups together all information relating to one word sense in a dictionary entry, for
  ##     example definitions, examples, and translation equivalents.
  element sense {
    (text
     | model.gLike
     | sense
     | model.entryPart.top
     | model.phrase
     | model.global)*,
    att.global.attributes,
    att.lexicographic.attributes,
    
    ## gives the nesting depth of this sense.
    attribute level { data.numeric }?,
    empty
  }
dictScrap =
  
  ## (dictionary scrap) encloses a part of a dictionary entry in which other phrase-level dictionary elements are
  ##         freely combined.
  element dictScrap {
    (text
     | model.gLike
     | model.entryPart
     | model.phrase
     | model.inter
     | model.global)*,
    att.global.attributes,
    empty
  }
form =
  
  ## (form information group) groups all the information on the written and spoken forms of one headword.
  element form {
    (text
     | model.gLike
     | model.phrase
     | model.inter
     | model.formPart
     | model.global)*,
    att.global.attributes,
    att.lexicographic.attributes,
    
    ## classifies form as simple, compound, etc.
    ## Suggested values include: 1] simple; 2] lemma; 3] variant; 4] compound; 5] derivative; 6] inflected; 7] phrase
    attribute type {
      
      ## single free lexical item
      "simple"
      | 
        ## the headword itself
        "lemma"
      | 
        ## a variant form
        "variant"
      | 
        ## word formed from simple lexical items
        "compound"
      | 
        ## word derived from headword
        "derivative"
      | 
        ## word in other than usual dictionary form
        "inflected"
      | 
        ## multiple-word lexical item
        "phrase"
      | xsd:Name
    }?,
    empty
  }
orth =
  
  ## (orthographic form) gives the orthographic form of a dictionary headword.
  element orth {
    macro.paraContent,
    att.global.attributes,
    att.lexicographic.attributes,
    
    ## gives the type of spelling.
    attribute type { data.enumerated }?,
    
    ## gives the extent of the orthographic information provided.
    ## Sample values include: 1] full(full form) ; 2] pref(prefix) ; 3] suff(suffix) ; 4] part(partial) 
    [ a:defaultValue = "full" ] attribute extent { data.enumerated }?,
    empty
  }
pron =
  
  ## (pronunciation) contains the pronunciation(s) of the word.
  element pron {
    macro.paraContent,
    att.global.attributes,
    att.lexicographic.attributes,
    
    ## indicates whether the pronunciation is for whole word or part. 
    ## Sample values include: 1] full(full form) ; 2] pref(prefix) ; 3] suff(suffix) ; 4] part(partial) 
    [ a:defaultValue = "full" ] attribute extent { data.enumerated }?,
    
    ## indicates what notation is used for the pronunciation, if more than one occurs in
    ##                 the machine-readable dictionary. 
    attribute notation { data.enumerated }?,
    empty
  }
hyph =
  
  ## (hyphenation) contains a hyphenated form of a dictionary headword, or hyphenation information in some
  ##     other form.
  element hyph {
    macro.paraContent,
    att.global.attributes,
    att.lexicographic.attributes,
    empty
  }
syll =
  
  ## (syllabification) contains the syllabification of the headword.
  element syll {
    macro.paraContent,
    att.global.attributes,
    att.lexicographic.attributes,
    empty
  }
stress =
  
  ## contains the stress pattern for a dictionary headword, if given separately.
  element stress { macro.paraContent, att.global.attributes, empty }
gram =
  
  ## (grammatical information) within an entry in a dictionary or a terminological data file, contains grammatical
  ##     information relating to a term, word, or form.
  element gram {
    macro.paraContent,
    att.global.attributes,
    att.lexicographic.attributes,
    
    ## classifies the grammatical information given according to some convenient typology — in
    ##         the case of terminological information, preferably the dictionary of data element types
    ##         specified in ISO WD 12 620.
    ## Sample values include: 1] pos(part of speech) ; 2] gen(gender) ; 3] num(number) ; 4] animate; 5] proper
    attribute type { data.enumerated }?,
    empty
  }
gen =
  
  ## (gender) identifies the morphological gender of a lexical item, as given in the dictionary.
  element gen {
    macro.paraContent,
    att.global.attributes,
    att.lexicographic.attributes,
    empty
  }
number =
  
  ## indicates grammatical number associated with a form, as given in a dictionary.
  element number {
    macro.paraContent,
    att.global.attributes,
    att.lexicographic.attributes,
    empty
  }
case =
  
  ## contains grammatical case information given by a dictionary for a given form.
  element case {
    macro.paraContent,
    att.global.attributes,
    att.lexicographic.attributes,
    empty
  }
per =
  
  ## (person) contains an indication of the grammatical person (1st, 2nd, 3rd, etc.) associated with a
  ##     given inflected form in a dictionary.
  element per {
    macro.paraContent,
    att.global.attributes,
    att.lexicographic.attributes,
    empty
  }
tns =
  
  ## (tense) indicates the grammatical tense associated with a given inflected form in a dictionary.
  element tns {
    macro.paraContent,
    att.global.attributes,
    att.lexicographic.attributes,
    empty
  }
mood =
  
  ## contains information about the grammatical mood of verbs (e.g. indicative, subjunctive,
  ##     imperative).
  element mood {
    macro.paraContent,
    att.global.attributes,
    att.lexicographic.attributes,
    empty
  }
iType =
  
  ## (inflectional class) indicates the inflectional class associated with a lexical item.
  element iType {
    macro.paraContent,
    att.global.attributes,
    att.lexicographic.attributes,
    
    ## indicates the type of indicator used to specify the inflection class, when it is
    ##         necessary to distinguish between the usual abbreviated indications (e.g.
    ##         inv) and other kinds of indicators, such as special codes referring
    ##         to conjugation patterns, etc.
    ## Sample values include: 1] abbrev; 2] verbTable
    attribute type { data.enumerated }?,
    empty
  }
model.morphLike = gram | gen | number | case | per | tns | mood | iType
model.morphLike_alternation =
  gram | gen | number | case | per | tns | mood | iType
model.morphLike_sequence =
  gram, gen, number, case, per, tns, mood, iType
model.morphLike_sequenceOptional =
  gram?, gen?, number?, case?, per?, tns?, mood?, iType?
model.morphLike_sequenceOptionalRepeatable =
  gram*, gen*, number*, case*, per*, tns*, mood*, iType*
model.morphLike_sequenceRepeatable =
  gram+, gen+, number+, case+, per+, tns+, mood+, iType+
model.gramPart =
  model.morphLike | gramGrp | pos | subc | colloc | usg | lbl
model.gramPart_alternation =
  model.morphLike_alternation
  | gramGrp
  | pos
  | subc
  | colloc
  | usg
  | lbl
model.gramPart_sequence =
  model.morphLike_sequence, gramGrp, pos, subc, colloc, usg, lbl
model.gramPart_sequenceOptional =
  model.morphLike_sequenceOptional?,
  gramGrp?,
  pos?,
  subc?,
  colloc?,
  usg?,
  lbl?
model.gramPart_sequenceOptionalRepeatable =
  model.morphLike_sequenceOptionalRepeatable*,
  gramGrp*,
  pos*,
  subc*,
  colloc*,
  usg*,
  lbl*
model.gramPart_sequenceRepeatable =
  model.morphLike_sequenceRepeatable+,
  gramGrp+,
  pos+,
  subc+,
  colloc+,
  usg+,
  lbl+
model.formPart =
  form | orth | pron | hyph | syll | stress | model.gramPart
gramGrp =
  
  ## (grammatical information group) groups morpho-syntactic information about a lexical item, e.g. pos, gen, number, case, or
  ##         iType (inflectional class).
  element gramGrp {
    (text
     | model.gLike
     | model.phrase
     | model.inter
     | model.gramPart
     | model.global)*,
    att.global.attributes,
    att.lexicographic.attributes,
    empty
  }
pos =
  
  ## (part of speech) indicates the part of speech assigned to a dictionary 
  ## headword  such as noun, verb, or adjective.
  ##     
  element pos {
    macro.paraContent,
    att.global.attributes,
    att.lexicographic.attributes,
    empty
  }
subc =
  
  ## (subcategorization) contains subcategorization information (transitive/intransitive, countable/non-countable,
  ##         etc.)
  element subc {
    macro.paraContent,
    att.global.attributes,
    att.lexicographic.attributes,
    empty
  }
colloc =
  
  ## (collocate) contains a collocate of the headword.
  element colloc {
    macro.paraContent,
    att.global.attributes,
    att.lexicographic.attributes,
    att.typed.attributes,
    empty
  }
def =
  
  ## (definition) contains definition text in a dictionary entry.
  element def {
    macro.paraContent,
    att.global.attributes,
    att.lexicographic.attributes,
    empty
  }
etym =
  
  ## (etymology) encloses the etymological information in a dictionary entry.
  element etym {
    (text
     | model.gLike
     | model.phrase
     | model.inter
     | usg
     | lbl
     | def
     | model.morphLike
     | xr
     | model.global)*,
    att.global.attributes,
    att.lexicographic.attributes,
    empty
  }
lang =
  
  ## (language name) name of a language mentioned in etymological or other linguistic discussion.
  element lang {
    macro.paraContent,
    att.global.attributes,
    att.lexicographic.attributes,
    empty
  }
usg =
  
  ## (usage) contains usage information in a dictionary entry.
  element usg {
    macro.paraContent,
    att.global.attributes,
    att.lexicographic.attributes,
    
    ## classifies the usage information using any convenient typology.
    ## Sample values include: 1] geo(geographic) ; 2] time; 3] dom(domain) ; 4] reg(register) ; 5] style; 6] plev(preference level) ; 7] lang(language) ; 8] gram(grammatical) ; 9] syn(synonym) ; 10] hyper(hypernym) ; 11] colloc(collocation) ; 12] comp(complement) ; 13] obj(object) ; 14] subj(subject) ; 15] verb; 16] hint
    attribute type { data.enumerated }?,
    empty
  }
lbl =
  
  ## (label) contains a label for a form, example, translation, or other piece of information, e.g.
  ##     abbreviation for, contraction of, literally, approximately, synonyms:, etc.
  element lbl {
    macro.paraContent,
    att.global.attributes,
    att.lexicographic.attributes,
    
    ## classifies the label using any convenient typology.
    attribute type { data.enumerated }?,
    empty
  }
xr =
  
  ## (cross-reference phrase) contains a phrase, sentence, or icon referring the reader to some other location in this or
  ##     another text.
  element xr {
    (text
     | model.gLike
     | model.phrase
     | model.inter
     | usg
     | lbl
     | model.global)*,
    att.global.attributes,
    att.lexicographic.attributes,
    
    ## indicates the type of cross reference, using any convenient typology.
    ## Sample values include: 1] syn(synonym) ; 2] etym(etymological) ; 3] cf(compare or consult) ; 4] illus(illustration) 
    attribute type { data.enumerated }?,
    empty
  }
re =
  
  ## (related entry) contains a dictionary entry for a lexical item related to the headword, such as a compound
  ##     phrase or derived form, embedded inside a larger entry.
  element re {
    (text
     | model.gLike
     | sense
     | model.entryPart.top
     | model.phrase
     | model.global)*,
    att.global.attributes,
    att.lexicographic.attributes,
    att.typed.attributes,
    empty
  }
model.ptrLike.form = oRef | oVar | pRef | pVar
model.ptrLike.form_alternation = oRef | oVar | pRef | pVar
model.ptrLike.form_sequence = oRef, oVar, pRef, pVar
model.ptrLike.form_sequenceOptional = oRef?, oVar?, pRef?, pVar?
model.ptrLike.form_sequenceOptionalRepeatable =
  oRef*, oVar*, pRef*, pVar*
model.ptrLike.form_sequenceRepeatable = oRef+, oVar+, pRef+, pVar+
oRef =
  
  ## (orthographic-form reference) in a dictionary example, indicates a reference to the orthographic form(s) of the headword.
  element oRef {
    empty,
    att.global.attributes,
    att.lexicographic.attributes,
    att.pointing.attributes,
    
    ## indicates the kind of typographic modification made to the headword in the reference.
    ## Sample values include: 1] cap(capital) ; 2] noHyph(no hyphen) 
    attribute type { data.enumerated }?,
    empty
  }
oVar =
  
  ## (orthographic-variant reference) in a dictionary example, indicates a reference to variant orthographic form(s) of the
  ##     headword.
  element oVar {
    (text | model.gLike | oRef)*,
    att.global.attributes,
    att.lexicographic.attributes,
    att.pointing.attributes,
    
    ## indicates the kind of variant involved.
    ## Sample values include: 1] pt(past tense) ; 2] pp(past participle) ; 3] prp(present participle) ; 4] f(feminine) ; 5] pl(plural) 
    attribute type { data.enumerated }?,
    empty
  }
pRef =
  
  ## (pronunciation reference) in a dictionary example, indicates a reference to the pronunciation(s) of the headword.
  element pRef {
    empty,
    att.global.attributes,
    att.pointing.attributes,
    att.lexicographic.attributes,
    empty
  }
pVar =
  
  ## (pronunciation-variant reference) in a dictionary example, indicates a reference to variant pronunciation(s) of the headword.
  element pVar {
    (text | model.gLike | pRef)*,
    att.global.attributes,
    att.pointing.attributes,
    att.lexicographic.attributes,
    empty
  }
link =
  
  ## defines an association or hypertextual link among elements or passages, of some type not more precisely specifiable by other elements.
  element link {
    empty
    >> sch:pattern [
         id = "link-constraint-linkTargets1"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "tei:link"
           "\x{a}" ~
           "               "
           sch:report [
             test = "@target and @targets"
             "You may not supply both \x{a}" ~
             "	@target and @targets"
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ]
    >> sch:pattern [
         id = "link-constraint-linkTargets2"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "tei:link"
           "\x{a}" ~
           "               "
           sch:report [
             test = "not(@target) and not(@targets)"
             "You must\x{a}" ~
             "	supply either @target or @targets"
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ]
    >> sch:pattern [
         id = "link-constraint-linkTargets3"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "tei:link"
           "\x{a}" ~
           "               "
           sch:assert [
             test = "contains(@target,' ')"
             "You must supply at least two\x{a}" ~
             "values for @target"
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    att.global.attributes,
    att.pointing.attributes,
    att.typed.attributes,
    
    ## specifies the identifiers of the elements or passages to be linked or associated. 
    attribute targets {
      list { data.pointer, data.pointer, data.pointer* }
    }?,
    empty
  }
linkGrp =
  
  ## (link group) defines a collection of associations or hypertextual links.
  element linkGrp {
    (link | ptr)+,
    att.global.attributes,
    att.pointing.group.attributes,
    empty
  }
ab =
  
  ## (anonymous block) contains any arbitrary component-level unit of text, acting as an anonymous container for phrase or inter level elements analogous to, but without the semantic baggage of, a paragraph.
  element ab {
    macro.paraContent,
    att.global.attributes,
    att.typed.attributes,
    att.declaring.attributes,
    
    ## specifies whether or not the block is complete. 
    [ a:defaultValue = "N" ]
    attribute part {
      
      ## (yes) the block is incomplete
      "Y"
      | 
        ## (no) either the block is complete, or no claim is made as to its completeness
        "N"
      | 
        ## (initial) the initial part of an incomplete block
        "I"
      | 
        ## (medial) a medial part of an incomplete block
        "M"
      | 
        ## (final) the final part of an incomplete block
        "F"
    }?,
    empty
  }
anchor =
  
  ## (anchor point) attaches an identifier to a point within a text, whether or not it corresponds with a textual element.
  element anchor {
    empty, att.global.attributes, att.typed.attributes, empty
  }
seg =
  
  ## (arbitrary segment) represents any segmentation of text below the chunk level.
  element seg {
    macro.paraContent,
    att.global.attributes,
    att.segLike.attributes,
    att.typed.attributes,
    att.responsibility.attributes,
    empty
  }
when =
  
  ## indicates a point in time either relative to other elements in the same timeline tag, or absolutely.
  element when {
    empty,
    att.global.attributes,
    
    ## supplies an absolute value for the time.
    attribute absolute { data.temporal.w3c }?,
    
    ## specifies the unit of time in which the interval value is expressed, if this is not inherited from the parent timeline.
    ## Suggested values include: 1] d(days) ; 2] h(hours) ; 3] min(minutes) ; 4] s(seconds) ; 5] ms(milliseconds) 
    attribute unit {
      
      ## (days) 
      "d"
      | 
        ## (hours) 
        "h"
      | 
        ## (minutes) 
        "min"
      | 
        ## (seconds) 
        "s"
      | 
        ## (milliseconds) 
        "ms"
      | xsd:Name
    }?,
    
    ## specifies the numeric portion of a time interval
    attribute interval {
      xsd:float { minExclusive = "0" }
      | "unknown"
    }?,
    
    ## identifies the reference point for determining the time of the current when element, which is obtained by adding the interval to the time of the reference point.
    attribute since { data.pointer }?,
    empty
  }
timeline =
  
  ## (timeline) provides a set of ordered points in time which can be linked to elements of a spoken text to create a temporal alignment of that text.
  element timeline {
    when+,
    att.global.attributes,
    
    ## designates the origin of the timeline, i.e. the time at which it begins.
    attribute origin { data.pointer }?,
    
    ## specifies the unit of time corresponding to the interval value of the timeline or of its constituent points in time.
    ## Suggested values include: 1] d(days) ; 2] h(hours) ; 3] min(minutes) ; 4] s(seconds) ; 5] ms(milliseconds) 
    attribute unit {
      
      ## (days) 
      "d"
      | 
        ## (hours) 
        "h"
      | 
        ## (minutes) 
        "min"
      | 
        ## (seconds) 
        "s"
      | 
        ## (milliseconds) 
        "ms"
      | xsd:Name
    }?,
    
    ## specifies the numeric portion of a time interval
    attribute interval {
      xsd:float { minExclusive = "0" }
      | "regular"
      | "irregular"
    }?,
    empty
  }
join =
  
  ## identifies a possibly fragmented segment of text, by pointing at the possibly discontiguous elements which compose it.
  element join {
    (model.glossLike*)
    >> sch:pattern [
         id = "join-constraint-joinTargets1"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "tei:join"
           "\x{a}" ~
           "               "
           sch:report [
             test = "@target and @targets"
             "You may not supply both \x{a}" ~
             "	@target and @targets"
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ]
    >> sch:pattern [
         id = "join-constraint-joinTargets2"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "tei:join"
           "\x{a}" ~
           "               "
           sch:report [
             test = "not(@target) and not(@targets)"
             "You must\x{a}" ~
             "	supply either @target or @targets"
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ]
    >> sch:pattern [
         id = "join-constraint-joinTargets3"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "tei:join"
           "\x{a}" ~
           "               "
           sch:assert [
             test = "contains(@target,' ')"
             "You must supply at least two\x{a}" ~
             "values for @target"
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    att.global.attributes,
    att.pointing.attributes,
    att.typed.attributes,
    
    ## specifies the identifiers of the elements or passages to be joined into a virtual element.
    attribute targets {
      list { data.pointer, data.pointer, data.pointer* }
    }?,
    
    ## specifies the name of an element which this aggregation may be understood to represent.
    attribute result { data.name }?,
    
    ## indicates whether the targets to be joined include the entire element indicated (the entire subtree including its root), or just the children of the target (the branches of the subtree).
    [ a:defaultValue = "root" ]
    attribute scope {
      
      ## the rooted subtrees indicated by the targets attribute are joined, each subtree become a child of the virtual element created by the join
      "root"
      | 
        ## the children of the subtrees indicated by the targets attribute become the children of the virtual element (i.e. the roots of the subtrees are discarded)
        "branches"
    }?,
    empty
  }
joinGrp =
  
  ## (join group) groups a collection of join elements and possibly pointers.
  element joinGrp {
    (model.glossLike*, (join | ptr)+),
    att.global.attributes,
    att.pointing.group.attributes,
    
    ## describes the result of the joins gathered in this collection.
    attribute result { data.name }?,
    empty
  }
alt =
  
  ## (alternation) identifies an alternation or a set of choices among elements or passages.
  element alt {
    empty
    >> sch:pattern [
         id = "alt-constraint-altTargets1"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "tei:alt"
           "\x{a}" ~
           "               "
           sch:report [
             test = "@target and @targets"
             "You may not supply both \x{a}" ~
             "	@target and @targets"
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ]
    >> sch:pattern [
         id = "alt-constraint-altTargets2"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "tei:alt"
           "\x{a}" ~
           "               "
           sch:report [
             test = "not(@target) and not(@targets)"
             "You must\x{a}" ~
             "	supply either @target or @targets"
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ]
    >> sch:pattern [
         id = "alt-constraint-altTargets3"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "tei:alt"
           "\x{a}" ~
           "               "
           sch:assert [
             test = "contains(@target,' ')"
             "You must supply at least two\x{a}" ~
             "values for @target"
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    att.global.attributes,
    att.pointing.attributes,
    att.typed.attributes,
    
    ## specifies the identifiers of the alternative elements or passages.
    attribute targets {
      list { data.pointer, data.pointer, data.pointer* }
    }?,
    
    ## states whether the alternations gathered in this collection are exclusive or
    ##                 inclusive.
    attribute mode {
      
      ## (exclusive) indicates that the alternation is exclusive, i.e. that at most one of the
      ##                         alternatives occurs.
      "excl"
      | 
        ## (inclusive) indicates that the alternation is not exclusive, i.e. that one or more of
        ##                         the alternatives occur.
        "incl"
    }?,
    
    ## If mode is , each weight states the probability that
    ##                 the corresponding alternative occurs. If mode is incl each
    ##                 weight states the probability that the corresponding alternative occurs given that
    ##                 at least one of the other alternatives occurs.
    attribute weights {
      list { data.probability, data.probability, data.probability* }
    }?,
    empty
  }
altGrp =
  
  ## (alternation group) groups a collection of alt elements and possibly pointers.
  element altGrp {
    (alt | ptr)*,
    att.global.attributes,
    att.pointing.group.attributes,
    
    ## states whether the alternations gathered in this collection are exclusive or
    ##                 inclusive.
    [ a:defaultValue = "excl" ]
    attribute mode {
      
      ## (exclusive) indicates that the alternation is exclusive, i.e. that at most one of the
      ##                         alternatives occurs.
      "excl"
      | 
        ## (inclusive) indicates that the alternation is not exclusive, i.e. that one or more of
        ##                         the alternatives occur.
        "incl"
    }?,
    empty
  }
att.global.linking.attributes =
  att.global.linking.attribute.corresp,
  att.global.linking.attribute.synch,
  att.global.linking.attribute.sameAs,
  att.global.linking.attribute.copyOf,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  att.global.linking.attribute.exclude,
  att.global.linking.attribute.select
att.global.linking.attribute.corresp =
  
  ## (corresponds) points to elements that correspond to the current
  ##       element in some way.
  attribute corresp {
    list { data.pointer, data.pointer* }
  }?
att.global.linking.attribute.synch =
  
  ## (synchronous) points to elements that are synchronous with the current
  ##       element.
  attribute synch {
    list { data.pointer, data.pointer* }
  }?
att.global.linking.attribute.sameAs =
  
  ## points to an element that is the same as the current
  ##       element.
  attribute sameAs { data.pointer }?
att.global.linking.attribute.copyOf =
  
  ## points to an element of which the current element is a
  ##	copy.
  attribute copyOf { data.pointer }?
att.global.linking.attribute.next =
  
  ## points to the next element of a virtual aggregate of which
  ##       the current element is part.
  attribute next { data.pointer }?
att.global.linking.attribute.prev =
  
  ## (previous) points to the previous element of a virtual aggregate of
  ##       which the current element is part.
  attribute prev { data.pointer }?
att.global.linking.attribute.exclude =
  
  ## points to elements that are in exclusive alternation
  ##       with the current element.
  attribute exclude {
    list { data.pointer, data.pointer* }
  }?
att.global.linking.attribute.select =
  
  ## selects one or more alternants; if one alternant is
  ##       selected, the ambiguity or uncertainty is marked as resolved. If
  ##       more than one alternant is selected, the degree of ambiguity or
  ##       uncertainty is marked as reduced by the number of alternants not
  ##       selected.
  attribute select {
    list { data.pointer, data.pointer* }
  }?
table =
  
  ## contains text displayed in tabular form, in rows and columns.
  element table {
    ((model.headLike | model.global)*, (row, model.global*)+),
    att.global.attributes,
    
    ## indicates the number of rows in the table.
    attribute rows { data.count }?,
    
    ## (columns) indicates the number of columns in each row of the table.
    attribute cols { data.count }?,
    empty
  }
row =
  
  ## contains one row of a table. 
  element row {
    cell+, att.global.attributes, att.tableDecoration.attributes, empty
  }
cell =
  
  ## contains one cell of a table. 
  element cell {
    macro.paraContent,
    att.global.attributes,
    att.tableDecoration.attributes,
    empty
  }
formula =
  
  ## contains a mathematical or other formula.
  element formula {
    (text | model.graphicLike)*,
    att.global.attributes,
    
    ## supplies the name of a previously defined notation used for the content of the element.
    attribute notation { data.code }?,
    empty
  }
figure =
  
  ## groups elements representing or containing graphic information such as an illustration or
  ##     figure.
  element figure {
    (model.headLike
     | model.pLike
     | figDesc
     | model.graphicLike
     | model.egLike
     | floatingText
     | model.global)*,
    att.global.attributes,
    att.placement.attributes,
    att.typed.attributes,
    empty
  }
figDesc =
  
  ## (description of figure) contains a brief prose description of the appearance or content
  ## of a graphic figure, for use when documenting an image without
  ## displaying it.
  element figDesc { macro.limitedContent, att.global.attributes, empty }
start = TEI | schemaSpec | elementSpec | classSpec | macroSpec | \div
