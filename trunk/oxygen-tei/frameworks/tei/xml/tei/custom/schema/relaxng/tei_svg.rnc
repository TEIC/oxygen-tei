default namespace = "http://www.w3.org/2000/svg"
namespace a = "http://relaxng.org/ns/compatibility/annotations/1.0"
namespace ns1 = "http://www.tei-c.org/ns/1.0"
namespace ns2 = "http://www.tei-c.org/ns/Examples"
namespace rng = "http://relaxng.org/ns/structure/1.0"
namespace sch = "http://purl.oclc.org/dsdl/schematron"
namespace xlink = "http://www.w3.org/1999/xlink"

# Schema generated from ODD source 2011-03-05T12:31:01Z. 
# Edition: 1.9.1. Last updated on March 5th 2011.
# Edition Location: http://www.tei-c.org/Vault/P5/1.9.1/
#

# 
# This template file is freely available and you are hereby
#             authorised to copy, modify, and redistribute it in any way without
#             further reference or permissions.
# 
# When making such modifications, you are strongly recommended to
#             change the present text to include an accurate statement of the
#             licencing conditions applicable to your modified text.
div {
  Boolean.datatype = "false" | "true"
  ClipFillRule.datatype = "nonzero" | "evenodd" | "inherit"
  ContentType.datatype = string
  Coordinate.datatype = string
  Coordinates.datatype = string
  Color.datatype = string
  Integer.datatype = string
  LanguageCode.datatype = xsd:NMTOKEN
  LanguageCodes.datatype = string
  Length.datatype = string
  Lengths.datatype = string
  Number.datatype = string
  Numbers.datatype = string
  OpacityValue.datatype = string
  PathData.datatype = string
  PreserveAspectRatioSpec.datatype = string
  Script.datatype = string
  SVGColor.datatype = string
  Text.datatype = string
  TransformList.datatype = string
  URI.datatype = string
  ViewBoxSpec.datatype = string
  XLINK.xmlns.attrib = empty
  SVG.xmlns.attrib = XLINK.xmlns.attrib
  SVG.Description.extra.class = notAllowed
  SVG.Description.class =
    desc | title | metadata | SVG.Description.extra.class
  SVG.Use.extra.class = notAllowed
  SVG.Use.class = use | SVG.Use.extra.class
  SVG.Structure.extra.class = notAllowed
  SVG.Structure.class =
    svg | g | defs | symbol | SVG.Use.class | SVG.Structure.extra.class
  SVG.Conditional.extra.class = notAllowed
  SVG.Conditional.class = switch | SVG.Conditional.extra.class
  SVG.Image.extra.class = notAllowed
  SVG.Image.class = image | SVG.Image.extra.class
  SVG.Style.extra.class = notAllowed
  SVG.Style.class = style | SVG.Style.extra.class
  SVG.Shape.extra.class = notAllowed
  SVG.Shape.class =
    path
    | rect
    | circle
    | line
    | ellipse
    | polyline
    | polygon
    | SVG.Shape.extra.class
  SVG.Text.extra.class = notAllowed
  SVG.Text.class = \text | altGlyphDef | SVG.Text.extra.class
  SVG.TextContent.extra.class = notAllowed
  SVG.TextContent.class =
    tspan | tref | textPath | altGlyph | SVG.TextContent.extra.class
  SVG.Marker.extra.class = notAllowed
  SVG.Marker.class = marker | SVG.Marker.extra.class
  SVG.ColorProfile.extra.class = notAllowed
  SVG.ColorProfile.class = color-profile | SVG.ColorProfile.extra.class
  SVG.Gradient.extra.class = notAllowed
  SVG.Gradient.class =
    linearGradient | radialGradient | SVG.Gradient.extra.class
  SVG.Pattern.extra.class = notAllowed
  SVG.Pattern.class = svgpattern | SVG.Pattern.extra.class
  SVG.Clip.extra.class = notAllowed
  SVG.Clip.class = clipPath | SVG.Clip.extra.class
  SVG.Mask.extra.class = notAllowed
  SVG.Mask.class = mask | SVG.Mask.extra.class
  SVG.Filter.extra.class = notAllowed
  SVG.Filter.class = filter | SVG.Filter.extra.class
  SVG.FilterPrimitive.extra.class = notAllowed
  SVG.FilterPrimitive.class =
    feBlend
    | feColorMatrix
    | feComponentTransfer
    | feComposite
    | feConvolveMatrix
    | feDiffuseLighting
    | feDisplacementMap
    | feFlood
    | feGaussianBlur
    | feImage
    | feMerge
    | feMorphology
    | feOffset
    | feSpecularLighting
    | feTile
    | feTurbulence
    | SVG.FilterPrimitive.extra.class
  SVG.Cursor.extra.class = notAllowed
  SVG.Cursor.class = cursor | SVG.Cursor.extra.class
  SVG.Hyperlink.extra.class = notAllowed
  SVG.Hyperlink.class = a | SVG.Hyperlink.extra.class
  SVG.View.extra.class = notAllowed
  SVG.View.class = view | SVG.View.extra.class
  SVG.Script.extra.class = notAllowed
  SVG.Script.class = script | SVG.Script.extra.class
  SVG.Animation.extra.class = notAllowed
  SVG.Animation.class =
    animate
    | set
    | animateMotion
    | animateColor
    | animateTransform
    | SVG.Animation.extra.class
  SVG.Font.extra.class = notAllowed
  SVG.Font.class = font | font-face | SVG.Font.extra.class
  SVG.Extensibility.extra.class = notAllowed
  SVG.Extensibility.class =
    foreignObject | SVG.Extensibility.extra.class
  ExtensionList.datatype = string
  FeatureList.datatype = string
  SVG.Conditional.extra.attrib = empty
  SVG.Conditional.attrib =
    attribute requiredFeatures { FeatureList.datatype }?,
    attribute requiredExtensions { ExtensionList.datatype }?,
    attribute systemLanguage { LanguageCodes.datatype }?,
    SVG.Conditional.extra.attrib
  ClassList.datatype = string
  StyleSheet.datatype = string
  SVG.Style.extra.attrib = empty
  SVG.Style.attrib =
    attribute style { StyleSheet.datatype }?,
    attribute class { ClassList.datatype }?,
    SVG.Style.extra.attrib
  BaselineShiftValue.datatype = string
  FontFamilyValue.datatype = string
  FontSizeValue.datatype = string
  FontSizeAdjustValue.datatype = string
  GlyphOrientationHorizontalValue.datatype = string
  GlyphOrientationVerticalValue.datatype = string
  KerningValue.datatype = string
  SpacingValue.datatype = string
  TextDecorationValue.datatype = string
  SVG.Text.extra.attrib = empty
  SVG.Text.attrib =
    attribute writing-mode {
      "lr-tb" | "rl-tb" | "tb-rl" | "lr" | "rl" | "tb" | "inherit"
    }?,
    SVG.Text.extra.attrib
  SVG.TextContent.extra.attrib = empty
  SVG.TextContent.attrib =
    attribute alignment-baseline {
      "auto"
      | "baseline"
      | "before-edge"
      | "text-before-edge"
      | "middle"
      | "central"
      | "after-edge"
      | "text-after-edge"
      | "ideographic"
      | "alphabetic"
      | "hanging"
      | "mathematical"
      | "inherit"
    }?,
    attribute baseline-shift { BaselineShiftValue.datatype }?,
    attribute direction { "ltr" | "rtl" | "inherit" }?,
    attribute dominant-baseline {
      "auto"
      | "use-script"
      | "no-change"
      | "reset-size"
      | "ideographic"
      | "alphabetic"
      | "hanging"
      | "mathematical"
      | "central"
      | "middle"
      | "text-after-edge"
      | "text-before-edge"
      | "inherit"
    }?,
    attribute glyph-orientation-horizontal {
      GlyphOrientationHorizontalValue.datatype
    }?,
    attribute glyph-orientation-vertical {
      GlyphOrientationVerticalValue.datatype
    }?,
    attribute kerning { KerningValue.datatype }?,
    attribute letter-spacing { SpacingValue.datatype }?,
    attribute text-anchor { "start" | "middle" | "end" | "inherit" }?,
    attribute text-decoration { TextDecorationValue.datatype }?,
    attribute unicode-bidi {
      "normal" | "embed" | "bidi-override" | "inherit"
    }?,
    attribute word-spacing { SpacingValue.datatype }?,
    SVG.TextContent.extra.attrib
  SVG.Font.extra.attrib = empty
  SVG.Font.attrib =
    attribute font-family { FontFamilyValue.datatype }?,
    attribute font-size { FontSizeValue.datatype }?,
    attribute font-size-adjust { FontSizeAdjustValue.datatype }?,
    attribute font-stretch {
      "normal"
      | "wider"
      | "narrower"
      | "ultra-condensed"
      | "extra-condensed"
      | "condensed"
      | "semi-condensed"
      | "semi-expanded"
      | "expanded"
      | "extra-expanded"
      | "ultra-expanded"
      | "inherit"
    }?,
    attribute font-style {
      "normal" | "italic" | "oblique" | "inherit"
    }?,
    attribute font-variant { "normal" | "small-caps" | "inherit" }?,
    attribute font-weight {
      "normal"
      | "bold"
      | "bolder"
      | "lighter"
      | "100"
      | "200"
      | "300"
      | "400"
      | "500"
      | "600"
      | "700"
      | "800"
      | "900"
      | "inherit"
    }?,
    SVG.Font.extra.attrib
  MarkerValue.datatype = string
  SVG.Marker.extra.attrib = empty
  SVG.Marker.attrib =
    attribute marker-start { MarkerValue.datatype }?,
    attribute marker-mid { MarkerValue.datatype }?,
    attribute marker-end { MarkerValue.datatype }?,
    SVG.Marker.extra.attrib
  SVG.ColorProfile.extra.attrib = empty
  SVG.ColorProfile.attrib =
    attribute color-profile { text }?,
    SVG.ColorProfile.extra.attrib
  NumberOrPercentage.datatype = string
  SVG.Gradient.extra.attrib = empty
  SVG.Gradient.attrib =
    attribute stop-color { SVGColor.datatype }?,
    attribute stop-opacity { OpacityValue.datatype }?,
    SVG.Gradient.extra.attrib
  ClipPathValue.datatype = string
  SVG.Clip.extra.attrib = empty
  SVG.Clip.attrib =
    attribute clip-path { ClipPathValue.datatype }?,
    attribute clip-rule { ClipFillRule.datatype }?,
    SVG.Clip.extra.attrib
  MaskValue.datatype = string
  SVG.Mask.extra.attrib = empty
  SVG.Mask.attrib =
    attribute mask { MaskValue.datatype }?,
    SVG.Mask.extra.attrib
  FilterValue.datatype = string
  NumberOptionalNumber.datatype = string
  SVG.Filter.extra.attrib = empty
  SVG.Filter.attrib =
    attribute filter { FilterValue.datatype }?,
    SVG.Filter.extra.attrib
  SVG.FilterColor.extra.attrib = empty
  SVG.FilterColor.attrib =
    attribute color-interpolation-filters {
      "auto" | "sRGB" | "linearRGB" | "inherit"
    }?,
    SVG.FilterColor.extra.attrib
  CursorValue.datatype = string
  SVG.Cursor.extra.attrib = empty
  SVG.Cursor.attrib =
    attribute cursor { CursorValue.datatype }?,
    SVG.Cursor.extra.attrib
  SVG.id.attrib = attribute id { xsd:ID }?
  SVG.base.attrib = attribute xml:base { URI.datatype }?
  SVG.lang.attrib = attribute xml:lang { LanguageCode.datatype }?
  SVG.space.attrib = attribute xml:space { "default" | "preserve" }?
  SVG.Core.extra.attrib = empty
  SVG.Core.attrib =
    SVG.id.attrib,
    SVG.base.attrib,
    SVG.lang.attrib,
    SVG.space.attrib,
    SVG.Core.extra.attrib
  EnableBackgroundValue.datatype = string
  SVG.enable-background.attrib =
    attribute enable-background { EnableBackgroundValue.datatype }?
  SVG.Container.extra.attrib = empty
  SVG.Container.attrib =
    SVG.enable-background.attrib, SVG.Container.extra.attrib
  ClipValue.datatype = string
  SVG.clip.attrib = attribute clip { ClipValue.datatype }?
  SVG.overflow.attrib =
    attribute overflow {
      "visible" | "hidden" | "scroll" | "auto" | "inherit"
    }?
  SVG.Viewport.extra.attrib = empty
  SVG.Viewport.attrib =
    SVG.clip.attrib, SVG.overflow.attrib, SVG.Viewport.extra.attrib
  Paint.datatype = string
  StrokeDashArrayValue.datatype = string
  StrokeDashOffsetValue.datatype = string
  StrokeMiterLimitValue.datatype = string
  StrokeWidthValue.datatype = string
  SVG.fill.attrib = attribute fill { Paint.datatype }?
  SVG.fill-rule.attrib = attribute fill-rule { ClipFillRule.datatype }?
  SVG.stroke.attrib = attribute stroke { Paint.datatype }?
  SVG.stroke-dasharray.attrib =
    attribute stroke-dasharray { StrokeDashArrayValue.datatype }?
  SVG.stroke-dashoffset.attrib =
    attribute stroke-dashoffset { StrokeDashOffsetValue.datatype }?
  SVG.stroke-linecap.attrib =
    attribute stroke-linecap {
      "butt" | "round" | "square" | "inherit"
    }?
  SVG.stroke-linejoin.attrib =
    attribute stroke-linejoin {
      "miter" | "round" | "bevel" | "inherit"
    }?
  SVG.stroke-miterlimit.attrib =
    attribute stroke-miterlimit { StrokeMiterLimitValue.datatype }?
  SVG.stroke-width.attrib =
    attribute stroke-width { StrokeWidthValue.datatype }?
  SVG.Paint.extra.attrib = empty
  SVG.Paint.attrib =
    SVG.fill.attrib,
    SVG.fill-rule.attrib,
    SVG.stroke.attrib,
    SVG.stroke-dasharray.attrib,
    SVG.stroke-dashoffset.attrib,
    SVG.stroke-linecap.attrib,
    SVG.stroke-linejoin.attrib,
    SVG.stroke-miterlimit.attrib,
    SVG.stroke-width.attrib,
    SVG.Paint.extra.attrib
  SVG.color.attrib = attribute color { Color.datatype }?
  SVG.color-interpolation.attrib =
    attribute color-interpolation {
      "auto" | "sRGB" | "linearRGB" | "inherit"
    }?
  SVG.color-rendering.attrib =
    attribute color-rendering {
      "auto" | "optimizeSpeed" | "optimizeQuality" | "inherit"
    }?
  SVG.Color.extra.attrib = empty
  SVG.Color.attrib =
    SVG.color.attrib,
    SVG.color-interpolation.attrib,
    SVG.color-rendering.attrib,
    SVG.Color.extra.attrib
  SVG.opacity.attrib = attribute opacity { OpacityValue.datatype }?
  SVG.fill-opacity.attrib =
    attribute fill-opacity { OpacityValue.datatype }?
  SVG.stroke-opacity.attrib =
    attribute stroke-opacity { OpacityValue.datatype }?
  SVG.Opacity.extra.attrib = empty
  SVG.Opacity.attrib =
    SVG.opacity.attrib,
    SVG.fill-opacity.attrib,
    SVG.stroke-opacity.attrib,
    SVG.Opacity.extra.attrib
  SVG.display.attrib =
    attribute display {
      "inline"
      | "block"
      | "list-item"
      | "run-in"
      | "compact"
      | "marker"
      | "table"
      | "inline-table"
      | "table-row-group"
      | "table-header-group"
      | "table-footer-group"
      | "table-row"
      | "table-column-group"
      | "table-column"
      | "table-cell"
      | "table-caption"
      | "none"
      | "inherit"
    }?
  SVG.image-rendering.attrib =
    attribute image-rendering {
      "auto" | "optimizeSpeed" | "optimizeQuality" | "inherit"
    }?
  SVG.pointer-events.attrib =
    attribute pointer-events {
      "visiblePainted"
      | "visibleFill"
      | "visibleStroke"
      | "visible"
      | "painted"
      | "fill"
      | "stroke"
      | "all"
      | "none"
      | "inherit"
    }?
  SVG.shape-rendering.attrib =
    attribute shape-rendering {
      "auto"
      | "optimizeSpeed"
      | "crispEdges"
      | "geometricPrecision"
      | "inherit"
    }?
  SVG.text-rendering.attrib =
    attribute text-rendering {
      "auto"
      | "optimizeSpeed"
      | "optimizeLegibility"
      | "geometricPrecision"
      | "inherit"
    }?
  SVG.visibility.attrib =
    attribute visibility { "visible" | "hidden" | "inherit" }?
  SVG.Graphics.extra.attrib = empty
  SVG.Graphics.attrib =
    SVG.display.attrib,
    SVG.image-rendering.attrib,
    SVG.pointer-events.attrib,
    SVG.shape-rendering.attrib,
    SVG.text-rendering.attrib,
    SVG.visibility.attrib,
    SVG.Graphics.extra.attrib
  SVG.onunload.attrib = attribute onunload { Script.datatype }?
  SVG.onabort.attrib = attribute onabort { Script.datatype }?
  SVG.onerror.attrib = attribute onerror { Script.datatype }?
  SVG.onresize.attrib = attribute onresize { Script.datatype }?
  SVG.onscroll.attrib = attribute onscroll { Script.datatype }?
  SVG.onzoom.attrib = attribute onzoom { Script.datatype }?
  SVG.DocumentEvents.extra.attrib = empty
  SVG.DocumentEvents.attrib =
    SVG.onunload.attrib,
    SVG.onabort.attrib,
    SVG.onerror.attrib,
    SVG.onresize.attrib,
    SVG.onscroll.attrib,
    SVG.onzoom.attrib,
    SVG.DocumentEvents.extra.attrib
  SVG.onfocusin.attrib = attribute onfocusin { Script.datatype }?
  SVG.onfocusout.attrib = attribute onfocusout { Script.datatype }?
  SVG.onactivate.attrib = attribute onactivate { Script.datatype }?
  SVG.onclick.attrib = attribute onclick { Script.datatype }?
  SVG.onmousedown.attrib = attribute onmousedown { Script.datatype }?
  SVG.onmouseup.attrib = attribute onmouseup { Script.datatype }?
  SVG.onmouseover.attrib = attribute onmouseover { Script.datatype }?
  SVG.onmousemove.attrib = attribute onmousemove { Script.datatype }?
  SVG.onmouseout.attrib = attribute onmouseout { Script.datatype }?
  SVG.onload.attrib = attribute onload { Script.datatype }?
  SVG.GraphicalEvents.extra.attrib = empty
  SVG.GraphicalEvents.attrib =
    SVG.onfocusin.attrib,
    SVG.onfocusout.attrib,
    SVG.onactivate.attrib,
    SVG.onclick.attrib,
    SVG.onmousedown.attrib,
    SVG.onmouseup.attrib,
    SVG.onmouseover.attrib,
    SVG.onmousemove.attrib,
    SVG.onmouseout.attrib,
    SVG.onload.attrib,
    SVG.GraphicalEvents.extra.attrib
  SVG.onbegin.attrib = attribute onbegin { Script.datatype }?
  SVG.onend.attrib = attribute onend { Script.datatype }?
  SVG.onrepeat.attrib = attribute onrepeat { Script.datatype }?
  SVG.AnimationEvents.extra.attrib = empty
  SVG.AnimationEvents.attrib =
    SVG.onbegin.attrib,
    SVG.onend.attrib,
    SVG.onrepeat.attrib,
    SVG.onload.attrib,
    SVG.AnimationEvents.extra.attrib
  SVG.XLink.extra.attrib = empty
  SVG.XLink.attrib =
    XLINK.xmlns.attrib,
    [ a:defaultValue = "simple" ] attribute xlink:type { "simple" }?,
    attribute xlink:href { URI.datatype }?,
    attribute xlink:role { URI.datatype }?,
    attribute xlink:arcrole { URI.datatype }?,
    attribute xlink:title { text }?,
    [ a:defaultValue = "other" ] attribute xlink:show { "other" }?,
    [ a:defaultValue = "onLoad" ] attribute xlink:actuate { "onLoad" }?,
    SVG.XLink.extra.attrib
  SVG.XLinkRequired.extra.attrib = empty
  SVG.XLinkRequired.attrib =
    XLINK.xmlns.attrib,
    [ a:defaultValue = "simple" ] attribute xlink:type { "simple" }?,
    attribute xlink:href { URI.datatype },
    attribute xlink:role { URI.datatype }?,
    attribute xlink:arcrole { URI.datatype }?,
    attribute xlink:title { text }?,
    [ a:defaultValue = "other" ] attribute xlink:show { "other" }?,
    [ a:defaultValue = "onLoad" ] attribute xlink:actuate { "onLoad" }?,
    SVG.XLinkRequired.extra.attrib
  SVG.XLinkEmbed.extra.attrib = empty
  SVG.XLinkEmbed.attrib =
    XLINK.xmlns.attrib,
    [ a:defaultValue = "simple" ] attribute xlink:type { "simple" }?,
    attribute xlink:href { URI.datatype },
    attribute xlink:role { URI.datatype }?,
    attribute xlink:arcrole { URI.datatype }?,
    attribute xlink:title { text }?,
    [ a:defaultValue = "embed" ] attribute xlink:show { "embed" }?,
    [ a:defaultValue = "onLoad" ] attribute xlink:actuate { "onLoad" }?,
    SVG.XLinkEmbed.extra.attrib
  SVG.XLinkReplace.extra.attrib = empty
  SVG.XLinkReplace.attrib =
    XLINK.xmlns.attrib,
    [ a:defaultValue = "simple" ] attribute xlink:type { "simple" }?,
    attribute xlink:href { URI.datatype },
    attribute xlink:role { URI.datatype }?,
    attribute xlink:arcrole { URI.datatype }?,
    attribute xlink:title { text }?,
    [ a:defaultValue = "replace" ]
    attribute xlink:show { "new" | "replace" }?,
    [ a:defaultValue = "onRequest" ]
    attribute xlink:actuate { "onRequest" }?,
    SVG.XLinkReplace.extra.attrib
  SVG.externalResourcesRequired.attrib =
    attribute externalResourcesRequired { Boolean.datatype }?
  SVG.External.extra.attrib = empty
  SVG.External.attrib =
    SVG.externalResourcesRequired.attrib, SVG.External.extra.attrib
  SVG.Presentation.extra.attrib = empty
  SVG.Presentation.attrib =
    SVG.Container.attrib,
    SVG.Viewport.attrib,
    SVG.Text.attrib,
    SVG.TextContent.attrib,
    SVG.Font.attrib,
    SVG.Paint.attrib,
    SVG.Color.attrib,
    SVG.Opacity.attrib,
    SVG.Graphics.attrib,
    SVG.Marker.attrib,
    SVG.ColorProfile.attrib,
    SVG.Gradient.attrib,
    SVG.Clip.attrib,
    SVG.Mask.attrib,
    SVG.Filter.attrib,
    SVG.FilterColor.attrib,
    SVG.Cursor.attrib,
    attribute flood-color { SVGColor.datatype }?,
    attribute flood-opacity { OpacityValue.datatype }?,
    attribute lighting-color { SVGColor.datatype }?,
    SVG.Presentation.extra.attrib
  SVG.svg.extra.content = notAllowed
  SVG.svg.content =
    (SVG.Description.class
     | SVG.Animation.class
     | SVG.Structure.class
     | SVG.Conditional.class
     | SVG.Image.class
     | SVG.Style.class
     | SVG.Shape.class
     | SVG.Text.class
     | SVG.Marker.class
     | SVG.ColorProfile.class
     | SVG.Gradient.class
     | SVG.Pattern.class
     | SVG.Clip.class
     | SVG.Mask.class
     | SVG.Filter.class
     | SVG.Cursor.class
     | SVG.Hyperlink.class
     | SVG.View.class
     | SVG.Script.class
     | SVG.Font.class
     | SVG.svg.extra.content)*
  svg = element svg { attlist.svg, SVG.svg.content }
  attlist.svg &=
    SVG.xmlns.attrib,
    SVG.Core.attrib,
    SVG.Conditional.attrib,
    SVG.Style.attrib,
    SVG.Presentation.attrib,
    SVG.DocumentEvents.attrib,
    SVG.GraphicalEvents.attrib,
    SVG.External.attrib,
    attribute x { Coordinate.datatype }?,
    attribute y { Coordinate.datatype }?,
    attribute width { Length.datatype }?,
    attribute height { Length.datatype }?,
    attribute viewBox { ViewBoxSpec.datatype }?,
    [ a:defaultValue = "xMidYMid meet" ]
    attribute preserveAspectRatio { PreserveAspectRatioSpec.datatype }?,
    [ a:defaultValue = "magnify" ]
    attribute zoomAndPan { "disable" | "magnify" }?,
    [ a:defaultValue = "1.1" ] attribute version { string "1.1" }?,
    attribute baseProfile { Text.datatype }?,
    [ a:defaultValue = "text/ecmascript" ]
    attribute contentScriptType { ContentType.datatype }?,
    [ a:defaultValue = "text/css" ]
    attribute contentStyleType { ContentType.datatype }?
  SVG.g.extra.content = notAllowed
  SVG.g.content =
    (SVG.Description.class
     | SVG.Animation.class
     | SVG.Structure.class
     | SVG.Conditional.class
     | SVG.Image.class
     | SVG.Style.class
     | SVG.Shape.class
     | SVG.Text.class
     | SVG.Marker.class
     | SVG.ColorProfile.class
     | SVG.Gradient.class
     | SVG.Pattern.class
     | SVG.Clip.class
     | SVG.Mask.class
     | SVG.Filter.class
     | SVG.Cursor.class
     | SVG.Hyperlink.class
     | SVG.View.class
     | SVG.Script.class
     | SVG.Font.class
     | SVG.g.extra.content)*
  g = element g { attlist.g, SVG.g.content }
  attlist.g &=
    SVG.Core.attrib,
    SVG.Conditional.attrib,
    SVG.Style.attrib,
    SVG.Presentation.attrib,
    SVG.GraphicalEvents.attrib,
    SVG.External.attrib,
    attribute transform { TransformList.datatype }?
  SVG.defs.extra.content = notAllowed
  SVG.defs.content =
    (SVG.Description.class
     | SVG.Animation.class
     | SVG.Structure.class
     | SVG.Conditional.class
     | SVG.Image.class
     | SVG.Style.class
     | SVG.Shape.class
     | SVG.Text.class
     | SVG.Marker.class
     | SVG.ColorProfile.class
     | SVG.Gradient.class
     | SVG.Pattern.class
     | SVG.Clip.class
     | SVG.Mask.class
     | SVG.Filter.class
     | SVG.Cursor.class
     | SVG.Hyperlink.class
     | SVG.View.class
     | SVG.Script.class
     | SVG.Font.class
     | SVG.defs.extra.content)*
  defs = element defs { attlist.defs, SVG.defs.content }
  attlist.defs &=
    SVG.Core.attrib,
    SVG.Conditional.attrib,
    SVG.Style.attrib,
    SVG.Presentation.attrib,
    SVG.GraphicalEvents.attrib,
    SVG.External.attrib,
    attribute transform { TransformList.datatype }?
  SVG.desc.extra.content = notAllowed
  SVG.desc.content = (text | SVG.desc.extra.content)*
  desc = element desc { attlist.desc, SVG.desc.content }
  attlist.desc &= SVG.Core.attrib, SVG.Style.attrib
  SVG.title.extra.content = notAllowed
  SVG.title.content = (text | SVG.title.extra.content)*
  title = element title { attlist.title, SVG.title.content }
  attlist.title &= SVG.Core.attrib, SVG.Style.attrib
  SVG.metadata.extra.content = notAllowed
  SVG.metadata.content = (text | SVG.metadata.extra.content)*
  metadata = element metadata { attlist.metadata, SVG.metadata.content }
  attlist.metadata &= SVG.Core.attrib
  SVG.symbol.extra.content = notAllowed
  SVG.symbol.content =
    (SVG.Description.class
     | SVG.Animation.class
     | SVG.Structure.class
     | SVG.Conditional.class
     | SVG.Image.class
     | SVG.Style.class
     | SVG.Shape.class
     | SVG.Text.class
     | SVG.Marker.class
     | SVG.ColorProfile.class
     | SVG.Gradient.class
     | SVG.Pattern.class
     | SVG.Clip.class
     | SVG.Mask.class
     | SVG.Filter.class
     | SVG.Cursor.class
     | SVG.Hyperlink.class
     | SVG.View.class
     | SVG.Script.class
     | SVG.Font.class
     | SVG.symbol.extra.content)*
  symbol = element symbol { attlist.symbol, SVG.symbol.content }
  attlist.symbol &=
    SVG.Core.attrib,
    SVG.Style.attrib,
    SVG.Presentation.attrib,
    SVG.GraphicalEvents.attrib,
    SVG.External.attrib,
    attribute viewBox { ViewBoxSpec.datatype }?,
    [ a:defaultValue = "xMidYMid meet" ]
    attribute preserveAspectRatio { PreserveAspectRatioSpec.datatype }?
  SVG.use.extra.content = notAllowed
  SVG.use.content =
    SVG.Description.class*,
    (SVG.Animation.class | SVG.use.extra.content)*
  use = element use { attlist.use, SVG.use.content }
  attlist.use &=
    SVG.Core.attrib,
    SVG.Conditional.attrib,
    SVG.Style.attrib,
    SVG.Presentation.attrib,
    SVG.GraphicalEvents.attrib,
    SVG.XLinkEmbed.attrib,
    SVG.External.attrib,
    attribute x { Coordinate.datatype }?,
    attribute y { Coordinate.datatype }?,
    attribute width { Length.datatype }?,
    attribute height { Length.datatype }?,
    attribute transform { TransformList.datatype }?
  SVG.switch.extra.content = notAllowed
  SVG.switch.content =
    SVG.Description.class*,
    (svg
     | g
     | use
     | \text
     | SVG.Animation.class
     | SVG.Conditional.class
     | SVG.Image.class
     | SVG.Shape.class
     | SVG.Hyperlink.class
     | SVG.Extensibility.class
     | SVG.switch.extra.content)*
  switch = element switch { attlist.switch, SVG.switch.content }
  attlist.switch &=
    SVG.Core.attrib,
    SVG.Conditional.attrib,
    SVG.Style.attrib,
    SVG.Presentation.attrib,
    SVG.GraphicalEvents.attrib,
    SVG.External.attrib,
    attribute transform { TransformList.datatype }?
  SVG.image.extra.content = notAllowed
  SVG.image.content =
    SVG.Description.class*,
    (SVG.Animation.class | SVG.image.extra.content)*
  image = element image { attlist.image, SVG.image.content }
  attlist.image &=
    SVG.Core.attrib,
    SVG.Conditional.attrib,
    SVG.Style.attrib,
    SVG.Viewport.attrib,
    SVG.Color.attrib,
    SVG.Opacity.attrib,
    SVG.Graphics.attrib,
    SVG.ColorProfile.attrib,
    SVG.Clip.attrib,
    SVG.Mask.attrib,
    SVG.Filter.attrib,
    SVG.GraphicalEvents.attrib,
    SVG.Cursor.attrib,
    SVG.XLinkEmbed.attrib,
    SVG.External.attrib,
    attribute x { Coordinate.datatype }?,
    attribute y { Coordinate.datatype }?,
    attribute width { Length.datatype },
    attribute height { Length.datatype },
    [ a:defaultValue = "xMidYMid meet" ]
    attribute preserveAspectRatio { PreserveAspectRatioSpec.datatype }?,
    attribute transform { TransformList.datatype }?
  MediaDesc.datatype = string
  SVG.style.extra.content = notAllowed
  SVG.style.content = (text | SVG.style.extra.content)*
  style = element style { attlist.style, SVG.style.content }
  attlist.style &=
    [ a:defaultValue = "preserve" ] attribute xml:space { "preserve" }?,
    SVG.id.attrib,
    SVG.base.attrib,
    SVG.lang.attrib,
    SVG.Core.extra.attrib,
    attribute type { ContentType.datatype },
    attribute media { MediaDesc.datatype }?,
    attribute title { Text.datatype }?
  Points.datatype = string
  SVG.path.extra.content = notAllowed
  SVG.path.content =
    SVG.Description.class*,
    (SVG.Animation.class | SVG.path.extra.content)*
  path = element path { attlist.path, SVG.path.content }
  attlist.path &=
    SVG.Core.attrib,
    SVG.Conditional.attrib,
    SVG.Style.attrib,
    SVG.Paint.attrib,
    SVG.Color.attrib,
    SVG.Opacity.attrib,
    SVG.Graphics.attrib,
    SVG.Marker.attrib,
    SVG.Clip.attrib,
    SVG.Mask.attrib,
    SVG.Filter.attrib,
    SVG.GraphicalEvents.attrib,
    SVG.Cursor.attrib,
    SVG.External.attrib,
    attribute d { PathData.datatype },
    attribute pathLength { Number.datatype }?,
    attribute transform { TransformList.datatype }?
  SVG.rect.extra.content = notAllowed
  SVG.rect.content =
    SVG.Description.class*,
    (SVG.Animation.class | SVG.rect.extra.content)*
  rect = element rect { attlist.rect, SVG.rect.content }
  attlist.rect &=
    SVG.Core.attrib,
    SVG.Conditional.attrib,
    SVG.Style.attrib,
    SVG.Paint.attrib,
    SVG.Color.attrib,
    SVG.Opacity.attrib,
    SVG.Graphics.attrib,
    SVG.Clip.attrib,
    SVG.Mask.attrib,
    SVG.Filter.attrib,
    SVG.GraphicalEvents.attrib,
    SVG.Cursor.attrib,
    SVG.External.attrib,
    attribute x { Coordinate.datatype }?,
    attribute y { Coordinate.datatype }?,
    attribute width { Length.datatype },
    attribute height { Length.datatype },
    attribute rx { Length.datatype }?,
    attribute ry { Length.datatype }?,
    attribute transform { TransformList.datatype }?
  SVG.circle.extra.content = notAllowed
  SVG.circle.content =
    SVG.Description.class*,
    (SVG.Animation.class | SVG.circle.extra.content)*
  circle = element circle { attlist.circle, SVG.circle.content }
  attlist.circle &=
    SVG.Core.attrib,
    SVG.Conditional.attrib,
    SVG.Style.attrib,
    SVG.Paint.attrib,
    SVG.Color.attrib,
    SVG.Opacity.attrib,
    SVG.Graphics.attrib,
    SVG.Clip.attrib,
    SVG.Mask.attrib,
    SVG.Filter.attrib,
    SVG.GraphicalEvents.attrib,
    SVG.Cursor.attrib,
    SVG.External.attrib,
    attribute cx { Coordinate.datatype }?,
    attribute cy { Coordinate.datatype }?,
    attribute r { Length.datatype },
    attribute transform { TransformList.datatype }?
  SVG.line.extra.content = notAllowed
  SVG.line.content =
    SVG.Description.class*,
    (SVG.Animation.class | SVG.line.extra.content)*
  line = element line { attlist.line, SVG.line.content }
  attlist.line &=
    SVG.Core.attrib,
    SVG.Conditional.attrib,
    SVG.Style.attrib,
    SVG.Paint.attrib,
    SVG.Color.attrib,
    SVG.Opacity.attrib,
    SVG.Graphics.attrib,
    SVG.Marker.attrib,
    SVG.Clip.attrib,
    SVG.Mask.attrib,
    SVG.Filter.attrib,
    SVG.GraphicalEvents.attrib,
    SVG.Cursor.attrib,
    SVG.External.attrib,
    attribute x1 { Coordinate.datatype }?,
    attribute y1 { Coordinate.datatype }?,
    attribute x2 { Coordinate.datatype }?,
    attribute y2 { Coordinate.datatype }?,
    attribute transform { TransformList.datatype }?
  SVG.ellipse.extra.content = notAllowed
  SVG.ellipse.content =
    SVG.Description.class*,
    (SVG.Animation.class | SVG.ellipse.extra.content)*
  ellipse = element ellipse { attlist.ellipse, SVG.ellipse.content }
  attlist.ellipse &=
    SVG.Core.attrib,
    SVG.Conditional.attrib,
    SVG.Style.attrib,
    SVG.Paint.attrib,
    SVG.Color.attrib,
    SVG.Opacity.attrib,
    SVG.Graphics.attrib,
    SVG.Clip.attrib,
    SVG.Mask.attrib,
    SVG.Filter.attrib,
    SVG.GraphicalEvents.attrib,
    SVG.Cursor.attrib,
    SVG.External.attrib,
    attribute cx { Coordinate.datatype }?,
    attribute cy { Coordinate.datatype }?,
    attribute rx { Length.datatype },
    attribute ry { Length.datatype },
    attribute transform { TransformList.datatype }?
  SVG.polyline.extra.content = notAllowed
  SVG.polyline.content =
    SVG.Description.class*,
    (SVG.Animation.class | SVG.polyline.extra.content)*
  polyline = element polyline { attlist.polyline, SVG.polyline.content }
  attlist.polyline &=
    SVG.Core.attrib,
    SVG.Conditional.attrib,
    SVG.Style.attrib,
    SVG.Paint.attrib,
    SVG.Color.attrib,
    SVG.Opacity.attrib,
    SVG.Graphics.attrib,
    SVG.Marker.attrib,
    SVG.Clip.attrib,
    SVG.Mask.attrib,
    SVG.Filter.attrib,
    SVG.GraphicalEvents.attrib,
    SVG.Cursor.attrib,
    SVG.External.attrib,
    attribute points { Points.datatype },
    attribute transform { TransformList.datatype }?
  SVG.polygon.extra.content = notAllowed
  SVG.polygon.content =
    SVG.Description.class*,
    (SVG.Animation.class | SVG.polygon.extra.content)*
  polygon = element polygon { attlist.polygon, SVG.polygon.content }
  attlist.polygon &=
    SVG.Core.attrib,
    SVG.Conditional.attrib,
    SVG.Style.attrib,
    SVG.Paint.attrib,
    SVG.Color.attrib,
    SVG.Opacity.attrib,
    SVG.Graphics.attrib,
    SVG.Marker.attrib,
    SVG.Clip.attrib,
    SVG.Mask.attrib,
    SVG.Filter.attrib,
    SVG.GraphicalEvents.attrib,
    SVG.Cursor.attrib,
    SVG.External.attrib,
    attribute points { Points.datatype },
    attribute transform { TransformList.datatype }?
  SVG.text.extra.content = notAllowed
  SVG.text.content =
    (text
     | SVG.Description.class
     | SVG.Animation.class
     | SVG.TextContent.class
     | SVG.Hyperlink.class
     | SVG.text.extra.content)*
  \text = element text { attlist.text, SVG.text.content }
  attlist.text &=
    SVG.Core.attrib,
    SVG.Conditional.attrib,
    SVG.Style.attrib,
    SVG.Text.attrib,
    SVG.TextContent.attrib,
    SVG.Font.attrib,
    SVG.Paint.attrib,
    SVG.Color.attrib,
    SVG.Opacity.attrib,
    SVG.Graphics.attrib,
    SVG.Clip.attrib,
    SVG.Mask.attrib,
    SVG.Filter.attrib,
    SVG.GraphicalEvents.attrib,
    SVG.Cursor.attrib,
    SVG.External.attrib,
    attribute x { Coordinates.datatype }?,
    attribute y { Coordinates.datatype }?,
    attribute dx { Lengths.datatype }?,
    attribute dy { Lengths.datatype }?,
    attribute rotate { Numbers.datatype }?,
    attribute textLength { Length.datatype }?,
    attribute lengthAdjust { "spacing" | "spacingAndGlyphs" }?,
    attribute transform { TransformList.datatype }?
  SVG.tspan.extra.content = notAllowed
  SVG.tspan.content =
    (text
     | tspan
     | tref
     | altGlyph
     | animate
     | set
     | animateColor
     | SVG.Description.class
     | SVG.Hyperlink.class
     | SVG.tspan.extra.content)*
  tspan = element tspan { attlist.tspan, SVG.tspan.content }
  attlist.tspan &=
    SVG.Core.attrib,
    SVG.Conditional.attrib,
    SVG.Style.attrib,
    SVG.TextContent.attrib,
    SVG.Font.attrib,
    SVG.Paint.attrib,
    SVG.Color.attrib,
    SVG.Opacity.attrib,
    SVG.Graphics.attrib,
    SVG.Clip.attrib,
    SVG.Mask.attrib,
    SVG.Filter.attrib,
    SVG.GraphicalEvents.attrib,
    SVG.Cursor.attrib,
    SVG.External.attrib,
    attribute x { Coordinates.datatype }?,
    attribute y { Coordinates.datatype }?,
    attribute dx { Lengths.datatype }?,
    attribute dy { Lengths.datatype }?,
    attribute rotate { Numbers.datatype }?,
    attribute textLength { Length.datatype }?,
    attribute lengthAdjust { "spacing" | "spacingAndGlyphs" }?
  SVG.tref.extra.content = notAllowed
  SVG.tref.content =
    (animate
     | set
     | animateColor
     | SVG.Description.class
     | SVG.tref.extra.content)*
  tref = element tref { attlist.tref, SVG.tref.content }
  attlist.tref &=
    SVG.Core.attrib,
    SVG.Conditional.attrib,
    SVG.Style.attrib,
    SVG.TextContent.attrib,
    SVG.Font.attrib,
    SVG.Paint.attrib,
    SVG.Color.attrib,
    SVG.Opacity.attrib,
    SVG.Graphics.attrib,
    SVG.Clip.attrib,
    SVG.Mask.attrib,
    SVG.Filter.attrib,
    SVG.GraphicalEvents.attrib,
    SVG.Cursor.attrib,
    SVG.XLinkRequired.attrib,
    SVG.External.attrib,
    attribute x { Coordinates.datatype }?,
    attribute y { Coordinates.datatype }?,
    attribute dx { Lengths.datatype }?,
    attribute dy { Lengths.datatype }?,
    attribute rotate { Numbers.datatype }?,
    attribute textLength { Length.datatype }?,
    attribute lengthAdjust { "spacing" | "spacingAndGlyphs" }?
  SVG.textPath.extra.content = notAllowed
  SVG.textPath.content =
    (text
     | tspan
     | tref
     | altGlyph
     | animate
     | set
     | animateColor
     | SVG.Description.class
     | SVG.Hyperlink.class
     | SVG.textPath.extra.content)*
  textPath = element textPath { attlist.textPath, SVG.textPath.content }
  attlist.textPath &=
    SVG.Core.attrib,
    SVG.Conditional.attrib,
    SVG.Style.attrib,
    SVG.TextContent.attrib,
    SVG.Font.attrib,
    SVG.Paint.attrib,
    SVG.Color.attrib,
    SVG.Opacity.attrib,
    SVG.Graphics.attrib,
    SVG.Clip.attrib,
    SVG.Mask.attrib,
    SVG.Filter.attrib,
    SVG.GraphicalEvents.attrib,
    SVG.Cursor.attrib,
    SVG.XLinkRequired.attrib,
    SVG.External.attrib,
    attribute startOffset { Length.datatype }?,
    attribute textLength { Length.datatype }?,
    attribute lengthAdjust { "spacing" | "spacingAndGlyphs" }?,
    attribute method { "align" | "stretch" }?,
    attribute spacing { "auto" | "exact" }?
  SVG.altGlyph.extra.content = notAllowed
  SVG.altGlyph.content = (text | SVG.altGlyph.extra.content)*
  altGlyph = element altGlyph { attlist.altGlyph, SVG.altGlyph.content }
  attlist.altGlyph &=
    SVG.Core.attrib,
    SVG.Conditional.attrib,
    SVG.Style.attrib,
    SVG.TextContent.attrib,
    SVG.Font.attrib,
    SVG.Paint.attrib,
    SVG.Color.attrib,
    SVG.Opacity.attrib,
    SVG.Graphics.attrib,
    SVG.Clip.attrib,
    SVG.Mask.attrib,
    SVG.Filter.attrib,
    SVG.GraphicalEvents.attrib,
    SVG.Cursor.attrib,
    SVG.XLink.attrib,
    SVG.External.attrib,
    attribute x { Coordinates.datatype }?,
    attribute y { Coordinates.datatype }?,
    attribute dx { Lengths.datatype }?,
    attribute dy { Lengths.datatype }?,
    attribute glyphRef { text }?,
    attribute format { text }?,
    attribute rotate { Numbers.datatype }?
  SVG.altGlyphDef.extra.content = notAllowed
  SVG.altGlyphDef.content =
    (glyphRef+ | altGlyphItem+) | SVG.altGlyphDef.extra.content
  altGlyphDef =
    element altGlyphDef { attlist.altGlyphDef, SVG.altGlyphDef.content }
  attlist.altGlyphDef &= SVG.Core.attrib
  SVG.altGlyphItem.extra.content = notAllowed
  SVG.altGlyphItem.content = glyphRef+ | SVG.altGlyphItem.extra.content
  altGlyphItem =
    element altGlyphItem {
      attlist.altGlyphItem, SVG.altGlyphItem.content
    }
  attlist.altGlyphItem &= SVG.Core.attrib
  SVG.glyphRef.content = empty
  glyphRef = element glyphRef { attlist.glyphRef, SVG.glyphRef.content }
  attlist.glyphRef &=
    SVG.Core.attrib,
    SVG.Style.attrib,
    SVG.Font.attrib,
    SVG.XLink.attrib,
    attribute x { Number.datatype }?,
    attribute y { Number.datatype }?,
    attribute dx { Number.datatype }?,
    attribute dy { Number.datatype }?,
    attribute glyphRef { text }?,
    attribute format { text }?
  SVG.marker.extra.content = notAllowed
  SVG.marker.content =
    (SVG.Description.class
     | SVG.Animation.class
     | SVG.Structure.class
     | SVG.Conditional.class
     | SVG.Image.class
     | SVG.Style.class
     | SVG.Shape.class
     | SVG.Text.class
     | SVG.Marker.class
     | SVG.ColorProfile.class
     | SVG.Gradient.class
     | SVG.Pattern.class
     | SVG.Clip.class
     | SVG.Mask.class
     | SVG.Filter.class
     | SVG.Cursor.class
     | SVG.Hyperlink.class
     | SVG.View.class
     | SVG.Script.class
     | SVG.Font.class
     | SVG.marker.extra.content)*
  marker = element marker { attlist.marker, SVG.marker.content }
  attlist.marker &=
    SVG.Core.attrib,
    SVG.Style.attrib,
    SVG.Presentation.attrib,
    SVG.External.attrib,
    attribute refX { Coordinate.datatype }?,
    attribute refY { Coordinate.datatype }?,
    attribute markerUnits { "strokeWidth" | "userSpaceOnUse" }?,
    attribute markerWidth { Length.datatype }?,
    attribute markerHeight { Length.datatype }?,
    attribute orient { text }?,
    attribute viewBox { ViewBoxSpec.datatype }?,
    [ a:defaultValue = "xMidYMid meet" ]
    attribute preserveAspectRatio { PreserveAspectRatioSpec.datatype }?
  SVG.color-profile.extra.content = notAllowed
  SVG.color-profile.content =
    (SVG.Description.class | SVG.color-profile.extra.content)*
  color-profile =
    element color-profile {
      attlist.color-profile, SVG.color-profile.content
    }
  attlist.color-profile &=
    SVG.Core.attrib,
    SVG.XLink.attrib,
    attribute local { text }?,
    attribute name { text },
    [ a:defaultValue = "auto" ]
    attribute rendering-intent {
      "auto"
      | "perceptual"
      | "relative-colorimetric"
      | "saturation"
      | "absolute-colorimetric"
    }?
  SVG.linearGradient.extra.content = notAllowed
  SVG.linearGradient.content =
    SVG.Description.class*,
    (stop
     | animate
     | set
     | animateTransform
     | SVG.linearGradient.extra.content)*
  linearGradient =
    element linearGradient {
      attlist.linearGradient, SVG.linearGradient.content
    }
  attlist.linearGradient &=
    SVG.Core.attrib,
    SVG.Style.attrib,
    SVG.Color.attrib,
    SVG.Gradient.attrib,
    SVG.XLink.attrib,
    SVG.External.attrib,
    attribute x1 { Coordinate.datatype }?,
    attribute y1 { Coordinate.datatype }?,
    attribute x2 { Coordinate.datatype }?,
    attribute y2 { Coordinate.datatype }?,
    attribute gradientUnits { "userSpaceOnUse" | "objectBoundingBox" }?,
    attribute gradientTransform { TransformList.datatype }?,
    attribute spreadMethod { "pad" | "reflect" | "repeat" }?
  SVG.radialGradient.extra.content = notAllowed
  SVG.radialGradient.content =
    SVG.Description.class*,
    (stop
     | animate
     | set
     | animateTransform
     | SVG.radialGradient.extra.content)*
  radialGradient =
    element radialGradient {
      attlist.radialGradient, SVG.radialGradient.content
    }
  attlist.radialGradient &=
    SVG.Core.attrib,
    SVG.Style.attrib,
    SVG.Color.attrib,
    SVG.Gradient.attrib,
    SVG.XLink.attrib,
    SVG.External.attrib,
    attribute cx { Coordinate.datatype }?,
    attribute cy { Coordinate.datatype }?,
    attribute r { Length.datatype }?,
    attribute fx { Coordinate.datatype }?,
    attribute fy { Coordinate.datatype }?,
    attribute gradientUnits { "userSpaceOnUse" | "objectBoundingBox" }?,
    attribute gradientTransform { TransformList.datatype }?,
    attribute spreadMethod { "pad" | "reflect" | "repeat" }?
  SVG.stop.extra.content = notAllowed
  SVG.stop.content =
    (animate | set | animateColor | SVG.stop.extra.content)*
  stop = element stop { attlist.stop, SVG.stop.content }
  attlist.stop &=
    SVG.Core.attrib,
    SVG.Style.attrib,
    SVG.Color.attrib,
    SVG.Gradient.attrib,
    attribute offset { NumberOrPercentage.datatype }
  SVG.pattern.extra.content = notAllowed
  SVG.pattern.content =
    (SVG.Description.class
     | SVG.Animation.class
     | SVG.Structure.class
     | SVG.Conditional.class
     | SVG.Image.class
     | SVG.Style.class
     | SVG.Shape.class
     | SVG.Text.class
     | SVG.Marker.class
     | SVG.ColorProfile.class
     | SVG.Gradient.class
     | SVG.Pattern.class
     | SVG.Clip.class
     | SVG.Mask.class
     | SVG.Filter.class
     | SVG.Cursor.class
     | SVG.Hyperlink.class
     | SVG.View.class
     | SVG.Script.class
     | SVG.Font.class
     | SVG.pattern.extra.content)*
  svgpattern = element pattern { attlist.pattern, SVG.pattern.content }
  attlist.pattern &=
    SVG.Core.attrib,
    SVG.Conditional.attrib,
    SVG.Style.attrib,
    SVG.Presentation.attrib,
    SVG.XLink.attrib,
    SVG.External.attrib,
    attribute x { Coordinate.datatype }?,
    attribute y { Coordinate.datatype }?,
    attribute width { Length.datatype }?,
    attribute height { Length.datatype }?,
    attribute patternUnits { "userSpaceOnUse" | "objectBoundingBox" }?,
    attribute patternContentUnits {
      "userSpaceOnUse" | "objectBoundingBox"
    }?,
    attribute patternTransform { TransformList.datatype }?,
    attribute viewBox { ViewBoxSpec.datatype }?,
    [ a:defaultValue = "xMidYMid meet" ]
    attribute preserveAspectRatio { PreserveAspectRatioSpec.datatype }?
  SVG.clipPath.extra.content = notAllowed
  SVG.clipPath.content =
    SVG.Description.class*,
    (SVG.Animation.class
     | SVG.Use.class
     | SVG.Shape.class
     | SVG.Text.class
     | SVG.clipPath.extra.content)*
  clipPath = element clipPath { attlist.clipPath, SVG.clipPath.content }
  attlist.clipPath &=
    SVG.Core.attrib,
    SVG.Conditional.attrib,
    SVG.Style.attrib,
    SVG.Text.attrib,
    SVG.TextContent.attrib,
    SVG.Font.attrib,
    SVG.Paint.attrib,
    SVG.Color.attrib,
    SVG.Opacity.attrib,
    SVG.Graphics.attrib,
    SVG.Clip.attrib,
    SVG.Mask.attrib,
    SVG.Filter.attrib,
    SVG.Cursor.attrib,
    SVG.External.attrib,
    attribute transform { TransformList.datatype }?,
    attribute clipPathUnits { "userSpaceOnUse" | "objectBoundingBox" }?
  SVG.mask.extra.content = notAllowed
  SVG.mask.content =
    (SVG.Description.class
     | SVG.Animation.class
     | SVG.Structure.class
     | SVG.Conditional.class
     | SVG.Image.class
     | SVG.Style.class
     | SVG.Shape.class
     | SVG.Text.class
     | SVG.Marker.class
     | SVG.ColorProfile.class
     | SVG.Gradient.class
     | SVG.Pattern.class
     | SVG.Clip.class
     | SVG.Mask.class
     | SVG.Filter.class
     | SVG.Cursor.class
     | SVG.Hyperlink.class
     | SVG.View.class
     | SVG.Script.class
     | SVG.Font.class
     | SVG.mask.extra.content)*
  mask = element mask { attlist.mask, SVG.mask.content }
  attlist.mask &=
    SVG.Core.attrib,
    SVG.Conditional.attrib,
    SVG.Style.attrib,
    SVG.Presentation.attrib,
    SVG.External.attrib,
    attribute x { Coordinate.datatype }?,
    attribute y { Coordinate.datatype }?,
    attribute width { Length.datatype }?,
    attribute height { Length.datatype }?,
    attribute maskUnits { "userSpaceOnUse" | "objectBoundingBox" }?,
    attribute maskContentUnits {
      "userSpaceOnUse" | "objectBoundingBox"
    }?
  SVG.FilterPrimitive.extra.attrib = empty
  SVG.FilterPrimitive.attrib =
    attribute x { Coordinate.datatype }?,
    attribute y { Coordinate.datatype }?,
    attribute width { Length.datatype }?,
    attribute height { Length.datatype }?,
    attribute result { text }?,
    SVG.FilterPrimitive.extra.attrib
  SVG.FilterPrimitiveWithIn.extra.attrib = empty
  SVG.FilterPrimitiveWithIn.attrib =
    SVG.FilterPrimitive.attrib,
    attribute in { text }?,
    SVG.FilterPrimitiveWithIn.extra.attrib
  SVG.filter.extra.content = notAllowed
  SVG.filter.content =
    SVG.Description.class*,
    (animate
     | set
     | SVG.FilterPrimitive.class
     | SVG.filter.extra.content)*
  filter = element filter { attlist.filter, SVG.filter.content }
  attlist.filter &=
    SVG.Core.attrib,
    SVG.Style.attrib,
    SVG.Presentation.attrib,
    SVG.XLink.attrib,
    SVG.External.attrib,
    attribute x { Coordinate.datatype }?,
    attribute y { Coordinate.datatype }?,
    attribute width { Length.datatype }?,
    attribute height { Length.datatype }?,
    attribute filterRes { NumberOptionalNumber.datatype }?,
    attribute filterUnits { "userSpaceOnUse" | "objectBoundingBox" }?,
    attribute primitiveUnits { "userSpaceOnUse" | "objectBoundingBox" }?
  SVG.feBlend.extra.content = notAllowed
  SVG.feBlend.content = (animate | set | SVG.feBlend.extra.content)*
  feBlend = element feBlend { attlist.feBlend, SVG.feBlend.content }
  attlist.feBlend &=
    SVG.Core.attrib,
    SVG.FilterColor.attrib,
    SVG.FilterPrimitiveWithIn.attrib,
    attribute in2 { text },
    [ a:defaultValue = "normal" ]
    attribute mode {
      "normal" | "multiply" | "screen" | "darken" | "lighten"
    }?
  SVG.feColorMatrix.extra.content = notAllowed
  SVG.feColorMatrix.content =
    (animate | set | SVG.feColorMatrix.extra.content)*
  feColorMatrix =
    element feColorMatrix {
      attlist.feColorMatrix, SVG.feColorMatrix.content
    }
  attlist.feColorMatrix &=
    SVG.Core.attrib,
    SVG.FilterColor.attrib,
    SVG.FilterPrimitiveWithIn.attrib,
    [ a:defaultValue = "matrix" ]
    attribute type {
      "matrix" | "saturate" | "hueRotate" | "luminanceToAlpha"
    }?,
    attribute values { text }?
  SVG.feComponentTransfer.extra.content = empty
  SVG.feComponentTransfer.content =
    feFuncR?,
    feFuncG?,
    feFuncB?,
    feFuncA?,
    SVG.feComponentTransfer.extra.content
  feComponentTransfer =
    element feComponentTransfer {
      attlist.feComponentTransfer, SVG.feComponentTransfer.content
    }
  attlist.feComponentTransfer &=
    SVG.Core.attrib,
    SVG.FilterColor.attrib,
    SVG.FilterPrimitiveWithIn.attrib
  SVG.feComposite.extra.content = notAllowed
  SVG.feComposite.content =
    (animate | set | SVG.feComposite.extra.content)*
  feComposite =
    element feComposite { attlist.feComposite, SVG.feComposite.content }
  attlist.feComposite &=
    SVG.Core.attrib,
    SVG.FilterColor.attrib,
    SVG.FilterPrimitiveWithIn.attrib,
    attribute in2 { text },
    [ a:defaultValue = "over" ]
    attribute operator {
      "over" | "in" | "out" | "atop" | "xor" | "arithmetic"
    }?,
    attribute k1 { Number.datatype }?,
    attribute k2 { Number.datatype }?,
    attribute k3 { Number.datatype }?,
    attribute k4 { Number.datatype }?
  SVG.feConvolveMatrix.extra.content = notAllowed
  SVG.feConvolveMatrix.content =
    (animate | set | SVG.feConvolveMatrix.extra.content)*
  feConvolveMatrix =
    element feConvolveMatrix {
      attlist.feConvolveMatrix, SVG.feConvolveMatrix.content
    }
  attlist.feConvolveMatrix &=
    SVG.Core.attrib,
    SVG.FilterColor.attrib,
    SVG.FilterPrimitiveWithIn.attrib,
    attribute order { NumberOptionalNumber.datatype },
    attribute kernelMatrix { text },
    attribute divisor { Number.datatype }?,
    attribute bias { Number.datatype }?,
    attribute targetX { Integer.datatype }?,
    attribute targetY { Integer.datatype }?,
    [ a:defaultValue = "duplicate" ]
    attribute edgeMode { "duplicate" | "wrap" | "none" }?,
    attribute kernelUnitLength { NumberOptionalNumber.datatype }?,
    attribute preserveAlpha { Boolean.datatype }?
  SVG.feDiffuseLighting.extra.content = notAllowed
  SVG.feDiffuseLighting.content =
    (feDistantLight | fePointLight | feSpotLight),
    (animate
     | set
     | animateColor
     | SVG.feDiffuseLighting.extra.content)*
  feDiffuseLighting =
    element feDiffuseLighting {
      attlist.feDiffuseLighting, SVG.feDiffuseLighting.content
    }
  attlist.feDiffuseLighting &=
    SVG.Core.attrib,
    SVG.Style.attrib,
    SVG.Color.attrib,
    SVG.FilterColor.attrib,
    SVG.FilterPrimitiveWithIn.attrib,
    attribute lighting-color { SVGColor.datatype }?,
    attribute surfaceScale { Number.datatype }?,
    attribute diffuseConstant { Number.datatype }?,
    attribute kernelUnitLength { NumberOptionalNumber.datatype }?
  SVG.feDisplacementMap.extra.content = notAllowed
  SVG.feDisplacementMap.content =
    (animate | set | SVG.feDisplacementMap.extra.content)*
  feDisplacementMap =
    element feDisplacementMap {
      attlist.feDisplacementMap, SVG.feDisplacementMap.content
    }
  attlist.feDisplacementMap &=
    SVG.Core.attrib,
    SVG.FilterColor.attrib,
    SVG.FilterPrimitiveWithIn.attrib,
    attribute in2 { text },
    attribute scale { Number.datatype }?,
    [ a:defaultValue = "A" ]
    attribute xChannelSelector { "R" | "G" | "B" | "A" }?,
    [ a:defaultValue = "A" ]
    attribute yChannelSelector { "R" | "G" | "B" | "A" }?
  SVG.feFlood.extra.content = notAllowed
  SVG.feFlood.content =
    (animate | set | animateColor | SVG.feFlood.extra.content)*
  feFlood = element feFlood { attlist.feFlood, SVG.feFlood.content }
  attlist.feFlood &=
    SVG.Core.attrib,
    SVG.Style.attrib,
    SVG.Color.attrib,
    SVG.FilterColor.attrib,
    SVG.FilterPrimitiveWithIn.attrib,
    attribute flood-color { SVGColor.datatype }?,
    attribute flood-opacity { OpacityValue.datatype }?
  SVG.feGaussianBlur.extra.content = notAllowed
  SVG.feGaussianBlur.content =
    (animate | set | SVG.feGaussianBlur.extra.content)*
  feGaussianBlur =
    element feGaussianBlur {
      attlist.feGaussianBlur, SVG.feGaussianBlur.content
    }
  attlist.feGaussianBlur &=
    SVG.Core.attrib,
    SVG.FilterColor.attrib,
    SVG.FilterPrimitiveWithIn.attrib,
    attribute stdDeviation { NumberOptionalNumber.datatype }?
  SVG.feImage.extra.content = notAllowed
  SVG.feImage.content =
    (animate | set | animateTransform | SVG.feImage.extra.content)*
  feImage = element feImage { attlist.feImage, SVG.feImage.content }
  attlist.feImage &=
    SVG.Core.attrib,
    SVG.Style.attrib,
    SVG.Presentation.attrib,
    SVG.FilterPrimitive.attrib,
    SVG.XLinkEmbed.attrib,
    SVG.External.attrib,
    [ a:defaultValue = "xMidYMid meet" ]
    attribute preserveAspectRatio { PreserveAspectRatioSpec.datatype }?
  SVG.feMerge.extra.content = notAllowed
  SVG.feMerge.content = (feMergeNode | SVG.feMerge.extra.content)*
  feMerge = element feMerge { attlist.feMerge, SVG.feMerge.content }
  attlist.feMerge &=
    SVG.Core.attrib, SVG.FilterColor.attrib, SVG.FilterPrimitive.attrib
  SVG.feMergeNode.extra.content = notAllowed
  SVG.feMergeNode.content =
    (animate | set | SVG.feMergeNode.extra.content)*
  feMergeNode =
    element feMergeNode { attlist.feMergeNode, SVG.feMergeNode.content }
  attlist.feMergeNode &=
    SVG.Core.attrib,
    attribute in { text }?
  SVG.feMorphology.extra.content = notAllowed
  SVG.feMorphology.content =
    (animate | set | SVG.feMorphology.extra.content)*
  feMorphology =
    element feMorphology {
      attlist.feMorphology, SVG.feMorphology.content
    }
  attlist.feMorphology &=
    SVG.Core.attrib,
    SVG.FilterColor.attrib,
    SVG.FilterPrimitiveWithIn.attrib,
    [ a:defaultValue = "erode" ]
    attribute operator { "erode" | "dilate" }?,
    attribute radius { NumberOptionalNumber.datatype }?
  SVG.feOffset.extra.content = notAllowed
  SVG.feOffset.content = (animate | set | SVG.feOffset.extra.content)*
  feOffset = element feOffset { attlist.feOffset, SVG.feOffset.content }
  attlist.feOffset &=
    SVG.Core.attrib,
    SVG.FilterColor.attrib,
    SVG.FilterPrimitiveWithIn.attrib,
    attribute dx { Number.datatype }?,
    attribute dy { Number.datatype }?
  SVG.feSpecularLighting.extra.content = notAllowed
  SVG.feSpecularLighting.content =
    (feDistantLight | fePointLight | feSpotLight),
    (animate
     | set
     | animateColor
     | SVG.feSpecularLighting.extra.content)*
  feSpecularLighting =
    element feSpecularLighting {
      attlist.feSpecularLighting, SVG.feSpecularLighting.content
    }
  attlist.feSpecularLighting &=
    SVG.Core.attrib,
    SVG.Style.attrib,
    SVG.Color.attrib,
    SVG.FilterColor.attrib,
    SVG.FilterPrimitiveWithIn.attrib,
    attribute lighting-color { SVGColor.datatype }?,
    attribute surfaceScale { Number.datatype }?,
    attribute specularConstant { Number.datatype }?,
    attribute specularExponent { Number.datatype }?,
    attribute kernelUnitLength { NumberOptionalNumber.datatype }?
  SVG.feTile.extra.content = notAllowed
  SVG.feTile.content = (animate | set | SVG.feTile.extra.content)*
  feTile = element feTile { attlist.feTile, SVG.feTile.content }
  attlist.feTile &=
    SVG.Core.attrib,
    SVG.FilterColor.attrib,
    SVG.FilterPrimitiveWithIn.attrib
  SVG.feTurbulence.extra.content = notAllowed
  SVG.feTurbulence.content =
    (animate | set | SVG.feTurbulence.extra.content)*
  feTurbulence =
    element feTurbulence {
      attlist.feTurbulence, SVG.feTurbulence.content
    }
  attlist.feTurbulence &=
    SVG.Core.attrib,
    SVG.FilterColor.attrib,
    SVG.FilterPrimitive.attrib,
    attribute baseFrequency { NumberOptionalNumber.datatype }?,
    attribute numOctaves { Integer.datatype }?,
    attribute seed { Number.datatype }?,
    [ a:defaultValue = "noStitch" ]
    attribute stitchTiles { "stitch" | "noStitch" }?,
    [ a:defaultValue = "turbulence" ]
    attribute type { "fractalNoise" | "turbulence" }?
  SVG.feDistantLight.extra.content = notAllowed
  SVG.feDistantLight.content =
    (animate | set | SVG.feDistantLight.extra.content)*
  feDistantLight =
    element feDistantLight {
      attlist.feDistantLight, SVG.feDistantLight.content
    }
  attlist.feDistantLight &=
    SVG.Core.attrib,
    attribute azimuth { Number.datatype }?,
    attribute elevation { Number.datatype }?
  SVG.fePointLight.extra.content = notAllowed
  SVG.fePointLight.content =
    (animate | set | SVG.fePointLight.extra.content)*
  fePointLight =
    element fePointLight {
      attlist.fePointLight, SVG.fePointLight.content
    }
  attlist.fePointLight &=
    SVG.Core.attrib,
    attribute x { Number.datatype }?,
    attribute y { Number.datatype }?,
    attribute z { Number.datatype }?
  SVG.feSpotLight.extra.content = notAllowed
  SVG.feSpotLight.content =
    (animate | set | SVG.feSpotLight.extra.content)*
  feSpotLight =
    element feSpotLight { attlist.feSpotLight, SVG.feSpotLight.content }
  attlist.feSpotLight &=
    SVG.Core.attrib,
    attribute x { Number.datatype }?,
    attribute y { Number.datatype }?,
    attribute z { Number.datatype }?,
    attribute pointsAtX { Number.datatype }?,
    attribute pointsAtY { Number.datatype }?,
    attribute pointsAtZ { Number.datatype }?,
    attribute specularExponent { Number.datatype }?,
    attribute limitingConeAngle { Number.datatype }?
  SVG.feFuncR.extra.content = notAllowed
  SVG.feFuncR.content = (animate | set | SVG.feFuncR.extra.content)*
  feFuncR = element feFuncR { attlist.feFuncR, SVG.feFuncR.content }
  attlist.feFuncR &=
    SVG.Core.attrib,
    attribute type {
      "identity" | "table" | "discrete" | "linear" | "gamma"
    },
    attribute tableValues { text }?,
    attribute slope { Number.datatype }?,
    attribute intercept { Number.datatype }?,
    attribute amplitude { Number.datatype }?,
    attribute exponent { Number.datatype }?,
    attribute offset { Number.datatype }?
  SVG.feFuncG.extra.content = notAllowed
  SVG.feFuncG.content = (animate | set | SVG.feFuncG.extra.content)*
  feFuncG = element feFuncG { attlist.feFuncG, SVG.feFuncG.content }
  attlist.feFuncG &=
    SVG.Core.attrib,
    attribute type {
      "identity" | "table" | "discrete" | "linear" | "gamma"
    },
    attribute tableValues { text }?,
    attribute slope { Number.datatype }?,
    attribute intercept { Number.datatype }?,
    attribute amplitude { Number.datatype }?,
    attribute exponent { Number.datatype }?,
    attribute offset { Number.datatype }?
  SVG.feFuncB.extra.content = notAllowed
  SVG.feFuncB.content = (animate | set | SVG.feFuncB.extra.content)*
  feFuncB = element feFuncB { attlist.feFuncB, SVG.feFuncB.content }
  attlist.feFuncB &=
    SVG.Core.attrib,
    attribute type {
      "identity" | "table" | "discrete" | "linear" | "gamma"
    },
    attribute tableValues { text }?,
    attribute slope { Number.datatype }?,
    attribute intercept { Number.datatype }?,
    attribute amplitude { Number.datatype }?,
    attribute exponent { Number.datatype }?,
    attribute offset { Number.datatype }?
  SVG.feFuncA.extra.content = notAllowed
  SVG.feFuncA.content = (animate | set | SVG.feFuncA.extra.content)*
  feFuncA = element feFuncA { attlist.feFuncA, SVG.feFuncA.content }
  attlist.feFuncA &=
    SVG.Core.attrib,
    attribute type {
      "identity" | "table" | "discrete" | "linear" | "gamma"
    },
    attribute tableValues { text }?,
    attribute slope { Number.datatype }?,
    attribute intercept { Number.datatype }?,
    attribute amplitude { Number.datatype }?,
    attribute exponent { Number.datatype }?,
    attribute offset { Number.datatype }?
  SVG.cursor.extra.content = notAllowed
  SVG.cursor.content =
    (SVG.Description.class | SVG.cursor.extra.content)*
  cursor = element cursor { attlist.cursor, SVG.cursor.content }
  attlist.cursor &=
    SVG.Core.attrib,
    SVG.Conditional.attrib,
    SVG.XLinkRequired.attrib,
    SVG.External.attrib,
    attribute x { Coordinate.datatype }?,
    attribute y { Coordinate.datatype }?
  LinkTarget.datatype = xsd:NMTOKEN
  SVG.a.extra.content = notAllowed
  SVG.a.content =
    (text
     | SVG.Description.class
     | SVG.Animation.class
     | SVG.Structure.class
     | SVG.Conditional.class
     | SVG.Image.class
     | SVG.Style.class
     | SVG.Shape.class
     | SVG.Text.class
     | SVG.Marker.class
     | SVG.ColorProfile.class
     | SVG.Gradient.class
     | SVG.Pattern.class
     | SVG.Clip.class
     | SVG.Mask.class
     | SVG.Filter.class
     | SVG.Cursor.class
     | SVG.Hyperlink.class
     | SVG.View.class
     | SVG.Script.class
     | SVG.Font.class
     | SVG.a.extra.content)*
  a = element a { attlist.a, SVG.a.content }
  attlist.a &=
    SVG.Core.attrib,
    SVG.Conditional.attrib,
    SVG.Style.attrib,
    SVG.Presentation.attrib,
    SVG.GraphicalEvents.attrib,
    SVG.XLinkReplace.attrib,
    SVG.External.attrib,
    attribute transform { TransformList.datatype }?,
    attribute target { LinkTarget.datatype }?
  SVG.view.extra.content = notAllowed
  SVG.view.content = (SVG.Description.class | SVG.view.extra.content)*
  view = element view { attlist.view, SVG.view.content }
  attlist.view &=
    SVG.Core.attrib,
    SVG.External.attrib,
    attribute viewBox { ViewBoxSpec.datatype }?,
    [ a:defaultValue = "xMidYMid meet" ]
    attribute preserveAspectRatio { PreserveAspectRatioSpec.datatype }?,
    [ a:defaultValue = "magnify" ]
    attribute zoomAndPan { "disable" | "magnify" }?,
    attribute viewTarget { text }?
  SVG.script.extra.content = notAllowed
  SVG.script.content = (text | SVG.script.extra.content)*
  script = element script { attlist.script, SVG.script.content }
  attlist.script &=
    SVG.Core.attrib,
    SVG.XLink.attrib,
    SVG.External.attrib,
    attribute type { ContentType.datatype }
  SVG.Animation.extra.attrib = empty
  SVG.Animation.attrib = SVG.XLink.attrib, SVG.Animation.extra.attrib
  SVG.AnimationAttribute.extra.attrib = empty
  SVG.AnimationAttribute.attrib =
    attribute attributeName { text },
    attribute attributeType { text }?,
    SVG.AnimationAttribute.extra.attrib
  SVG.AnimationTiming.extra.attrib = empty
  SVG.AnimationTiming.attrib =
    attribute begin { text }?,
    attribute dur { text }?,
    attribute end { text }?,
    attribute min { text }?,
    attribute max { text }?,
    [ a:defaultValue = "always" ]
    attribute restart { "always" | "never" | "whenNotActive" }?,
    attribute repeatCount { text }?,
    attribute repeatDur { text }?,
    [ a:defaultValue = "remove" ]
    attribute fill { "remove" | "freeze" }?,
    SVG.AnimationTiming.extra.attrib
  SVG.AnimationValue.extra.attrib = empty
  SVG.AnimationValue.attrib =
    [ a:defaultValue = "linear" ]
    attribute calcMode { "discrete" | "linear" | "paced" | "spline" }?,
    attribute values { text }?,
    attribute keyTimes { text }?,
    attribute keySplines { text }?,
    attribute from { text }?,
    attribute to { text }?,
    attribute by { text }?,
    SVG.AnimationValue.extra.attrib
  SVG.AnimationAddtion.extra.attrib = empty
  SVG.AnimationAddtion.attrib =
    [ a:defaultValue = "replace" ]
    attribute additive { "replace" | "sum" }?,
    [ a:defaultValue = "none" ]
    attribute accumulate { "none" | "sum" }?,
    SVG.AnimationAddtion.extra.attrib
  SVG.animate.extra.content = notAllowed
  SVG.animate.content =
    (SVG.Description.class | SVG.animate.extra.content)*
  animate = element animate { attlist.animate, SVG.animate.content }
  attlist.animate &=
    SVG.Core.attrib,
    SVG.Conditional.attrib,
    SVG.AnimationEvents.attrib,
    SVG.External.attrib,
    SVG.Animation.attrib,
    SVG.AnimationAttribute.attrib,
    SVG.AnimationTiming.attrib,
    SVG.AnimationValue.attrib,
    SVG.AnimationAddtion.attrib
  SVG.set.extra.content = notAllowed
  SVG.set.content = (SVG.Description.class | SVG.set.extra.content)*
  set = element set { attlist.set, SVG.set.content }
  attlist.set &=
    SVG.Core.attrib,
    SVG.Conditional.attrib,
    SVG.AnimationEvents.attrib,
    SVG.External.attrib,
    SVG.Animation.attrib,
    SVG.AnimationAttribute.attrib,
    SVG.AnimationTiming.attrib,
    attribute to { text }?
  SVG.animateMotion.extra.content = empty
  SVG.animateMotion.content =
    SVG.Description.class*, mpath?, SVG.animateMotion.extra.content
  animateMotion =
    element animateMotion {
      attlist.animateMotion, SVG.animateMotion.content
    }
  attlist.animateMotion &=
    SVG.Core.attrib,
    SVG.Conditional.attrib,
    SVG.AnimationEvents.attrib,
    SVG.External.attrib,
    SVG.Animation.attrib,
    SVG.AnimationTiming.attrib,
    SVG.AnimationAddtion.attrib,
    [ a:defaultValue = "paced" ]
    attribute calcMode { "discrete" | "linear" | "paced" | "spline" }?,
    attribute values { text }?,
    attribute keyTimes { text }?,
    attribute keySplines { text }?,
    attribute from { text }?,
    attribute to { text }?,
    attribute by { text }?,
    attribute path { text }?,
    attribute keyPoints { text }?,
    attribute rotate { text }?,
    attribute origin { text }?
  SVG.animateColor.extra.content = notAllowed
  SVG.animateColor.content =
    (SVG.Description.class | SVG.animateColor.extra.content)*
  animateColor =
    element animateColor {
      attlist.animateColor, SVG.animateColor.content
    }
  attlist.animateColor &=
    SVG.Core.attrib,
    SVG.Conditional.attrib,
    SVG.AnimationEvents.attrib,
    SVG.External.attrib,
    SVG.Animation.attrib,
    SVG.AnimationAttribute.attrib,
    SVG.AnimationTiming.attrib,
    SVG.AnimationValue.attrib,
    SVG.AnimationAddtion.attrib
  SVG.animateTransform.extra.content = notAllowed
  SVG.animateTransform.content =
    (SVG.Description.class | SVG.animateTransform.extra.content)*
  animateTransform =
    element animateTransform {
      attlist.animateTransform, SVG.animateTransform.content
    }
  attlist.animateTransform &=
    SVG.Core.attrib,
    SVG.Conditional.attrib,
    SVG.AnimationEvents.attrib,
    SVG.External.attrib,
    SVG.Animation.attrib,
    SVG.AnimationAttribute.attrib,
    SVG.AnimationTiming.attrib,
    SVG.AnimationValue.attrib,
    SVG.AnimationAddtion.attrib,
    [ a:defaultValue = "translate" ]
    attribute type {
      "translate" | "scale" | "rotate" | "skewX" | "skewY"
    }?
  SVG.mpath.extra.content = notAllowed
  SVG.mpath.content = (SVG.Description.class | SVG.mpath.extra.content)*
  mpath = element mpath { attlist.mpath, SVG.mpath.content }
  attlist.mpath &=
    SVG.Core.attrib, SVG.XLinkRequired.attrib, SVG.External.attrib
  SVG.font.extra.content = notAllowed
  SVG.font.content =
    SVG.Description.class*,
    font-face,
    missing-glyph,
    (glyph | hkern | vkern | SVG.font.extra.content)*
  font = element font { attlist.font, SVG.font.content }
  attlist.font &=
    SVG.Core.attrib,
    SVG.Style.attrib,
    SVG.Presentation.attrib,
    SVG.External.attrib,
    attribute horiz-origin-x { Number.datatype }?,
    attribute horiz-origin-y { Number.datatype }?,
    attribute horiz-adv-x { Number.datatype },
    attribute vert-origin-x { Number.datatype }?,
    attribute vert-origin-y { Number.datatype }?,
    attribute vert-adv-y { Number.datatype }?
  SVG.font-face.extra.content = empty
  SVG.font-face.content =
    SVG.Description.class*,
    font-face-src?,
    definition-src?,
    SVG.font-face.extra.content
  font-face =
    element font-face { attlist.font-face, SVG.font-face.content }
  attlist.font-face &=
    SVG.Core.attrib,
    attribute font-family { text }?,
    attribute font-style { text }?,
    attribute font-variant { text }?,
    attribute font-weight { text }?,
    attribute font-stretch { text }?,
    attribute font-size { text }?,
    attribute unicode-range { text }?,
    attribute units-per-em { Number.datatype }?,
    attribute panose-1 { text }?,
    attribute stemv { Number.datatype }?,
    attribute stemh { Number.datatype }?,
    attribute slope { Number.datatype }?,
    attribute cap-height { Number.datatype }?,
    attribute x-height { Number.datatype }?,
    attribute accent-height { Number.datatype }?,
    attribute ascent { Number.datatype }?,
    attribute descent { Number.datatype }?,
    attribute widths { text }?,
    attribute bbox { text }?,
    attribute ideographic { Number.datatype }?,
    attribute alphabetic { Number.datatype }?,
    attribute mathematical { Number.datatype }?,
    attribute hanging { Number.datatype }?,
    attribute v-ideographic { Number.datatype }?,
    attribute v-alphabetic { Number.datatype }?,
    attribute v-mathematical { Number.datatype }?,
    attribute v-hanging { Number.datatype }?,
    attribute underline-position { Number.datatype }?,
    attribute underline-thickness { Number.datatype }?,
    attribute strikethrough-position { Number.datatype }?,
    attribute strikethrough-thickness { Number.datatype }?,
    attribute overline-position { Number.datatype }?,
    attribute overline-thickness { Number.datatype }?
  SVG.glyph.extra.content = notAllowed
  SVG.glyph.content =
    (SVG.Description.class
     | SVG.Animation.class
     | SVG.Structure.class
     | SVG.Conditional.class
     | SVG.Image.class
     | SVG.Style.class
     | SVG.Shape.class
     | SVG.Text.class
     | SVG.Marker.class
     | SVG.ColorProfile.class
     | SVG.Gradient.class
     | SVG.Pattern.class
     | SVG.Clip.class
     | SVG.Mask.class
     | SVG.Filter.class
     | SVG.Cursor.class
     | SVG.Hyperlink.class
     | SVG.View.class
     | SVG.Script.class
     | SVG.Font.class
     | SVG.glyph.extra.content)*
  glyph = element glyph { attlist.glyph, SVG.glyph.content }
  attlist.glyph &=
    SVG.Core.attrib,
    SVG.Style.attrib,
    SVG.Presentation.attrib,
    attribute unicode { text }?,
    attribute glyph-name { text }?,
    attribute d { PathData.datatype }?,
    attribute orientation { text }?,
    attribute arabic-form { text }?,
    attribute lang { LanguageCodes.datatype }?,
    attribute horiz-adv-x { Number.datatype }?,
    attribute vert-origin-x { Number.datatype }?,
    attribute vert-origin-y { Number.datatype }?,
    attribute vert-adv-y { Number.datatype }?
  SVG.missing-glyph.extra.content = notAllowed
  SVG.missing-glyph.content =
    (SVG.Description.class
     | SVG.Animation.class
     | SVG.Structure.class
     | SVG.Conditional.class
     | SVG.Image.class
     | SVG.Style.class
     | SVG.Shape.class
     | SVG.Text.class
     | SVG.Marker.class
     | SVG.ColorProfile.class
     | SVG.Gradient.class
     | SVG.Pattern.class
     | SVG.Clip.class
     | SVG.Mask.class
     | SVG.Filter.class
     | SVG.Cursor.class
     | SVG.Hyperlink.class
     | SVG.View.class
     | SVG.Script.class
     | SVG.Font.class
     | SVG.missing-glyph.extra.content)*
  missing-glyph =
    element missing-glyph {
      attlist.missing-glyph, SVG.missing-glyph.content
    }
  attlist.missing-glyph &=
    SVG.Core.attrib,
    SVG.Style.attrib,
    SVG.Presentation.attrib,
    attribute d { PathData.datatype }?,
    attribute horiz-adv-x { Number.datatype }?,
    attribute vert-origin-x { Number.datatype }?,
    attribute vert-origin-y { Number.datatype }?,
    attribute vert-adv-y { Number.datatype }?
  SVG.hkern.content = empty
  hkern = element hkern { attlist.hkern, SVG.hkern.content }
  attlist.hkern &=
    SVG.Core.attrib,
    attribute u1 { text }?,
    attribute g1 { text }?,
    attribute u2 { text }?,
    attribute g2 { text }?,
    attribute k { Number.datatype }
  SVG.vkern.content = empty
  vkern = element vkern { attlist.vkern, SVG.vkern.content }
  attlist.vkern &=
    SVG.Core.attrib,
    attribute u1 { text }?,
    attribute g1 { text }?,
    attribute u2 { text }?,
    attribute g2 { text }?,
    attribute k { Number.datatype }
  SVG.font-face-src.extra.content = notAllowed
  SVG.font-face-src.content =
    (font-face-uri | font-face-name | SVG.font-face-src.extra.content)+
  font-face-src =
    element font-face-src {
      attlist.font-face-src, SVG.font-face-src.content
    }
  attlist.font-face-src &= SVG.Core.attrib
  SVG.font-face-uri.extra.content = notAllowed
  SVG.font-face-uri.content =
    (font-face-format | SVG.font-face-uri.extra.content)*
  font-face-uri =
    element font-face-uri {
      attlist.font-face-uri, SVG.font-face-uri.content
    }
  attlist.font-face-uri &= SVG.Core.attrib, SVG.XLinkRequired.attrib
  SVG.font-face-format.content = empty
  font-face-format =
    element font-face-format {
      attlist.font-face-format, SVG.font-face-format.content
    }
  attlist.font-face-format &=
    SVG.Core.attrib,
    attribute string { text }?
  SVG.font-face-name.content = empty
  font-face-name =
    element font-face-name {
      attlist.font-face-name, SVG.font-face-name.content
    }
  attlist.font-face-name &=
    SVG.Core.attrib,
    attribute name { text }?
  SVG.definition-src.content = empty
  definition-src =
    element definition-src {
      attlist.definition-src, SVG.definition-src.content
    }
  attlist.definition-src &= SVG.Core.attrib, SVG.XLinkRequired.attrib
  SVG.foreignObject.extra.content = notAllowed
  SVG.foreignObject.content = (text | SVG.foreignObject.extra.content)*
  foreignObject =
    element foreignObject {
      attlist.foreignObject, SVG.foreignObject.content
    }
  attlist.foreignObject &=
    SVG.Core.attrib,
    SVG.Conditional.attrib,
    SVG.Style.attrib,
    SVG.Presentation.attrib,
    SVG.GraphicalEvents.attrib,
    SVG.External.attrib,
    attribute x { Coordinate.datatype }?,
    attribute y { Coordinate.datatype }?,
    attribute width { Length.datatype },
    attribute height { Length.datatype },
    attribute transform { TransformList.datatype }?
  tei_model.graphicLike |= svg
}
tei_macro.paraContent =
  (text
   | tei_model.gLike
   | tei_model.phrase
   | tei_model.inter
   | tei_model.global)*
tei_macro.limitedContent =
  (text | tei_model.limitedPhrase | tei_model.inter)*
tei_macro.phraseSeq =
  (text | tei_model.gLike | tei_model.phrase | tei_model.global)*
tei_macro.phraseSeq.limited =
  (text | tei_model.limitedPhrase | tei_model.global)*
tei_macro.specialPara =
  (text
   | tei_model.gLike
   | tei_model.phrase
   | tei_model.inter
   | tei_model.divPart
   | tei_model.global)*
tei_macro.xtext = (text | tei_model.gLike)*
tei_data.certainty = "high" | "medium" | "low" | "unknown"
tei_data.numeric =
  xsd:double
  | xsd:token { pattern = "(\-?[\d]+/\-?[\d]+)" }
  | xsd:decimal
tei_data.count = xsd:nonNegativeInteger
tei_data.temporal.w3c =
  xsd:date
  | xsd:gYear
  | xsd:gMonth
  | xsd:gDay
  | xsd:gYearMonth
  | xsd:gMonthDay
  | xsd:time
  | xsd:dateTime
tei_data.truthValue = xsd:boolean
tei_data.xTruthValue = xsd:boolean | "unknown" | "inapplicable"
tei_data.language = xsd:language
tei_data.namespace = xsd:anyURI
tei_data.outputMeasurement =
  xsd:token {
    pattern =
      "[\-+]?\d+(\.\d+)?(%|cm|mm|in|pt|pc|px|em|ex|gd|rem|vw|vh|vm)"
  }
tei_data.pattern = xsd:token
tei_data.pointer = xsd:anyURI
tei_data.version = xsd:token { pattern = "[\d]+(\.[\d]+){0,2}" }
tei_data.key = xsd:string
tei_data.word = xsd:token { pattern = "(\p{L}|\p{N}|\p{P}|\p{S})+" }
tei_data.code = xsd:anyURI
tei_data.name = xsd:Name
tei_data.enumerated = tei_data.name
tei_macro.anyXML =
  element * - (ns1:* | ns2:egXML) {
    attribute * { text }*,
    (text | tei_macro.anyXML)*
  }
tei_att.ascribed.attributes = tei_att.ascribed.attribute.who
tei_att.ascribed.attribute.who =
  
  ## indicates the person, or group of people, to whom the element content is ascribed.
  attribute who {
    list { tei_data.pointer, tei_data.pointer* }
  }?
tei_att.canonical.attributes =
  tei_att.canonical.attribute.key, tei_att.canonical.attribute.ref
tei_att.canonical.attribute.key =
  
  ## provides an externally-defined means of identifying the entity (or entities) being
  ##         named, using a coded value of some kind.
  attribute key { tei_data.key }?
tei_att.canonical.attribute.ref =
  
  ## (reference) provides an explicit means of locating a full definition for the entity being named by
  ##         means of one or more URIs.
  attribute ref {
    list { tei_data.pointer, tei_data.pointer* }
  }?
tei_att.ranging.attributes =
  tei_att.ranging.attribute.atLeast,
  tei_att.ranging.attribute.atMost,
  tei_att.ranging.attribute.min,
  tei_att.ranging.attribute.max
tei_att.ranging.attribute.atLeast =
  
  ## gives a minimum estimated value for the approximate measurement.
  attribute atLeast { tei_data.numeric }?
tei_att.ranging.attribute.atMost =
  
  ## gives a maximum estimated value for the approximate measurement.
  attribute atMost { tei_data.numeric }?
tei_att.ranging.attribute.min =
  
  ## where the measurement summarizes more than one observation
  ##       or a range, supplies the minimum value
  ##         observed.
  attribute min { tei_data.numeric }?
tei_att.ranging.attribute.max =
  
  ## where the measurement summarizes more than one observation
  ##       or a range, supplies the maximum value
  ##       observed.
  attribute max { tei_data.numeric }?
tei_att.dimensions.attributes =
  tei_att.ranging.attributes,
  tei_att.dimensions.attribute.unit,
  tei_att.dimensions.attribute.quantity,
  tei_att.dimensions.attribute.extent,
  tei_att.dimensions.attribute.precision,
  tei_att.dimensions.attribute.scope
tei_att.dimensions.attribute.unit =
  
  ## names the unit used for the measurement
  ## Suggested values include: 1] cm(centimetres) ; 2] mm(millimetres) ; 3] in(inches) ; 4] lines; 5] chars(characters) 
  attribute unit {
    
    ## (centimetres) 
    "cm"
    | 
      ## (millimetres) 
      "mm"
    | 
      ## (inches) 
      "in"
    | 
      ## lines of text
      "lines"
    | 
      ## (characters) characters of text
      "chars"
    | xsd:Name
  }?
tei_att.dimensions.attribute.quantity =
  
  ## specifies the length in the units specified
  attribute quantity { tei_data.numeric }?
tei_att.dimensions.attribute.extent =
  
  ## indicates the size of the object concerned using a project-specific vocabulary combining
  ##         quantity and units in a single string of words. 
  attribute extent {
    list { tei_data.word, tei_data.word* }
  }?
tei_att.dimensions.attribute.precision =
  
  ## characterizes the precision of the values specified by the other attributes.
  attribute precision { tei_data.certainty }?
tei_att.dimensions.attribute.scope =
  
  ## where the measurement summarizes more than one observation, specifies the applicability
  ##         of this measurement.
  ## Sample values include: 1] all; 2] most; 3] range
  attribute scope { tei_data.enumerated }?
tei_att.breaking.attributes = tei_att.breaking.attribute.break
tei_att.breaking.attribute.break =
  
  ## indicates whether or not the  element
  ##	bearing this attribute should be considered to mark the end of
  ##	an orthographic token in the same way as whitespace.
  attribute break { tei_data.enumerated }?
tei_att.datable.w3c.attributes =
  tei_att.datable.w3c.attribute.period,
  tei_att.datable.w3c.attribute.when,
  tei_att.datable.w3c.attribute.notBefore,
  tei_att.datable.w3c.attribute.notAfter,
  tei_att.datable.w3c.attribute.from,
  tei_att.datable.w3c.attribute.to
tei_att.datable.w3c.attribute.period =
  
  ## supplies a pointer to some location defining a named
  ##       period of time within which the datable item is understood to
  ##       have occurred.
  attribute period { tei_data.pointer }?
tei_att.datable.w3c.attribute.when =
  
  ## supplies the value of the date or time in a standard form,
  ##       e.g. yyyy-mm-dd.
  attribute when { tei_data.temporal.w3c }?
tei_att.datable.w3c.attribute.notBefore =
  
  ## specifies the earliest possible date for the event in
  ##	  standard form, e.g. yyyy-mm-dd.
  attribute notBefore { tei_data.temporal.w3c }?
tei_att.datable.w3c.attribute.notAfter =
  
  ## specifies the latest possible date for the event in
  ##	  standard form, e.g. yyyy-mm-dd.
  attribute notAfter { tei_data.temporal.w3c }?
tei_att.datable.w3c.attribute.from =
  
  ## indicates the starting point of the period in standard form, e.g. yyyy-mm-dd.
  attribute from { tei_data.temporal.w3c }?
tei_att.datable.w3c.attribute.to =
  
  ## indicates the ending point of the period in standard
  ##	  form, e.g. yyyy-mm-dd.
  attribute to { tei_data.temporal.w3c }?
tei_att.datable.attributes = tei_att.datable.w3c.attributes
tei_att.declarable.attributes = tei_att.declarable.attribute.default
tei_att.declarable.attribute.default =
  
  ## indicates whether or not this element is selected by default when
  ## its parent is selected.
  [ a:defaultValue = "false" ]
  attribute default {
    
    ## This element is selected if its parent is selected
    "true"
    | 
      ## This element can only be selected explicitly, unless it is the
      ## only one of its kind, in which case it is selected if its parent is selected.
      "false"
  }?
tei_att.declaring.attributes = tei_att.declaring.attribute.decls
tei_att.declaring.attribute.decls =
  
  ## identifies one or more declarable elements within the
  ## header, which are understood to apply to the element bearing this
  ## attribute and its content.
  attribute decls {
    list { tei_data.pointer, tei_data.pointer* }
  }?
tei_att.divLike.attributes =
  tei_att.divLike.attribute.org,
  tei_att.divLike.attribute.sample,
  tei_att.divLike.attribute.part
tei_att.divLike.attribute.org =
  
  ## (organization) specifies how the content of the division is organized.
  [ a:defaultValue = "uniform" ]
  attribute org {
    
    ## composite content: i.e. no claim is made about the
    ##		  sequence in which the immediate contents of this division
    ##		  are to be processed, or their inter-relationships.
    "composite"
    | 
      ## uniform content: i.e. the immediate contents of this
      ##		  element are regarded as forming a logical unit, to be
      ##		  processed in sequence.
      "uniform"
  }?
tei_att.divLike.attribute.sample =
  
  ## indicates whether this division is a sample of the
  ##		original source and if so, from which part.
  [ a:defaultValue = "complete" ]
  attribute sample {
    
    ## division lacks material present at end in source.
    "initial"
    | 
      ## division lacks material at start and end.
      "medial"
    | 
      ## division lacks material at start.
      "final"
    | 
      ## position of sampled material within original unknown.
      "unknown"
    | 
      ## division is not a sample.
      "complete"
  }?
tei_att.divLike.attribute.part =
  
  ## specifies whether or not the division is fragmented by
  ##		some other structural element, for example a speech which is
  ##		divided between two or more verse stanzas.
  [ a:defaultValue = "N" ]
  attribute part {
    
    ## (yes) the division is incomplete in some respect
    "Y"
    | 
      ## (no) either the division is complete, or no claim is made as to its completeness.
      "N"
    | 
      ## (initial) the initial part of an incomplete division
      "I"
    | 
      ## (medial) a medial part of an incomplete division
      "M"
    | 
      ## (final) the final part of an incomplete division
      "F"
  }?
tei_att.docStatus.attributes = tei_att.docStatus.attribute.status
tei_att.docStatus.attribute.status =
  
  ## describes the status of a document either currently or, when
  ## associated with a dated element, at the time indicated.
  ## Sample values include: 1] approved; 2] candidate; 3] cleared; 4] deprecated; 5] draft; 6] embargoed; 7] expired; 8] frozen; 9] galley; 10] proposed; 11] published; 12] recommendation; 13] submitted; 14] unfinished; 15] withdrawn
  [ a:defaultValue = "draft" ] attribute status { tei_data.enumerated }?
tei_att.responsibility.attributes =
  tei_att.responsibility.attribute.cert,
  tei_att.responsibility.attribute.resp
tei_att.responsibility.attribute.cert =
  
  ## (certainty) signifies the degree of certainty associated with the intervention or interpretation.
  attribute cert { tei_data.certainty }?
tei_att.responsibility.attribute.resp =
  
  ## (responsible party) indicates the agency responsible for the intervention or interpretation, for example an
  ##         editor or transcriber.
  attribute resp {
    list { tei_data.pointer, tei_data.pointer* }
  }?
tei_att.editLike.attributes =
  tei_att.dimensions.attributes,
  tei_att.responsibility.attributes,
  tei_att.editLike.attribute.evidence,
  tei_att.editLike.attribute.source
tei_att.editLike.attribute.evidence =
  
  ## indicates the nature of the evidence supporting the reliability or accuracy of the
  ##         intervention or interpretation.
  ## Suggested values include: 1] internal; 2] external; 3] conjecture
  attribute evidence {
    list {
      (
       ## there is internal evidence to support the intervention.
       "internal"
       | 
         ## there is external evidence to support the intervention.
         "external"
       | 
         ## the intervention or interpretation has been made by the editor, cataloguer, or
         ##             scholar on the basis of their expertise.
         "conjecture"
       | xsd:Name),
      (
       ## there is internal evidence to support the intervention.
       "internal"
       | 
         ## there is external evidence to support the intervention.
         "external"
       | 
         ## the intervention or interpretation has been made by the editor, cataloguer, or
         ##             scholar on the basis of their expertise.
         "conjecture"
       | xsd:Name)*
    }
  }?
tei_att.editLike.attribute.source =
  
  ## contains a list of one or more pointers indicating sources
  ##       supporting the given  intervention or interpretation.
  attribute source {
    list { tei_data.pointer, tei_data.pointer* }
  }?
tei_att.global.attributes =
  tei_att.global.attribute.xmlid,
  tei_att.global.attribute.n,
  tei_att.global.attribute.xmllang,
  tei_att.global.attribute.rend,
  tei_att.global.attribute.rendition,
  tei_att.global.attribute.xmlbase,
  tei_att.global.attribute.xmlspace
tei_att.global.attribute.xmlid =
  
  ## (identifier) provides a unique identifier for the element bearing the attribute.
  attribute xml:id { xsd:ID }?
tei_att.global.attribute.n =
  
  ## (number) gives a number (or other label) for an element, which is not necessarily unique within
  ##         the document.
  attribute n {
    list { tei_data.word, tei_data.word* }
  }?
tei_att.global.attribute.xmllang =
  
  ## (language) indicates the language of the element content using a tag generated
  ##         according to BCP 47
  ##          
  attribute xml:lang { tei_data.language }?
tei_att.global.attribute.rend =
  
  ## (rendition) indicates how the element in question was rendered or presented in the source text.
  attribute rend {
    list { tei_data.word, tei_data.word* }
  }?
tei_att.global.attribute.rendition =
  
  ## points to a description of the rendering or presentation used for this element in the
  ##         source text.
  attribute rendition {
    list { tei_data.pointer, tei_data.pointer* }
  }?
tei_att.global.attribute.xmlbase =
  
  ## provides a base URI reference with which applications can resolve relative URI
  ##         references into absolute URI references.
  attribute xml:base { tei_data.pointer }?
tei_att.global.attribute.xmlspace =
  
  ## signals an intention about how white space should be 
  ##       managed by  applications. 
  attribute xml:space {
    
    ## the processor should treat white space according to the
    ##	default XML white space handling rules
    "default"
    | 
      ## the processor should preserve unchanged any and all
      ##	white space in the source
      "preserve"
  }?
tei_att.handFeatures.attributes =
  tei_att.handFeatures.attribute.scribe,
  tei_att.handFeatures.attribute.scribeRef,
  tei_att.handFeatures.attribute.script,
  tei_att.handFeatures.attribute.scriptRef,
  tei_att.handFeatures.attribute.medium,
  tei_att.handFeatures.attribute.scope
tei_att.handFeatures.attribute.scribe =
  
  ## gives a name or other identifier for the scribe
  ## believed to be responsible for this hand.
  attribute scribe { tei_data.name }?
tei_att.handFeatures.attribute.scribeRef =
  
  ## points to a full description of the scribe concerned, typically supplied by a person element
  ##       elsewhere in the description.
  attribute scribeRef {
    list { tei_data.pointer, tei_data.pointer* }
  }?
tei_att.handFeatures.attribute.script =
  
  ## characterizes the particular script or writing style used by
  ## this hand, for example secretary, copperplate, Chancery, Italian, etc.
  attribute script {
    list { tei_data.name, tei_data.name* }
  }?
tei_att.handFeatures.attribute.scriptRef =
  
  ## points to a full description of the script or writing style used by
  ## this hand, typically supplied by a scriptNote element
  ##       elsewhere in the description.
  attribute scriptRef {
    list { tei_data.pointer, tei_data.pointer* }
  }?
tei_att.handFeatures.attribute.medium =
  
  ## describes the tint or type of ink, e.g. brown, or other
  ## writing medium, e.g. pencil
  attribute medium { tei_data.enumerated }?
tei_att.handFeatures.attribute.scope =
  
  ## specifies how widely this  hand is used in the manuscript.
  attribute scope {
    
    ## only this hand is used throughout the manuscript
    "sole"
    | 
      ## this hand is used through most of the manuscript
      "major"
    | 
      ## this hand is used occasionally in the manuscript
      "minor"
  }?
tei_att.internetMedia.attributes =
  tei_att.internetMedia.attribute.mimeType
tei_att.internetMedia.attribute.mimeType =
  
  ## (MIME media type) specifies the applicable multimedia internet mail extension (MIME) media type
  attribute mimeType { tei_data.word }?
tei_att.measurement.attributes =
  tei_att.measurement.attribute.unit,
  tei_att.measurement.attribute.quantity,
  tei_att.measurement.attribute.commodity
tei_att.measurement.attribute.unit =
  
  ## indicates the units used for the measurement, usually
  ##       using the standard symbol for the desired units.
  ## Suggested values include: 1] m(metre) ; 2] kg(kilogram) ; 3] s(second) ; 4] Hz(hertz) ; 5] Pa(pascal) ; 6] (ohm) ; 7] L(litre) ; 8] t(tonne) ; 9] ha(hectare) ; 10] (ngstrm) ; 11] mL(millilitre) ; 12] cm(centimetre) ; 13] dB(decibel) ; 14] kbit(kilobit) ; 15] Kibit(kibibit) ; 16] kB(kilobyte) ; 17] KiB(kibibyte) ; 18] MB(megabyte) ; 19] MiB(mebibyte) 
  attribute unit {
    
    ## (metre) SI base unit of length
    "m"
    | 
      ## (kilogram) SI base unit of mass
      "kg"
    | 
      ## (second) SI base unit of time
      "s"
    | 
      ## (hertz) SI unit of frequency
      "Hz"
    | 
      ## (pascal) SI unit of pressure or stress
      "Pa"
    | 
      ## (ohm) SI unit of electric resistance
      ""
    | 
      ## (litre) 1 dm
      "L"
    | 
      ## (tonne) 10 kg
      "t"
    | 
      ## (hectare) 1 hm
      "ha"
    | 
      ## (ngstrm) 10 m
      ""
    | 
      ## (millilitre) 
      "mL"
    | 
      ## (centimetre) 
      "cm"
    | 
      ## (decibel) see remarks, below
      "dB"
    | 
      ## (kilobit) 10 or 1000 bits
      "kbit"
    | 
      ## (kibibit) 2 or 1024 bits
      "Kibit"
    | 
      ## (kilobyte) 10 or 1000 bytes
      "kB"
    | 
      ## (kibibyte) 2 or 1024 bytes
      "KiB"
    | 
      ## (megabyte) 10 or 1000000 bytes
      "MB"
    | 
      ## (mebibyte) 2 or 1048576 bytes
      "MiB"
    | xsd:Name
  }?
tei_att.measurement.attribute.quantity =
  
  ## specifies the number of the specified units that
  ##       comprise the measurement
  attribute quantity { tei_data.numeric }?
tei_att.measurement.attribute.commodity =
  
  ## indicates the substance that is being measured
  attribute commodity {
    list { tei_data.word, tei_data.word* }
  }?
tei_att.naming.attributes =
  tei_att.canonical.attributes,
  tei_att.naming.attribute.role,
  tei_att.naming.attribute.nymRef
tei_att.naming.attribute.role =
  
  ## may be used to specify further information about the entity referenced by
  ## this name, for example the occupation of a person, or the status of a place. 
  attribute role { tei_data.enumerated }?
tei_att.naming.attribute.nymRef =
  
  ## (reference to the canonical name) provides a means of locating the canonical form
  ##       (nym) of the names associated with the object
  ##        named by
  ##       the element bearing it.
  attribute nymRef {
    list { tei_data.pointer, tei_data.pointer* }
  }?
tei_att.placement.attributes = tei_att.placement.attribute.place
tei_att.placement.attribute.place =
  
  ## 
  ## Suggested values include: 1] below; 2] bottom; 3] margin; 4] top; 5] opposite; 6] overleaf; 7] above; 8] end; 9] inline; 10] inspace
  attribute place {
    list {
      (
       ## below the line
       "below"
       | 
         ## at the foot of the page
         "bottom"
       | 
         ## in the margin (left, right, or both)
         "margin"
       | 
         ## at the top of the page
         "top"
       | 
         ## on the opposite, i.e. facing, page
         "opposite"
       | 
         ## on the other side of the leaf
         "overleaf"
       | 
         ## above the line
         "above"
       | 
         ## at the end of e.g. chapter or volume.
         "end"
       | 
         ## within the body of the text.
         "inline"
       | 
         ##  in a predefined space, for example left by an earlier scribe.
         "inspace"
       | xsd:Name),
      (
       ## below the line
       "below"
       | 
         ## at the foot of the page
         "bottom"
       | 
         ## in the margin (left, right, or both)
         "margin"
       | 
         ## at the top of the page
         "top"
       | 
         ## on the opposite, i.e. facing, page
         "opposite"
       | 
         ## on the other side of the leaf
         "overleaf"
       | 
         ## above the line
         "above"
       | 
         ## at the end of e.g. chapter or volume.
         "end"
       | 
         ## within the body of the text.
         "inline"
       | 
         ##  in a predefined space, for example left by an earlier scribe.
         "inspace"
       | xsd:Name)*
    }
  }?
tei_att.typed.attributes =
  tei_att.typed.attribute.type, tei_att.typed.attribute.subtype
tei_att.typed.attribute.type =
  
  ## characterizes the element in some sense, using any convenient
  ##  classification scheme or typology.
  attribute type { tei_data.enumerated }?
tei_att.typed.attribute.subtype =
  
  ## provides a sub-categorization of the element, if needed
  attribute subtype { tei_data.enumerated }?
tei_att.pointing.attributes =
  tei_att.pointing.attribute.target, tei_att.pointing.attribute.evaluate
tei_att.pointing.attribute.target =
  
  ## specifies the destination of the reference by supplying one or more URI References
  attribute target {
    list { tei_data.pointer, tei_data.pointer* }
  }?
tei_att.pointing.attribute.evaluate =
  
  ## specifies the intended meaning when the target of a
  ##       pointer is itself a pointer.
  attribute evaluate {
    
    ## if the element pointed to is itself a pointer, then
    ##	  the target of that pointer will be taken, and so on, until
    ##	  an element is found which is not a pointer.
    "all"
    | 
      ## if the element pointed to is itself a pointer, then
      ##	  its target (whether a pointer or not) is taken as the target
      ##	  of this pointer.
      "one"
    | 
      ## no further evaluation of targets is carried out
      ##	  beyond that needed to find the element specified in the
      ##	  pointer's target.
      "none"
  }?
tei_att.sourced.attributes = tei_att.sourced.attribute.ed
tei_att.sourced.attribute.ed =
  
  ## (edition) supplies an arbitrary identifier for the source edition in which
  ##       the associated feature (for example, a  page, column, or line
  ##       break) occurs at this point in the text.
  attribute ed {
    list { tei_data.code, tei_data.code* }
  }?
tei_att.spanning.attributes = tei_att.spanning.attribute.spanTo
tei_att.spanning.attribute.spanTo =
  
  ## indicates the end of a span initiated by the element
  ##	bearing this attribute.
  attribute spanTo { tei_data.pointer }?
tei_att.tableDecoration.attributes =
  tei_att.tableDecoration.attribute.role,
  tei_att.tableDecoration.attribute.rows,
  tei_att.tableDecoration.attribute.cols
tei_att.tableDecoration.attribute.role =
  
  ## indicates the kind of information held in this cell or
  ## in each cell of this row.
  ## Suggested values include: 1] label; 2] data
  [ a:defaultValue = "data" ]
  attribute role {
    
    ## labelling or descriptive information only.
    "label"
    | 
      ## data values.
      "data"
    | xsd:Name
  }?
tei_att.tableDecoration.attribute.rows =
  
  ## indicates the number of rows occupied by this cell or row.
  [ a:defaultValue = "1" ] attribute rows { tei_data.count }?
tei_att.tableDecoration.attribute.cols =
  
  ## (columns) indicates the number of columns occupied by this cell or
  ##	row.
  [ a:defaultValue = "1" ] attribute cols { tei_data.count }?
tei_att.transcriptional.attributes =
  tei_att.editLike.attributes,
  tei_att.transcriptional.attribute.hand,
  tei_att.transcriptional.attribute.status,
  tei_att.transcriptional.attribute.seq
tei_att.transcriptional.attribute.hand =
  
  ## signifies the hand of the agent which made the intervention.
  attribute hand { tei_data.pointer }?
tei_att.transcriptional.attribute.status =
  
  ## indicates the effect of the intervention, for example in
  ##       the case of a deletion, strikeouts
  ##       which include too much or too little text, or in the case of an
  ##       addition, an insertion which duplicates some of the text
  ##       already present.
  ## Sample values include: 1] duplicate; 2] duplicate-partial; 3] excessStart; 4] excessEnd; 5] shortStart; 6] shortEnd; 7] partial; 8] unremarkable
  [ a:defaultValue = "unremarkable" ]
  attribute status { tei_data.enumerated }?
tei_att.transcriptional.attribute.seq =
  
  ## (sequence) assigns a sequence number related to the order in which
  ##       the encoded features carrying this attribute are believed to have occurred.
  attribute seq { tei_data.count }?
tei_att.translatable.attributes = tei_att.translatable.attribute.version
tei_att.translatable.attribute.version =
  
  ## specifies the version name or number of the source from
  ##	which the translated version was derived
  attribute version { tei_data.word }?
tei_model.nameLike.agent = tei_name
tei_model.nameLike.agent_alternation = tei_name
tei_model.nameLike.agent_sequence = tei_name
tei_model.nameLike.agent_sequenceOptional = tei_name?
tei_model.nameLike.agent_sequenceOptionalRepeatable = tei_name*
tei_model.nameLike.agent_sequenceRepeatable = tei_name+
tei_model.segLike = notAllowed
tei_model.segLike_alternation = notAllowed
tei_model.segLike_sequence = empty
tei_model.segLike_sequenceOptional = empty
tei_model.segLike_sequenceOptionalRepeatable = empty
tei_model.segLike_sequenceRepeatable = notAllowed
tei_model.hiLike = tei_hi
tei_model.hiLike_alternation = tei_hi
tei_model.hiLike_sequence = tei_hi
tei_model.hiLike_sequenceOptional = tei_hi?
tei_model.hiLike_sequenceOptionalRepeatable = tei_hi*
tei_model.hiLike_sequenceRepeatable = tei_hi+
tei_model.emphLike =
  tei_foreign
  | tei_emph
  | tei_distinct
  | tei_mentioned
  | tei_soCalled
  | tei_gloss
  | tei_term
  | tei_title
tei_model.emphLike_alternation =
  tei_foreign
  | tei_emph
  | tei_distinct
  | tei_mentioned
  | tei_soCalled
  | tei_gloss
  | tei_term
  | tei_title
tei_model.emphLike_sequence =
  tei_foreign,
  tei_emph,
  tei_distinct,
  tei_mentioned,
  tei_soCalled,
  tei_gloss,
  tei_term,
  tei_title
tei_model.emphLike_sequenceOptional =
  tei_foreign?,
  tei_emph?,
  tei_distinct?,
  tei_mentioned?,
  tei_soCalled?,
  tei_gloss?,
  tei_term?,
  tei_title?
tei_model.emphLike_sequenceOptionalRepeatable =
  tei_foreign*,
  tei_emph*,
  tei_distinct*,
  tei_mentioned*,
  tei_soCalled*,
  tei_gloss*,
  tei_term*,
  tei_title*
tei_model.emphLike_sequenceRepeatable =
  tei_foreign+,
  tei_emph+,
  tei_distinct+,
  tei_mentioned+,
  tei_soCalled+,
  tei_gloss+,
  tei_term+,
  tei_title+
tei_model.highlighted = tei_model.hiLike | tei_model.emphLike
tei_model.highlighted_alternation =
  tei_model.hiLike_alternation | tei_model.emphLike_alternation
tei_model.highlighted_sequence =
  tei_model.hiLike_sequence, tei_model.emphLike_sequence
tei_model.highlighted_sequenceOptional =
  tei_model.hiLike_sequenceOptional?,
  tei_model.emphLike_sequenceOptional?
tei_model.highlighted_sequenceOptionalRepeatable =
  tei_model.hiLike_sequenceOptionalRepeatable*,
  tei_model.emphLike_sequenceOptionalRepeatable*
tei_model.highlighted_sequenceRepeatable =
  tei_model.hiLike_sequenceRepeatable+,
  tei_model.emphLike_sequenceRepeatable+
tei_model.dateLike = tei_date | tei_time
tei_model.dateLike_alternation = tei_date | tei_time
tei_model.dateLike_sequence = tei_date, tei_time
tei_model.dateLike_sequenceOptional = tei_date?, tei_time?
tei_model.dateLike_sequenceOptionalRepeatable = tei_date*, tei_time*
tei_model.dateLike_sequenceRepeatable = tei_date+, tei_time+
tei_model.measureLike = tei_num | tei_measure | tei_measureGrp
tei_model.measureLike_alternation =
  tei_num | tei_measure | tei_measureGrp
tei_model.measureLike_sequence = tei_num, tei_measure, tei_measureGrp
tei_model.measureLike_sequenceOptional =
  tei_num?, tei_measure?, tei_measureGrp?
tei_model.measureLike_sequenceOptionalRepeatable =
  tei_num*, tei_measure*, tei_measureGrp*
tei_model.measureLike_sequenceRepeatable =
  tei_num+, tei_measure+, tei_measureGrp+
tei_model.egLike = notAllowed
tei_model.egLike_alternation = notAllowed
tei_model.egLike_sequence = empty
tei_model.egLike_sequenceOptional = empty
tei_model.egLike_sequenceOptionalRepeatable = empty
tei_model.egLike_sequenceRepeatable = notAllowed
tei_model.graphicLike = tei_graphic | tei_binaryObject | tei_formula
tei_model.graphicLike_alternation =
  tei_graphic | tei_binaryObject | tei_formula
tei_model.graphicLike_sequence =
  tei_graphic, tei_binaryObject, tei_formula
tei_model.graphicLike_sequenceOptional =
  tei_graphic?, tei_binaryObject?, tei_formula?
tei_model.graphicLike_sequenceOptionalRepeatable =
  tei_graphic*, tei_binaryObject*, tei_formula*
tei_model.graphicLike_sequenceRepeatable =
  tei_graphic+, tei_binaryObject+, tei_formula+
tei_model.pPart.editorial = tei_choice | tei_abbr | tei_expan
tei_model.pPart.editorial_alternation =
  tei_choice | tei_abbr | tei_expan
tei_model.pPart.editorial_sequence = tei_choice, tei_abbr, tei_expan
tei_model.pPart.editorial_sequenceOptional =
  tei_choice?, tei_abbr?, tei_expan?
tei_model.pPart.editorial_sequenceOptionalRepeatable =
  tei_choice*, tei_abbr*, tei_expan*
tei_model.pPart.editorial_sequenceRepeatable =
  tei_choice+, tei_abbr+, tei_expan+
tei_model.pPart.transcriptional =
  tei_sic
  | tei_corr
  | tei_reg
  | tei_orig
  | tei_add
  | tei_del
  | tei_unclear
tei_model.pPart.transcriptional_alternation =
  tei_sic
  | tei_corr
  | tei_reg
  | tei_orig
  | tei_add
  | tei_del
  | tei_unclear
tei_model.pPart.transcriptional_sequence =
  tei_sic, tei_corr, tei_reg, tei_orig, tei_add, tei_del, tei_unclear
tei_model.pPart.transcriptional_sequenceOptional =
  tei_sic?,
  tei_corr?,
  tei_reg?,
  tei_orig?,
  tei_add?,
  tei_del?,
  tei_unclear?
tei_model.pPart.transcriptional_sequenceOptionalRepeatable =
  tei_sic*,
  tei_corr*,
  tei_reg*,
  tei_orig*,
  tei_add*,
  tei_del*,
  tei_unclear*
tei_model.pPart.transcriptional_sequenceRepeatable =
  tei_sic+,
  tei_corr+,
  tei_reg+,
  tei_orig+,
  tei_add+,
  tei_del+,
  tei_unclear+
tei_model.pPart.edit =
  tei_model.pPart.editorial | tei_model.pPart.transcriptional
tei_model.pPart.edit_alternation =
  tei_model.pPart.editorial_alternation
  | tei_model.pPart.transcriptional_alternation
tei_model.pPart.edit_sequence =
  tei_model.pPart.editorial_sequence,
  tei_model.pPart.transcriptional_sequence
tei_model.pPart.edit_sequenceOptional =
  tei_model.pPart.editorial_sequenceOptional?,
  tei_model.pPart.transcriptional_sequenceOptional?
tei_model.pPart.edit_sequenceOptionalRepeatable =
  tei_model.pPart.editorial_sequenceOptionalRepeatable*,
  tei_model.pPart.transcriptional_sequenceOptionalRepeatable*
tei_model.pPart.edit_sequenceRepeatable =
  tei_model.pPart.editorial_sequenceRepeatable+,
  tei_model.pPart.transcriptional_sequenceRepeatable+
tei_model.ptrLike = tei_ptr | tei_ref
tei_model.ptrLike_alternation = tei_ptr | tei_ref
tei_model.ptrLike_sequence = tei_ptr, tei_ref
tei_model.ptrLike_sequenceOptional = tei_ptr?, tei_ref?
tei_model.ptrLike_sequenceOptionalRepeatable = tei_ptr*, tei_ref*
tei_model.ptrLike_sequenceRepeatable = tei_ptr+, tei_ref+
tei_model.global.meta = tei_index
tei_model.global.meta_alternation = tei_index
tei_model.global.meta_sequence = tei_index
tei_model.global.meta_sequenceOptional = tei_index?
tei_model.global.meta_sequenceOptionalRepeatable = tei_index*
tei_model.global.meta_sequenceRepeatable = tei_index+
tei_model.milestoneLike = tei_milestone | tei_pb | tei_lb | tei_cb
tei_model.milestoneLike_alternation =
  tei_milestone | tei_pb | tei_lb | tei_cb
tei_model.milestoneLike_sequence = tei_milestone, tei_pb, tei_lb, tei_cb
tei_model.milestoneLike_sequenceOptional =
  tei_milestone?, tei_pb?, tei_lb?, tei_cb?
tei_model.milestoneLike_sequenceOptionalRepeatable =
  tei_milestone*, tei_pb*, tei_lb*, tei_cb*
tei_model.milestoneLike_sequenceRepeatable =
  tei_milestone+, tei_pb+, tei_lb+, tei_cb+
tei_model.gLike = notAllowed
tei_model.biblLike = tei_bibl | tei_biblStruct | tei_biblFull
tei_model.biblLike_alternation =
  tei_bibl | tei_biblStruct | tei_biblFull
tei_model.biblLike_sequence = tei_bibl, tei_biblStruct, tei_biblFull
tei_model.biblLike_sequenceOptional =
  tei_bibl?, tei_biblStruct?, tei_biblFull?
tei_model.biblLike_sequenceOptionalRepeatable =
  tei_bibl*, tei_biblStruct*, tei_biblFull*
tei_model.biblLike_sequenceRepeatable =
  tei_bibl+, tei_biblStruct+, tei_biblFull+
tei_model.headLike = tei_head
tei_model.headLike_alternation = tei_head
tei_model.headLike_sequence = tei_head
tei_model.headLike_sequenceOptional = tei_head?
tei_model.headLike_sequenceOptionalRepeatable = tei_head*
tei_model.headLike_sequenceRepeatable = tei_head+
tei_model.labelLike = tei_desc | tei_label
tei_model.labelLike_alternation = tei_desc | tei_label
tei_model.labelLike_sequence = tei_desc, tei_label
tei_model.labelLike_sequenceOptional = tei_desc?, tei_label?
tei_model.labelLike_sequenceOptionalRepeatable = tei_desc*, tei_label*
tei_model.labelLike_sequenceRepeatable = tei_desc+, tei_label+
tei_model.listLike = tei_list | tei_listBibl
tei_model.listLike_alternation = tei_list | tei_listBibl
tei_model.listLike_sequence = tei_list, tei_listBibl
tei_model.listLike_sequenceOptional = tei_list?, tei_listBibl?
tei_model.listLike_sequenceOptionalRepeatable = tei_list*, tei_listBibl*
tei_model.listLike_sequenceRepeatable = tei_list+, tei_listBibl+
tei_model.noteLike = tei_note
tei_model.noteLike_alternation = tei_note
tei_model.noteLike_sequence = tei_note
tei_model.noteLike_sequenceOptional = tei_note?
tei_model.noteLike_sequenceOptionalRepeatable = tei_note*
tei_model.noteLike_sequenceRepeatable = tei_note+
tei_model.lLike = tei_l
tei_model.lLike_alternation = tei_l
tei_model.lLike_sequence = tei_l
tei_model.lLike_sequenceOptional = tei_l?
tei_model.lLike_sequenceOptionalRepeatable = tei_l*
tei_model.lLike_sequenceRepeatable = tei_l+
tei_model.pLike = tei_p
tei_model.pLike_alternation = tei_p
tei_model.pLike_sequence = tei_p
tei_model.pLike_sequenceOptional = tei_p?
tei_model.pLike_sequenceOptionalRepeatable = tei_p*
tei_model.pLike_sequenceRepeatable = tei_p+
tei_model.stageLike = tei_stage
tei_model.stageLike_alternation = tei_stage
tei_model.stageLike_sequence = tei_stage
tei_model.stageLike_sequenceOptional = tei_stage?
tei_model.stageLike_sequenceOptionalRepeatable = tei_stage*
tei_model.stageLike_sequenceRepeatable = tei_stage+
tei_model.entryPart = notAllowed
tei_model.global.edit = tei_gap
tei_model.global.edit_alternation = tei_gap
tei_model.global.edit_sequence = tei_gap
tei_model.global.edit_sequenceOptional = tei_gap?
tei_model.global.edit_sequenceOptionalRepeatable = tei_gap*
tei_model.global.edit_sequenceRepeatable = tei_gap+
tei_model.divPart =
  tei_model.lLike | tei_model.pLike | tei_lg | tei_sp | tei_floatingText
tei_model.divPart_alternation =
  tei_model.lLike_alternation
  | tei_model.pLike_alternation
  | tei_lg
  | tei_sp
  | tei_floatingText
tei_model.divPart_sequence =
  tei_model.lLike_sequence,
  tei_model.pLike_sequence,
  tei_lg,
  tei_sp,
  tei_floatingText
tei_model.divPart_sequenceOptional =
  tei_model.lLike_sequenceOptional?,
  tei_model.pLike_sequenceOptional?,
  tei_lg?,
  tei_sp?,
  tei_floatingText?
tei_model.divPart_sequenceOptionalRepeatable =
  tei_model.lLike_sequenceOptionalRepeatable*,
  tei_model.pLike_sequenceOptionalRepeatable*,
  tei_lg*,
  tei_sp*,
  tei_floatingText*
tei_model.divPart_sequenceRepeatable =
  tei_model.lLike_sequenceRepeatable+,
  tei_model.pLike_sequenceRepeatable+,
  tei_lg+,
  tei_sp+,
  tei_floatingText+
tei_model.publicationStmtPart =
  tei_address
  | tei_date
  | tei_publisher
  | tei_pubPlace
  | tei_distributor
  | tei_authority
  | tei_idno
  | tei_availability
tei_model.glossLike = tei_desc | tei_gloss
tei_model.quoteLike = tei_quote | tei_cit
tei_model.quoteLike_alternation = tei_quote | tei_cit
tei_model.quoteLike_sequence = tei_quote, tei_cit
tei_model.quoteLike_sequenceOptional = tei_quote?, tei_cit?
tei_model.quoteLike_sequenceOptionalRepeatable = tei_quote*, tei_cit*
tei_model.quoteLike_sequenceRepeatable = tei_quote+, tei_cit+
tei_model.qLike = tei_model.quoteLike | tei_said | tei_q
tei_model.qLike_alternation =
  tei_model.quoteLike_alternation | tei_said | tei_q
tei_model.qLike_sequence = tei_model.quoteLike_sequence, tei_said, tei_q
tei_model.qLike_sequenceOptional =
  tei_model.quoteLike_sequenceOptional?, tei_said?, tei_q?
tei_model.qLike_sequenceOptionalRepeatable =
  tei_model.quoteLike_sequenceOptionalRepeatable*, tei_said*, tei_q*
tei_model.qLike_sequenceRepeatable =
  tei_model.quoteLike_sequenceRepeatable+, tei_said+, tei_q+
tei_model.respLike =
  tei_author
  | tei_editor
  | tei_respStmt
  | tei_meeting
  | tei_sponsor
  | tei_funder
  | tei_principal
tei_model.respLike_alternation =
  tei_author
  | tei_editor
  | tei_respStmt
  | tei_meeting
  | tei_sponsor
  | tei_funder
  | tei_principal
tei_model.respLike_sequence =
  tei_author,
  tei_editor,
  tei_respStmt,
  tei_meeting,
  tei_sponsor,
  tei_funder,
  tei_principal
tei_model.respLike_sequenceOptional =
  tei_author?,
  tei_editor?,
  tei_respStmt?,
  tei_meeting?,
  tei_sponsor?,
  tei_funder?,
  tei_principal?
tei_model.respLike_sequenceOptionalRepeatable =
  tei_author*,
  tei_editor*,
  tei_respStmt*,
  tei_meeting*,
  tei_sponsor*,
  tei_funder*,
  tei_principal*
tei_model.respLike_sequenceRepeatable =
  tei_author+,
  tei_editor+,
  tei_respStmt+,
  tei_meeting+,
  tei_sponsor+,
  tei_funder+,
  tei_principal+
tei_model.divWrapper =
  tei_meeting
  | tei_byline
  | tei_dateline
  | tei_argument
  | tei_epigraph
  | tei_salute
  | tei_docAuthor
  | tei_docDate
tei_model.divWrapper_alternation =
  tei_meeting
  | tei_byline
  | tei_dateline
  | tei_argument
  | tei_epigraph
  | tei_salute
  | tei_docAuthor
  | tei_docDate
tei_model.divWrapper_sequence =
  tei_meeting,
  tei_byline,
  tei_dateline,
  tei_argument,
  tei_epigraph,
  tei_salute,
  tei_docAuthor,
  tei_docDate
tei_model.divWrapper_sequenceOptional =
  tei_meeting?,
  tei_byline?,
  tei_dateline?,
  tei_argument?,
  tei_epigraph?,
  tei_salute?,
  tei_docAuthor?,
  tei_docDate?
tei_model.divWrapper_sequenceOptionalRepeatable =
  tei_meeting*,
  tei_byline*,
  tei_dateline*,
  tei_argument*,
  tei_epigraph*,
  tei_salute*,
  tei_docAuthor*,
  tei_docDate*
tei_model.divWrapper_sequenceRepeatable =
  tei_meeting+,
  tei_byline+,
  tei_dateline+,
  tei_argument+,
  tei_epigraph+,
  tei_salute+,
  tei_docAuthor+,
  tei_docDate+
tei_model.divTopPart = tei_model.headLike | tei_opener
tei_model.divTopPart_alternation =
  tei_model.headLike_alternation | tei_opener
tei_model.divTopPart_sequence = tei_model.headLike_sequence, tei_opener
tei_model.divTopPart_sequenceOptional =
  tei_model.headLike_sequenceOptional?, tei_opener?
tei_model.divTopPart_sequenceOptionalRepeatable =
  tei_model.headLike_sequenceOptionalRepeatable*, tei_opener*
tei_model.divTopPart_sequenceRepeatable =
  tei_model.headLike_sequenceRepeatable+, tei_opener+
tei_model.divTop = tei_model.divWrapper | tei_model.divTopPart
tei_model.pLike.front =
  tei_head
  | tei_byline
  | tei_argument
  | tei_epigraph
  | tei_docTitle
  | tei_titlePart
  | tei_docAuthor
  | tei_docEdition
  | tei_docImprint
  | tei_docDate
tei_model.divBottomPart =
  tei_trailer | tei_closer | tei_signed | tei_postscript
tei_model.divBottomPart_alternation =
  tei_trailer | tei_closer | tei_signed | tei_postscript
tei_model.divBottomPart_sequence =
  tei_trailer, tei_closer, tei_signed, tei_postscript
tei_model.divBottomPart_sequenceOptional =
  tei_trailer?, tei_closer?, tei_signed?, tei_postscript?
tei_model.divBottomPart_sequenceOptionalRepeatable =
  tei_trailer*, tei_closer*, tei_signed*, tei_postscript*
tei_model.divBottomPart_sequenceRepeatable =
  tei_trailer+, tei_closer+, tei_signed+, tei_postscript+
tei_model.divBottom = tei_model.divWrapper | tei_model.divBottomPart
tei_model.titlepagePart =
  tei_graphic
  | tei_binaryObject
  | tei_byline
  | tei_argument
  | tei_epigraph
  | tei_docTitle
  | tei_titlePart
  | tei_docAuthor
  | tei_imprimatur
  | tei_docEdition
  | tei_docImprint
  | tei_docDate
tei_model.msQuoteLike = tei_title
tei_model.msQuoteLike_alternation = tei_title
tei_model.msQuoteLike_sequence = tei_title
tei_model.msQuoteLike_sequenceOptional = tei_title?
tei_model.msQuoteLike_sequenceOptionalRepeatable = tei_title*
tei_model.msQuoteLike_sequenceRepeatable = tei_title+
tei_model.choicePart =
  tei_sic
  | tei_corr
  | tei_reg
  | tei_orig
  | tei_unclear
  | tei_abbr
  | tei_expan
tei_model.imprintPart =
  tei_publisher | tei_biblScope | tei_pubPlace | tei_distributor
tei_model.imprintPart_alternation =
  tei_publisher | tei_biblScope | tei_pubPlace | tei_distributor
tei_model.imprintPart_sequence =
  tei_publisher, tei_biblScope, tei_pubPlace, tei_distributor
tei_model.imprintPart_sequenceOptional =
  tei_publisher?, tei_biblScope?, tei_pubPlace?, tei_distributor?
tei_model.imprintPart_sequenceOptionalRepeatable =
  tei_publisher*, tei_biblScope*, tei_pubPlace*, tei_distributor*
tei_model.imprintPart_sequenceRepeatable =
  tei_publisher+, tei_biblScope+, tei_pubPlace+, tei_distributor+
tei_model.catDescPart = notAllowed
tei_model.addressLike = tei_email | tei_address
tei_model.addressLike_alternation = tei_email | tei_address
tei_model.addressLike_sequence = tei_email, tei_address
tei_model.addressLike_sequenceOptional = tei_email?, tei_address?
tei_model.addressLike_sequenceOptionalRepeatable =
  tei_email*, tei_address*
tei_model.addressLike_sequenceRepeatable = tei_email+, tei_address+
tei_model.nameLike = tei_model.nameLike.agent | tei_rs | tei_idno
tei_model.nameLike_alternation =
  tei_model.nameLike.agent_alternation | tei_rs | tei_idno
tei_model.nameLike_sequence =
  tei_model.nameLike.agent_sequence, tei_rs, tei_idno
tei_model.nameLike_sequenceOptional =
  tei_model.nameLike.agent_sequenceOptional?, tei_rs?, tei_idno?
tei_model.nameLike_sequenceOptionalRepeatable =
  tei_model.nameLike.agent_sequenceOptionalRepeatable*,
  tei_rs*,
  tei_idno*
tei_model.nameLike_sequenceRepeatable =
  tei_model.nameLike.agent_sequenceRepeatable+, tei_rs+, tei_idno+
tei_model.global =
  tei_model.global.meta
  | tei_model.milestoneLike
  | tei_model.noteLike
  | tei_model.global.edit
  | tei_figure
tei_model.biblPart =
  tei_model.respLike
  | tei_model.imprintPart
  | tei_series
  | tei_relatedItem
  | tei_edition
  | tei_extent
tei_model.frontPart = tei_divGen | tei_titlePage
tei_model.addrPart =
  tei_model.nameLike
  | tei_addrLine
  | tei_street
  | tei_postCode
  | tei_postBox
tei_model.pPart.data =
  tei_model.dateLike
  | tei_model.measureLike
  | tei_model.addressLike
  | tei_model.nameLike
tei_model.pPart.data_alternation =
  tei_model.dateLike_alternation
  | tei_model.measureLike_alternation
  | tei_model.addressLike_alternation
  | tei_model.nameLike_alternation
tei_model.pPart.data_sequence =
  tei_model.dateLike_sequence,
  tei_model.measureLike_sequence,
  tei_model.addressLike_sequence,
  tei_model.nameLike_sequence
tei_model.pPart.data_sequenceOptional =
  tei_model.dateLike_sequenceOptional?,
  tei_model.measureLike_sequenceOptional?,
  tei_model.addressLike_sequenceOptional?,
  tei_model.nameLike_sequenceOptional?
tei_model.pPart.data_sequenceOptionalRepeatable =
  tei_model.dateLike_sequenceOptionalRepeatable*,
  tei_model.measureLike_sequenceOptionalRepeatable*,
  tei_model.addressLike_sequenceOptionalRepeatable*,
  tei_model.nameLike_sequenceOptionalRepeatable*
tei_model.pPart.data_sequenceRepeatable =
  tei_model.dateLike_sequenceRepeatable+,
  tei_model.measureLike_sequenceRepeatable+,
  tei_model.addressLike_sequenceRepeatable+,
  tei_model.nameLike_sequenceRepeatable+
tei_model.inter =
  tei_model.egLike
  | tei_model.biblLike
  | tei_model.labelLike
  | tei_model.listLike
  | tei_model.stageLike
  | tei_model.qLike
  | tei_table
tei_model.inter_alternation =
  tei_model.egLike_alternation
  | tei_model.biblLike_alternation
  | tei_model.labelLike_alternation
  | tei_model.listLike_alternation
  | tei_model.stageLike_alternation
  | tei_model.qLike_alternation
  | tei_table
tei_model.inter_sequence =
  tei_model.egLike_sequence,
  tei_model.biblLike_sequence,
  tei_model.labelLike_sequence,
  tei_model.listLike_sequence,
  tei_model.stageLike_sequence,
  tei_model.qLike_sequence,
  tei_table
tei_model.inter_sequenceOptional =
  tei_model.egLike_sequenceOptional?,
  tei_model.biblLike_sequenceOptional?,
  tei_model.labelLike_sequenceOptional?,
  tei_model.listLike_sequenceOptional?,
  tei_model.stageLike_sequenceOptional?,
  tei_model.qLike_sequenceOptional?,
  tei_table?
tei_model.inter_sequenceOptionalRepeatable =
  tei_model.egLike_sequenceOptionalRepeatable*,
  tei_model.biblLike_sequenceOptionalRepeatable*,
  tei_model.labelLike_sequenceOptionalRepeatable*,
  tei_model.listLike_sequenceOptionalRepeatable*,
  tei_model.stageLike_sequenceOptionalRepeatable*,
  tei_model.qLike_sequenceOptionalRepeatable*,
  tei_table*
tei_model.inter_sequenceRepeatable =
  tei_model.egLike_sequenceRepeatable+,
  tei_model.biblLike_sequenceRepeatable+,
  tei_model.labelLike_sequenceRepeatable+,
  tei_model.listLike_sequenceRepeatable+,
  tei_model.stageLike_sequenceRepeatable+,
  tei_model.qLike_sequenceRepeatable+,
  tei_table+
tei_model.common = tei_model.divPart | tei_model.inter
tei_model.phrase =
  tei_model.segLike
  | tei_model.highlighted
  | tei_model.graphicLike
  | tei_model.pPart.edit
  | tei_model.ptrLike
  | tei_model.pPart.data
tei_model.limitedPhrase =
  tei_model.emphLike
  | tei_model.pPart.editorial
  | tei_model.ptrLike
  | tei_model.pPart.data
tei_model.divLike = tei_div
tei_model.divGenLike = tei_divGen
tei_model.div1Like = tei_div1
tei_model.div2Like = tei_div2
tei_model.div3Like = tei_div3
tei_model.div4Like = tei_div4
tei_model.div5Like = tei_div5
tei_model.div6Like = tei_div6
tei_model.div7Like = tei_div7
tei_model.applicationLike = tei_application
tei_model.teiHeaderPart = tei_encodingDesc | tei_profileDesc
tei_model.sourceDescPart = notAllowed
tei_model.encodingDescPart =
  tei_projectDesc
  | tei_samplingDecl
  | tei_editorialDecl
  | tei_tagsDecl
  | tei_refsDecl
  | tei_classDecl
  | tei_appInfo
  | tei_geoDecl
tei_model.editorialDeclPart =
  tei_correction
  | tei_normalization
  | tei_quotation
  | tei_hyphenation
  | tei_segmentation
  | tei_stdVals
  | tei_interpretation
tei_model.profileDescPart = tei_creation | tei_langUsage | tei_textClass
tei_model.resourceLike = notAllowed
tei_p =
  
  ## (paragraph) marks paragraphs in prose.
  element ns1:p {
    tei_macro.paraContent,
    tei_att.global.attributes,
    tei_att.declaring.attributes,
    empty
  }
tei_foreign =
  
  ## (foreign) identifies a word or phrase as belonging to some language other than that of the
  ##                 surrounding text. 
  element ns1:foreign {
    tei_macro.phraseSeq, tei_att.global.attributes, empty
  }
tei_emph =
  
  ## (emphasized) marks words or phrases which are stressed or emphasized for
  ##         linguistic or rhetorical effect.
  element ns1:emph {
    tei_macro.paraContent, tei_att.global.attributes, empty
  }
tei_hi =
  
  ## (highlighted) marks a word or phrase as graphically distinct from the
  ##         surrounding text, for reasons concerning which no claim is
  ##         made. 
  element ns1:hi {
    tei_macro.paraContent, tei_att.global.attributes, empty
  }
tei_distinct =
  
  ## identifies any word or phrase which is regarded as linguistically distinct, for example as
  ##         archaic, technical, dialectal, non-preferred, etc., or as forming part of a sublanguage. 
  element ns1:distinct {
    tei_macro.phraseSeq,
    tei_att.global.attributes,
    
    ## specifies the sublanguage or register to which the word or phrase is being
    ##                 assigned
    attribute type { tei_data.enumerated }?,
    
    ## specifies how the phrase is distinct diachronically
    attribute time { tei_data.code }?,
    
    ## specifies how the phrase is distinct diatopically
    attribute space { tei_data.code }?,
    
    ## specifies how the phrase is distinct diastatically
    attribute social { tei_data.code }?,
    empty
  }
tei_said =
  
  ## (speech or thought) indicates passages thought or spoken aloud, whether explicitly indicated in the source or
  ##     not, whether directly or indirectly reported, whether by real people or fictional characters.
  element ns1:said {
    tei_macro.specialPara,
    tei_att.global.attributes,
    tei_att.ascribed.attributes,
    
    ## may be used to indicate whether the quoted matter is regarded as having been vocalized
    ##         or signed.
    [ a:defaultValue = "unknown" ]
    attribute aloud { tei_data.xTruthValue }?,
    
    ## may be used to indicate whether the quoted matter is regarded as direct or indirect
    ##         speech.
    [ a:defaultValue = "true" ]
    attribute direct { tei_data.xTruthValue }?,
    empty
  }
tei_quote =
  
  ## (quotation) contains a phrase or passage attributed by the narrator or author to some agency external
  ##         to the text.
  element ns1:quote {
    tei_macro.specialPara,
    tei_att.global.attributes,
    tei_att.typed.attributes,
    empty
  }
tei_q =
  
  ## (separated from the surrounding text with quotation marks) contains material which is marked as (ostensibly) being somehow different than the
  ##     surrounding text, for any one of a variety of reasons including, but not limited to: direct
  ##     speech or thought, technical terms or jargon, authorial distance, quotations from elsewhere, and
  ##     passages that are mentioned but not used.
  element ns1:q {
    tei_macro.specialPara,
    tei_att.global.attributes,
    tei_att.ascribed.attributes,
    
    ## may be used to indicate whether the offset passage is spoken or thought, or to
    ##         characterize it more finely.
    ## Suggested values include: 1] spoken; 2] thought; 3] written; 4] soCalled; 5] foreign(foreign words) ; 6] distinct(linguistically distinct) ; 7] term(technical term) ; 8] emph(rhetorically emphasized) ; 9] mentioned
    attribute type {
      
      ## representation of speech
      "spoken"
      | 
        ## representation of thought, e.g. internal monologue
        "thought"
      | 
        ## quotation from a written source
        "written"
      | 
        ## authorial distance
        "soCalled"
      | 
        ## (foreign words) 
        "foreign"
      | 
        ## (linguistically distinct) 
        "distinct"
      | 
        ## (technical term) 
        "term"
      | 
        ## (rhetorically emphasized) 
        "emph"
      | 
        ## refering to itself, not its normal referant
        "mentioned"
      | xsd:Name
    }?,
    empty
  }
tei_cit =
  
  ## (cited quotation) contains a quotation from some other document, together with a bibliographic reference to
  ##     its source. In a dictionary it may contain an example text with at least one occurrence of the
  ##     word form, used in the sense being described, or a translation of the headword, or an example. 
  element ns1:cit {
    (tei_model.qLike
     | tei_model.egLike
     | tei_model.biblLike
     | tei_model.ptrLike
     | tei_model.global
     | tei_model.entryPart)+,
    tei_att.global.attributes,
    tei_att.typed.attributes,
    empty
  }
tei_mentioned =
  
  ## marks words or phrases mentioned, not used.
  element ns1:mentioned {
    tei_macro.phraseSeq, tei_att.global.attributes, empty
  }
tei_soCalled =
  
  ## contains a word or phrase for which the author or narrator indicates a disclaiming of
  ##     responsibility, for example by the use of scare quotes or italics.
  element ns1:soCalled {
    tei_macro.phraseSeq, tei_att.global.attributes, empty
  }
tei_desc =
  
  ## (description) contains a brief description of the object documented by its parent element, including its
  ##     intended usage, purpose, or application where this is appropriate.
  element ns1:desc {
    tei_macro.limitedContent,
    tei_att.global.attributes,
    tei_att.translatable.attributes,
    empty
  }
tei_gloss =
  
  ## identifies a phrase or word used to provide a gloss or definition for some other word or
  ##     phrase.
  element ns1:gloss {
    tei_macro.phraseSeq,
    tei_att.global.attributes,
    tei_att.declaring.attributes,
    tei_att.translatable.attributes,
    tei_att.typed.attributes,
    tei_att.pointing.attributes,
    
    ## (canonical reference) identifies the associated term element using a canonical reference from a
    ##         scheme defined in a refsDecl element in the TEI header
    attribute cRef { tei_data.pointer }?,
    empty
  }
tei_term =
  
  ## contains a single-word, multi-word, or symbolic designation which is regarded as a technical
  ##     term.
  element ns1:term {
    tei_macro.phraseSeq,
    tei_att.global.attributes,
    tei_att.declaring.attributes,
    tei_att.pointing.attributes,
    tei_att.typed.attributes,
    tei_att.canonical.attributes,
    
    ## identifies the associated gloss element using a canonical reference from a
    ##           scheme defined in a refsDecl element in the TEI header
    attribute cRef { tei_data.pointer }?,
    
    ## supplies the sort key for this term in an index.
    attribute sortKey { tei_data.word }?,
    empty
  }
tei_sic =
  
  ## (latin for thus or so
  ##   ) contains text reproduced although apparently incorrect or inaccurate.
  element ns1:sic {
    tei_macro.paraContent,
    tei_att.global.attributes,
    tei_att.responsibility.attributes,
    empty
  }
tei_corr =
  
  ## (correction) contains the correct form of a passage apparently erroneous in the copy text.
  element ns1:corr {
    tei_macro.paraContent,
    tei_att.global.attributes,
    tei_att.editLike.attributes,
    tei_att.typed.attributes,
    empty
  }
tei_choice =
  
  ## groups a number of alternative encodings for the same point in
  ##         a text.
  element ns1:choice {
    (tei_model.choicePart | tei_choice)*,
    tei_att.global.attributes,
    empty
  }
tei_reg =
  
  ## (regularization) contains a reading which has been regularized or normalized in some sense.
  element ns1:reg {
    tei_macro.paraContent,
    tei_att.global.attributes,
    tei_att.editLike.attributes,
    tei_att.typed.attributes,
    empty
  }
tei_orig =
  
  ## (original form) contains a reading which is marked as following the original, rather than being normalized
  ##         or corrected.
  element ns1:orig {
    tei_macro.paraContent,
    tei_att.global.attributes,
    tei_att.responsibility.attributes,
    empty
  }
tei_gap =
  
  ## (gap) indicates a point where material has been omitted in a transcription, whether for editorial
  ##     reasons described in the TEI header, as part of sampling practice, or because the material is
  ##     illegible, invisible, or inaudible.
  element ns1:gap {
    tei_model.glossLike*,
    tei_att.global.attributes,
    tei_att.editLike.attributes,
    
    ## gives the reason for omission. Sample values include sampling,
    ##         inaudible, irrelevant, cancelled.
    attribute reason {
      list { tei_data.word, tei_data.word* }
    }?,
    
    ## in the case of text omitted from the transcription because of deliberate deletion by an
    ##         identifiable hand, signifies the hand which made the deletion.
    attribute hand { tei_data.pointer }?,
    
    ## In the case of text omitted because of damage, categorizes the cause of the damage, if
    ##         it can be identified.
    ## Sample values include: 1] rubbing; 2] mildew; 3] smoke
    attribute agent { tei_data.enumerated }?,
    empty
  }
tei_add =
  
  ## (addition) contains letters, words, or phrases inserted in the text by an
  ##         author, scribe, annotator, or corrector.
  element ns1:add {
    tei_macro.paraContent,
    tei_att.global.attributes,
    tei_att.transcriptional.attributes,
    tei_att.placement.attributes,
    tei_att.typed.attributes,
    empty
  }
tei_del =
  
  ## (deletion) contains a letter, word, or passage deleted, marked as deleted, or otherwise indicated as
  ##     superfluous or spurious in the copy text by an author, scribe, annotator, or corrector.
  element ns1:del {
    tei_macro.paraContent,
    tei_att.global.attributes,
    tei_att.transcriptional.attributes,
    tei_att.typed.attributes,
    empty
  }
tei_unclear =
  
  ## contains a word, phrase, or passage which cannot be transcribed with certainty because it
  ##         is illegible or inaudible in the source.
  element ns1:unclear {
    tei_macro.paraContent,
    tei_att.global.attributes,
    tei_att.editLike.attributes,
    
    ## indicates why the material is hard to transcribe.
    attribute reason {
      list { tei_data.word, tei_data.word* }
    }?,
    
    ## Where the difficulty in transcription arises from action (partial deletion, etc.)
    ##                 assignable to an identifiable hand, signifies the hand responsible for the action.
    attribute hand { tei_data.pointer }?,
    
    ## Where the difficulty in transcription arises from damage, categorizes the cause of
    ##                 the damage, if it can be identified.
    ## Sample values include: 1] rubbing; 2] mildew; 3] smoke
    attribute agent { tei_data.enumerated }?,
    empty
  }
tei_name =
  
  ## (name, proper noun) contains a proper noun or noun phrase.
  element ns1:name {
    tei_macro.phraseSeq,
    tei_att.global.attributes,
    tei_att.naming.attributes,
    tei_att.typed.attributes,
    empty
  }
tei_rs =
  
  ## (referencing string) contains a general purpose name or referring string.
  element ns1:rs {
    tei_macro.phraseSeq,
    tei_att.global.attributes,
    tei_att.naming.attributes,
    
    ## indicates more specifically the object referred to by the referencing string.
    ##                 Values might include person, place, ship,
    ##                     element etc.
    attribute type { tei_data.enumerated }?,
    empty
  }
tei_email =
  
  ## (electronic mail address) contains an e-mail address identifying a location to which
  ##         e-mail messages can be delivered.
  ##     
  element ns1:email {
    tei_macro.phraseSeq, tei_att.global.attributes, empty
  }
tei_address =
  
  ## contains a postal  address, for example of a
  ##         publisher, an organization, or an individual.
  element ns1:address {
    (tei_model.global*, (tei_model.addrPart, tei_model.global*)+),
    tei_att.global.attributes,
    empty
  }
tei_addrLine =
  
  ## (address line) contains one line of a postal address.
  element ns1:addrLine {
    tei_macro.phraseSeq, tei_att.global.attributes, empty
  }
tei_street =
  
  ## a full street address including any name or number identifying a
  ##         building as well as the name of the street or route on which it is
  ##         located.
  element ns1:street {
    tei_macro.phraseSeq, tei_att.global.attributes, empty
  }
tei_postCode =
  
  ## (postal code) contains a numerical or alphanumeric code used as part of a postal address to simplify
  ##         sorting or delivery of mail. 
  element ns1:postCode { text, tei_att.global.attributes, empty }
tei_postBox =
  
  ## (postal box or post office box) contains a number or other identifier for some postal delivery point other than a street
  ##     address. 
  element ns1:postBox { text, tei_att.global.attributes, empty }
tei_num =
  
  ## (number) contains a number, written in any form.
  element ns1:num {
    tei_macro.phraseSeq,
    tei_att.global.attributes,
    tei_att.ranging.attributes,
    
    ## indicates the type of numeric value.
    ## Suggested values include: 1] cardinal; 2] ordinal; 3] fraction; 4] percentage
    attribute type {
      
      ## absolute number, e.g. 21, 21.5
      "cardinal"
      | 
        ## ordinal number, e.g. 21st
        "ordinal"
      | 
        ## fraction, e.g. one half or three-quarters
        "fraction"
      | 
        ## a percentage
        "percentage"
      | xsd:Name
    }?,
    
    ## supplies the value of the number in standard form.
    attribute value { tei_data.numeric }?,
    empty
  }
tei_measure =
  
  ## contains a word or phrase referring to some quantity of an object or commodity, usually
  ##         comprising a number, a unit, and a commodity name.
  element ns1:measure {
    tei_macro.phraseSeq,
    tei_att.global.attributes,
    tei_att.measurement.attributes,
    
    ## specifies the type of measurement in any convenient typology.
    attribute type { tei_data.enumerated }?,
    empty
  }
tei_measureGrp =
  
  ## (measure group) contains a group of dimensional specifications which relate to the same object, for example
  ##     the height and width of a manuscript page.
  element ns1:measureGrp {
    (text | tei_model.gLike | tei_model.measureLike)*,
    tei_att.global.attributes,
    tei_att.measurement.attributes,
    tei_att.typed.attributes,
    empty
  }
tei_date =
  
  ## contains a date in any format.
  element ns1:date {
    (text | tei_model.gLike | tei_model.phrase | tei_model.global)*,
    tei_att.global.attributes,
    tei_att.datable.attributes,
    tei_att.editLike.attributes,
    tei_att.typed.attributes,
    
    ## indicates the system or calendar to which the date represented by the content of this
    ##         element belongs.
    ## Suggested values include: 1] Gregorian; 2] Julian; 3] Islamic; 4] Hebrew; 5] Revolutionary; 6] Iranian; 7] Coptic; 8] Chinese
    attribute calendar {
      
      ## Gregorian calendar
      "Gregorian"
      | 
        ## Julian calendar
        "Julian"
      | 
        ## Islamic or Muslim (hijri) lunar calendar
        "Islamic"
      | 
        ## Hebrew or Jewish lunisolar calendar
        "Hebrew"
      | 
        ## French Revolutionary calendar
        "Revolutionary"
      | 
        ## Iranian or Persian (Jalaali) solar calendar
        "Iranian"
      | 
        ## Coptic or Alexandrian calendar
        "Coptic"
      | 
        ## Chinese lunisolar calendar
        "Chinese"
      | xsd:Name
    }?,
    empty
  }
tei_time =
  
  ## contains a phrase defining a time of day in any format.
  element ns1:time {
    (text | tei_model.gLike | tei_model.phrase | tei_model.global)*,
    tei_att.global.attributes,
    tei_att.datable.attributes,
    tei_att.editLike.attributes,
    tei_att.typed.attributes,
    empty
  }
tei_abbr =
  
  ## (abbreviation) contains an abbreviation of any sort.
  element ns1:abbr {
    tei_macro.phraseSeq,
    tei_att.global.attributes,
    tei_att.responsibility.attributes,
    
    ## allows the encoder to classify the abbreviation according to some convenient
    ##                 typology.
    ## Sample values include: 1] suspension; 2] contraction; 3] brevigraph; 4] superscription; 5] acronym; 6] title; 7] organization; 8] geographic
    attribute type { tei_data.enumerated }?,
    empty
  }
tei_expan =
  
  ## (expansion) contains the expansion of an abbreviation.
  element ns1:expan {
    tei_macro.phraseSeq,
    tei_att.global.attributes,
    tei_att.editLike.attributes,
    empty
  }
tei_ptr =
  
  ## (pointer) defines a pointer to another location.
  element ns1:ptr {
    empty
    >> sch:pattern [
         id = "ptr-constraint-ptrAtts"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "tei:ptr"
           "\x{a}" ~
           "               "
           sch:report [
             test = "@target and @cRef"
             "Only one of the\x{a}" ~
             "	attributes 'target' and 'cRef' may be supplied."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    tei_att.global.attributes,
    tei_att.pointing.attributes,
    tei_att.typed.attributes,
    tei_att.declaring.attributes,
    
    ## (canonical reference) specifies the destination of the pointer by supplying a canonical reference from a
    ##         scheme defined in a refsDecl element in the TEI header
    attribute cRef {
      list { tei_data.word, tei_data.word* }
    }?,
    empty
  }
tei_ref =
  
  ## (reference) defines a reference to another location, possibly modified by additional text or comment.
  element ns1:ref {
    tei_macro.paraContent
    >> sch:pattern [
         id = "ref-constraint-refAtts"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "tei:ref"
           "\x{a}" ~
           "               "
           sch:report [
             test = "@target and @cRef"
             "Only one of the\x{a}" ~
             "	attributes 'target' and 'cRef' may be supplied."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    tei_att.global.attributes,
    tei_att.pointing.attributes,
    tei_att.typed.attributes,
    tei_att.declaring.attributes,
    
    ## (canonical reference) specifies the destination of the reference by supplying a canonical reference from a
    ##         scheme defined in a refsDecl element in the TEI header
    attribute cRef {
      list { tei_data.word, tei_data.word* }
    }?,
    empty
  }
tei_list =
  
  ## (list) contains any sequence of items organized as a list.
  element ns1:list {
    ((tei_model.divTop | tei_model.global)*,
     ((tei_item, tei_model.global*)+
      | (tei_headLabel?,
         tei_headItem?,
         (tei_label, tei_model.global*, tei_item, tei_model.global*)+)),
     (tei_model.divBottom, tei_model.global*)*),
    tei_att.global.attributes,
    
    ## describes the form of the list.
    ## Suggested values include: 1] ordered; 2] bulleted; 3] simple; 4] gloss
    [ a:defaultValue = "simple" ]
    attribute type {
      
      ## list items are numbered or lettered. 
      "ordered"
      | 
        ## list items are marked with a bullet or other typographic device. 
        "bulleted"
      | 
        ## list items are not numbered or bulleted. 
        "simple"
      | 
        ## each list item glosses some term or concept, which is given by a label element
        ##             preceding the list item.
        "gloss"
      | xsd:Name
    }?,
    empty
  }
tei_item =
  
  ## contains one component of a list.
  element ns1:item {
    tei_macro.specialPara, tei_att.global.attributes, empty
  }
tei_label =
  
  ## contains the label associated with an item in a list; in glossaries, marks the term being
  ##     defined.
  element ns1:label {
    tei_macro.phraseSeq, tei_att.global.attributes, empty
  }
tei_head =
  
  ## (heading) contains any type of heading, for example the title of a section, or the heading of a list,
  ##     glossary, manuscript description, etc.
  element ns1:head {
    tei_macro.paraContent,
    tei_att.global.attributes,
    tei_att.typed.attributes,
    empty
  }
tei_headLabel =
  
  ## (heading for list labels) contains the heading for the label or term column in a glossary list or similar structured
  ##         list.
  element ns1:headLabel {
    tei_macro.phraseSeq, tei_att.global.attributes, empty
  }
tei_headItem =
  
  ## (heading for list items) contains the heading for the item or gloss column in a glossary list or similar structured
  ##         list.
  element ns1:headItem {
    tei_macro.phraseSeq, tei_att.global.attributes, empty
  }
tei_note =
  
  ## contains a note or annotation.
  element ns1:note {
    tei_macro.specialPara,
    tei_att.global.attributes,
    tei_att.placement.attributes,
    tei_att.pointing.attributes,
    tei_att.responsibility.attributes,
    tei_att.typed.attributes,
    
    ## indicates whether the copy text shows the exact place of reference for the note.
    [ a:defaultValue = "true" ]
    attribute anchored { tei_data.truthValue }?,
    
    ## points to the end of the span to which the note is attached, if the note is not embedded
    ##         in the text at that point.
    attribute targetEnd {
      list { tei_data.pointer, tei_data.pointer* }
    }?,
    empty
  }
tei_index =
  
  ## (index entry) marks a location to be indexed for whatever purpose.
  element ns1:index {
    (tei_term, tei_index?)*,
    tei_att.global.attributes,
    tei_att.spanning.attributes,
    
    ## supplies a name to specify which index (of several) the index entry belongs to.
    attribute indexName { tei_data.name }?,
    empty
  }
tei_graphic =
  
  ## indicates the location of an inline graphic, illustration, or figure.
  element ns1:graphic {
    tei_model.glossLike*,
    tei_att.global.attributes,
    tei_att.internetMedia.attributes,
    tei_att.declaring.attributes,
    
    ## The display width of the image
    attribute width { tei_data.outputMeasurement }?,
    
    ## The display height of the image
    attribute height { tei_data.outputMeasurement }?,
    
    ## A scale factor to be applied to the image to make it the desired display size
    attribute scale { tei_data.numeric }?,
    
    ## (uniform resource locator) A URL which refers to the image itself.
    attribute url { tei_data.pointer },
    empty
  }
tei_binaryObject =
  
  ## provides encoded binary data representing an inline graphic or other object.
  element ns1:binaryObject {
    text,
    tei_att.global.attributes,
    tei_att.internetMedia.attributes,
    
    ## The display width of the object
    attribute width { tei_data.outputMeasurement }?,
    
    ## The display height of the object
    attribute height { tei_data.outputMeasurement }?,
    
    ## A scale factor to be applied to the object to make it the desired display size
    attribute scale { tei_data.numeric }?,
    
    ## The encoding used to encode the binary data. If not specified, this is assumed to be
    ##           Base64.
    attribute encoding {
      list { tei_data.word, tei_data.word* }
    }?,
    empty
  }
tei_milestone =
  
  ## marks a boundary point separating any kind of section of a text, typically but not
  ##     necessarily indicating a point at which some part of a standard reference system changes, where
  ##     the change is not represented by a structural element.
  element ns1:milestone {
    empty,
    tei_att.global.attributes,
    tei_att.typed.attributes,
    tei_att.sourced.attributes,
    tei_att.spanning.attributes,
    tei_att.breaking.attributes,
    
    ## provides a conventional name for the kind of section changing at this milestone.
    ## Suggested values include: 1] page; 2] column; 3] line; 4] book; 5] poem; 6] canto; 7] speaker; 8] stanza; 9] act; 10] scene; 11] section; 12] absent; 13] unnumbered
    attribute unit {
      
      ## physical page breaks (synonymous with the pb element).
      "page"
      | 
        ## column breaks.
        "column"
      | 
        ## line breaks (synonymous with the lb element).
        "line"
      | 
        ## any units termed book, liber, etc.
        "book"
      | 
        ## individual poems in a collection.
        "poem"
      | 
        ## cantos or other major sections of a poem.
        "canto"
      | 
        ## changes of speaker or narrator.
        "speaker"
      | 
        ## stanzas within a poem, book, or canto.
        "stanza"
      | 
        ## acts within a play.
        "act"
      | 
        ## scenes within a play or act.
        "scene"
      | 
        ## sections of any kind.
        "section"
      | 
        ## passages not present in the reference edition.
        "absent"
      | 
        ## passages present in the text, but not to be included as part of the reference.
        "unnumbered"
      | xsd:Name
    },
    empty
  }
tei_pb =
  
  ## (page break) marks the boundary between one page of a text and the next in a standard reference system.
  element ns1:pb {
    empty,
    tei_att.global.attributes,
    tei_att.typed.attributes,
    tei_att.sourced.attributes,
    tei_att.spanning.attributes,
    tei_att.breaking.attributes,
    empty
  }
tei_lb =
  
  ## (line break) marks the start of a new (typographic) line in some edition or version of a text.
  element ns1:lb {
    empty,
    tei_att.global.attributes,
    tei_att.typed.attributes,
    tei_att.sourced.attributes,
    tei_att.spanning.attributes,
    tei_att.breaking.attributes,
    empty
  }
tei_cb =
  
  ## (column break) marks the boundary between one column of a text and the next
  ##         in a standard reference system.
  element ns1:cb {
    empty,
    tei_att.global.attributes,
    tei_att.typed.attributes,
    tei_att.sourced.attributes,
    tei_att.spanning.attributes,
    tei_att.breaking.attributes,
    empty
  }
tei_analytic =
  
  ## (analytic level) contains bibliographic elements describing an item (e.g. an article or poem) published
  ##     within a monograph or journal and not as an independent publication.
  element ns1:analytic {
    (tei_author
     | tei_editor
     | tei_respStmt
     | tei_title
     | tei_ref
     | tei_date)*,
    tei_att.global.attributes,
    empty
  }
tei_monogr =
  
  ## (monographic level) contains bibliographic elements describing an item (e.g. a book or journal) published as an
  ##     independent item (i.e. as a separate physical object).
  element ns1:monogr {
    ((((tei_author | tei_editor | tei_respStmt),
       (tei_author | tei_editor | tei_respStmt)*,
       tei_title+,
       (tei_idno | tei_editor | tei_respStmt)*)
      | ((tei_title | tei_ref)+,
         (tei_idno | tei_author | tei_editor | tei_respStmt)*))?,
     (tei_model.noteLike | tei_meeting)*,
     (tei_edition, (tei_idno | tei_editor | tei_respStmt)*)*,
     tei_imprint,
     (tei_imprint | tei_extent | tei_biblScope)*),
    tei_att.global.attributes,
    empty
  }
tei_series =
  
  ## (series information) contains information about the series in which a book or other bibliographic item has
  ##     appeared.
  element ns1:series {
    (text
     | tei_model.gLike
     | tei_title
     | tei_ref
     | tei_editor
     | tei_respStmt
     | tei_biblScope
     | tei_model.global)*,
    tei_att.global.attributes,
    empty
  }
tei_author =
  
  ## in a bibliographic reference, contains the name(s) of the
  ##   author(s), personal or corporate, of a work; for example in the same
  ##   form as that provided by a recognized bibliographic name authority. 
  element ns1:author {
    tei_macro.phraseSeq,
    tei_att.global.attributes,
    tei_att.naming.attributes,
    empty
  }
tei_editor =
  
  ## secondary statement of responsibility for a bibliographic item, for example the name of an
  ##     individual, institution or organization, (or of several such) acting as editor, compiler,
  ##     translator, etc. 
  element ns1:editor {
    tei_macro.phraseSeq,
    tei_att.global.attributes,
    tei_att.naming.attributes,
    empty
  }
tei_respStmt =
  
  ## (statement of responsibility) supplies a statement of responsibility for the intellectual content of a text, edition,
  ##     recording, or series, where the specialized elements for authors, editors, etc. do not suffice
  ##     or do not apply.
  element ns1:respStmt {
    ((tei_resp+, tei_model.nameLike.agent+)
     | (tei_model.nameLike.agent+, tei_resp+)),
    tei_att.global.attributes,
    empty
  }
tei_resp =
  
  ## (responsibility) contains a phrase describing the nature of a person's intellectual responsibility.
  element ns1:resp {
    tei_macro.phraseSeq.limited,
    tei_att.global.attributes,
    tei_att.canonical.attributes,
    empty
  }
tei_title =
  
  ## contains a title for any kind of work.
  element ns1:title {
    tei_macro.paraContent,
    tei_att.global.attributes,
    tei_att.canonical.attributes,
    
    ## indicates the bibliographic level for a title, that is, whether
    ##                                         it identifies an article, book, journal, series, or
    ##                                         unpublished material.
    attribute level {
      
      ## (analytic) analytic title (article, poem, or other item
      ##                                                   published as part of a larger item) 
      "a"
      | 
        ## (monographic) monographic title (book, collection, or
        ##                                                   other item published as a distinct item,
        ##                                                   including single volumes of multi-volume
        ##                                                   works) 
        "m"
      | 
        ## (journal) journal title 
        "j"
      | 
        ## (series) series title 
        "s"
      | 
        ## (unpublished) title of unpublished material (including
        ##                                                   theses and dissertations unless
        ##                                                   published by a commercial press)
        "u"
    }?,
    
    ## classifies the title according to some convenient typology.
    ## Sample values include: 1] main; 2] sub(subordinate) ; 3] alt(alternate) ; 4] short; 5] desc(descriptive) 
    attribute type { tei_data.enumerated }?,
    empty
  }
tei_meeting =
  
  ## contains the formalized descriptive title for a meeting or conference, for use in a
  ##     bibliographic description for an item derived from such a meeting, or as a heading or preamble
  ##     to publications emanating from it.
  element ns1:meeting {
    tei_macro.limitedContent, tei_att.global.attributes, empty
  }
tei_imprint =
  
  ## groups information relating to the publication or distribution
  ##         of a bibliographic item.
  element ns1:imprint {
    ((tei_model.imprintPart | tei_model.dateLike), tei_model.global*)+,
    tei_att.global.attributes,
    empty
  }
tei_publisher =
  
  ## provides the name of the organization responsible for the publication or distribution of a
  ##         bibliographic item.
  element ns1:publisher {
    tei_macro.phraseSeq, tei_att.global.attributes, empty
  }
tei_biblScope =
  
  ## (scope of citation) defines the scope of a bibliographic reference, for example as a
  ##         list of page numbers, or a named subdivision of a larger work.
  element ns1:biblScope {
    tei_macro.phraseSeq,
    tei_att.global.attributes,
    
    ## identifies the type of information conveyed by the element, e.g.
    ##                 columns, pages, volume.
    ## Suggested values include: 1] vol(volume) ; 2] issue; 3] pp(pages) ; 4] ll (lines) ; 5] chap(chapter) ; 6] part
    attribute type {
      
      ## (volume) the element contains a volume number.
      "vol"
      | 
        ## the element contains an issue number, or volume and
        ##                         issue numbers.
        "issue"
      | 
        ## (pages) the element contains a page number or page range.
        "pp"
      | 
        ##  (lines) the element contains a line number or line range.
        "ll"
      | 
        ## (chapter) the element contains a chapter indication (number
        ##                         and/or title)
        "chap"
      | 
        ## the element identifies a part of a book or collection.
        "part"
      | xsd:Name
    }?,
    
    ## specifies the starting point of the range of units indicated by the type attribute.
    attribute from { tei_data.word }?,
    
    ## specifies the end-point of the range of units indicated by the type attribute.
    attribute to { tei_data.word }?,
    empty
  }
tei_pubPlace =
  
  ## (publication place) contains the name of the place where a bibliographic item was published.
  element ns1:pubPlace {
    tei_macro.phraseSeq,
    tei_att.global.attributes,
    tei_att.naming.attributes,
    empty
  }
tei_bibl =
  
  ## (bibliographic citation) contains a loosely-structured bibliographic citation of which the sub-components may or may
  ##     not be explicitly tagged. 
  element ns1:bibl {
    (text
     | tei_model.gLike
     | tei_model.highlighted
     | tei_model.pPart.data
     | tei_model.pPart.edit
     | tei_model.segLike
     | tei_model.ptrLike
     | tei_model.biblPart
     | tei_model.global)*,
    tei_att.global.attributes,
    tei_att.declarable.attributes,
    tei_att.typed.attributes,
    empty
  }
tei_biblStruct =
  
  ## (structured bibliographic citation) contains a structured bibliographic citation, in which only bibliographic sub-elements
  ##     appear and in a specified order. 
  element ns1:biblStruct {
    (tei_analytic*,
     (tei_monogr, tei_series*)+,
     (tei_model.noteLike | tei_idno | tei_relatedItem)*),
    tei_att.global.attributes,
    tei_att.declarable.attributes,
    tei_att.typed.attributes,
    empty
  }
tei_listBibl =
  
  ## (citation list) contains a list of bibliographic citations of any kind. 
  element ns1:listBibl {
    (tei_model.headLike*,
     (tei_model.biblLike | tei_model.milestoneLike | tei_listBibl)+),
    tei_att.global.attributes,
    tei_att.declarable.attributes,
    tei_att.typed.attributes,
    empty
  }
tei_relatedItem =
  
  ## contains or references some other bibliographic item which is related to the present one in
  ##     some specified manner, for example as a constituent or alternative version of it.
  element ns1:relatedItem {
    ((tei_model.biblLike | tei_model.ptrLike)?)
    >> sch:pattern [
         id = "relatedItem-constraint-targetorcontent11"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "tei:relatedItem"
           "\x{a}" ~
           "               "
           sch:report [
             test = "@target and count( child::* ) > 0"
             "If the 'target' attribute is used, the\x{a}" ~
             "        relatedItem element must be empty"
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ]
    >> sch:pattern [
         id = "relatedItem-constraint-targetorcontent11"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "tei:relatedItem"
           "\x{a}" ~
           "               "
           sch:assert [
             test = "@target or child::*"
             "A relatedItem element should have either a 'target' attribute\x{a}" ~
             "        or a child element to indicate the related bibliographic item"
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    tei_att.global.attributes,
    tei_att.typed.attributes,
    
    ## points to the related bibliographic element by means of an
    ##       absolute or relative URI reference
    attribute target { tei_data.pointer }?,
    empty
  }
tei_l =
  
  ## (verse line) contains a single, possibly incomplete, line of verse.
  element ns1:l {
    tei_macro.paraContent,
    tei_att.global.attributes,
    
    ## specifies whether or not the line is metrically complete. 
    [ a:defaultValue = "N" ]
    attribute part {
      
      ## (yes) the line is metrically incomplete
      "Y"
      | 
        ## (no) either the line is complete, or no claim is made as to its completeness
        "N"
      | 
        ## (initial) the initial part of an incomplete line
        "I"
      | 
        ## (medial) a medial part of an incomplete line
        "M"
      | 
        ## (final) the final part of an incomplete line
        "F"
    }?,
    empty
  }
tei_lg =
  
  ## (line group) contains a group of verse lines functioning as a formal unit, e.g. a stanza, refrain,
  ##         verse paragraph, etc.
  element ns1:lg {
    ((tei_model.divTop | tei_model.global)*,
     (tei_model.lLike | tei_lg),
     (tei_model.lLike | tei_lg | tei_model.global)*,
     (tei_model.divBottom, tei_model.global*)*),
    tei_att.global.attributes,
    tei_att.divLike.attributes,
    tei_att.typed.attributes,
    tei_att.declaring.attributes,
    empty
  }
tei_sp =
  
  ## (speech) An individual speech in a performance text, or a passage presented as such in a prose or
  ##     verse text.
  element ns1:sp {
    (tei_model.global*,
     (tei_speaker, tei_model.global*)?,
     ((tei_model.lLike
       | tei_lg
       | tei_model.pLike
       | tei_model.stageLike
       | tei_model.qLike),
      tei_model.global*)+),
    tei_att.global.attributes,
    tei_att.ascribed.attributes,
    empty
  }
tei_speaker =
  
  ## A specialized form of heading or label, giving the name of one or more speakers in a
  ##         dramatic text or fragment.
  element ns1:speaker {
    tei_macro.phraseSeq, tei_att.global.attributes, empty
  }
tei_stage =
  
  ## (stage direction) contains any kind of stage direction within a dramatic text or fragment.
  element ns1:stage {
    tei_macro.specialPara,
    tei_att.global.attributes,
    
    ## indicates the kind of stage direction.
    ## Suggested values include: 1] setting; 2] entrance; 3] exit; 4] business; 5] novelistic; 6] delivery; 7] modifier; 8] location; 9] mixed
    attribute type {
      
      ## describes a setting.
      "setting"
      | 
        ## describes an entrance.
        "entrance"
      | 
        ## describes an exit.
        "exit"
      | 
        ## describes stage business.
        "business"
      | 
        ## is a narrative, motivating stage direction.
        "novelistic"
      | 
        ## describes how a character speaks.
        "delivery"
      | 
        ## gives some detail about a character.
        "modifier"
      | 
        ## describes a location.
        "location"
      | 
        ## more than one of the above
        "mixed"
      | xsd:Name
    }?,
    empty
  }
tei_teiCorpus =
  
  ## contains the whole of a TEI encoded corpus, comprising a single corpus header and one or
  ##     more TEI elements, each containing a single text header and a text.
  element ns1:teiCorpus {
    (tei_teiHeader, (tei_TEI | tei_teiCorpus)+),
    tei_att.global.attributes,
    
    ## The version of the TEI scheme
    [ a:defaultValue = "5.0" ] attribute version { tei_data.version }?,
    empty
  }
tei_divGen =
  
  ## (automatically generated text division) indicates the location at which a textual division generated
  ##         automatically by a text-processing application is to appear.
  element ns1:divGen {
    tei_model.headLike*,
    tei_att.global.attributes,
    
    ## specifies what type of generated text division (e.g. index,
    ##                 table of contents, etc.) is to appear.
    ## Sample values include: 1] index; 2] toc; 3] figlist; 4] tablist
    attribute type { tei_data.enumerated }?,
    empty
  }
tei_teiHeader =
  
  ## (TEI Header) supplies the descriptive and declarative information making up an electronic title page
  ##     prefixed to every TEI-conformant text.
  element ns1:teiHeader {
    (tei_fileDesc, tei_model.teiHeaderPart*, tei_revisionDesc?),
    tei_att.global.attributes,
    
    ## specifies the kind of document to which the header is attached, for example whether it
    ##         is a corpus or individual text.
    ## Sample values include: 1] text; 2] corpus
    [ a:defaultValue = "text" ] attribute type { tei_data.enumerated }?,
    empty
  }
tei_fileDesc =
  
  ## (file description) contains a full bibliographic description of an electronic file.
  element ns1:fileDesc {
    ((tei_titleStmt,
      tei_editionStmt?,
      tei_extent?,
      tei_publicationStmt,
      tei_seriesStmt?,
      tei_notesStmt?),
     tei_sourceDesc+),
    tei_att.global.attributes,
    empty
  }
tei_titleStmt =
  
  ## (title statement) groups information about the title of a work and those responsible for its intellectual
  ##     content.
  element ns1:titleStmt {
    (tei_title+, tei_model.respLike*), tei_att.global.attributes, empty
  }
tei_sponsor =
  
  ## specifies the name of a sponsoring organization or institution.
  element ns1:sponsor {
    tei_macro.phraseSeq.limited, tei_att.global.attributes, empty
  }
tei_funder =
  
  ## (funding body) specifies the name of an individual, institution, or organization responsible for the
  ##     funding of a project or text.
  element ns1:funder {
    tei_macro.phraseSeq.limited, tei_att.global.attributes, empty
  }
tei_principal =
  
  ## (principal researcher) supplies the name of the principal researcher responsible for the
  ## creation of an electronic text.
  element ns1:principal {
    tei_macro.phraseSeq.limited, tei_att.global.attributes, empty
  }
tei_editionStmt =
  
  ## (edition statement) groups information relating to one edition of a text.
  element ns1:editionStmt {
    (tei_model.pLike+ | (tei_edition, tei_respStmt*)),
    tei_att.global.attributes,
    empty
  }
tei_edition =
  
  ## (edition) describes the particularities of one edition of a text.
  element ns1:edition {
    tei_macro.phraseSeq, tei_att.global.attributes, empty
  }
tei_extent =
  
  ## describes the approximate size of a text as stored on some carrier medium, whether digital
  ##     or non-digital, specified in any convenient units.
  element ns1:extent {
    tei_macro.phraseSeq, tei_att.global.attributes, empty
  }
tei_publicationStmt =
  
  ## (publication statement) groups information concerning the publication or distribution of an electronic or other
  ##     text. 
  element ns1:publicationStmt {
    (tei_model.pLike+ | tei_model.publicationStmtPart+),
    tei_att.global.attributes,
    empty
  }
tei_distributor =
  
  ## supplies the name of a person or other agency responsible for the
  ## distribution of a text.
  element ns1:distributor {
    tei_macro.phraseSeq, tei_att.global.attributes, empty
  }
tei_authority =
  
  ## (release authority) supplies the name of a person or other agency responsible for
  ##   making an electronic file available, other than a publisher or
  ##   distributor.
  element ns1:authority {
    tei_macro.phraseSeq.limited, tei_att.global.attributes, empty
  }
tei_idno =
  
  ## (identifier) supplies any form of identifier used to identify some object,
  ##   such as a bibliographic item, a person, a title, an organization,
  ##   etc. in a standardized way.
  element ns1:idno {
    tei_macro.xtext,
    tei_att.global.attributes,
    
    ## categorizes the identifier, for example as an ISBN, Social
    ##       Security number, etc. 
    attribute type { tei_data.enumerated }?,
    empty
  }
tei_availability =
  
  ## supplies information about the availability of a text, for example any restrictions on its
  ##     use or distribution, its copyright status, etc.
  element ns1:availability {
    tei_model.pLike+,
    tei_att.global.attributes,
    tei_att.declarable.attributes,
    
    ## supplies a code identifying the current availability of the text. 
    [ a:defaultValue = "unknown" ]
    attribute status {
      
      ## the text is freely available. 
      "free"
      | 
        ## the status of the text is unknown. 
        "unknown"
      | 
        ## the text is not freely available. 
        "restricted"
    }?,
    empty
  }
tei_seriesStmt =
  
  ## (series statement) groups information about the series, if any, to which a publication belongs.
  element ns1:seriesStmt {
    (tei_model.pLike+
     | (tei_title+, (tei_idno | tei_respStmt)*)),
    tei_att.global.attributes,
    empty
  }
tei_notesStmt =
  
  ## (notes statement) collects together any notes providing information about a text additional to that recorded
  ##     in other parts of the bibliographic description.
  element ns1:notesStmt {
    tei_model.noteLike+, tei_att.global.attributes, empty
  }
tei_sourceDesc =
  
  ## (source description) describes the source from which an electronic text was derived or generated, typically a
  ##     bibliographic description in the case of a digitized text, or a phrase such as "born digital"
  ##     for a text which has no previous existence.
  element ns1:sourceDesc {
    (tei_model.pLike+
     | (tei_model.biblLike
        | tei_model.sourceDescPart
        | tei_model.listLike)+),
    tei_att.global.attributes,
    tei_att.declarable.attributes,
    empty
  }
tei_biblFull =
  
  ## (fully-structured bibliographic citation) contains a fully-structured bibliographic citation, in which all components of the TEI file
  ##     description are present.
  element ns1:biblFull {
    ((tei_titleStmt,
      tei_editionStmt?,
      tei_extent?,
      tei_publicationStmt,
      tei_seriesStmt?,
      tei_notesStmt?),
     tei_sourceDesc*),
    tei_att.global.attributes,
    tei_att.declarable.attributes,
    empty
  }
tei_encodingDesc =
  
  ## (encoding description) documents the relationship between an electronic text and the
  ## source or sources from which it was derived.
  element ns1:encodingDesc {
    (tei_model.encodingDescPart | tei_model.pLike)+,
    tei_att.global.attributes,
    empty
  }
tei_projectDesc =
  
  ## (project description) describes in detail the aim or purpose for which an electronic file was encoded, together
  ##     with any other relevant information concerning the process by which it was assembled or
  ##     collected.
  element ns1:projectDesc {
    tei_model.pLike+,
    tei_att.global.attributes,
    tei_att.declarable.attributes,
    empty
  }
tei_samplingDecl =
  
  ## (sampling declaration) contains a prose description of the rationale and methods used in sampling texts in the
  ##     creation of a corpus or collection.
  element ns1:samplingDecl {
    tei_model.pLike+,
    tei_att.global.attributes,
    tei_att.declarable.attributes,
    empty
  }
tei_editorialDecl =
  
  ## (editorial practice declaration) provides details of editorial principles and practices applied
  ## during the encoding of a text.
  element ns1:editorialDecl {
    (tei_model.pLike | tei_model.editorialDeclPart)+,
    tei_att.global.attributes,
    tei_att.declarable.attributes,
    empty
  }
tei_correction =
  
  ## (correction principles) states how and under what circumstances corrections have been made in the text.
  element ns1:correction {
    tei_model.pLike+,
    tei_att.global.attributes,
    tei_att.declarable.attributes,
    
    ## indicates the degree of correction applied to the text. 
    [ a:defaultValue = "unknown" ]
    attribute status {
      
      ## the text has been thoroughly checked and proofread. 
      "high"
      | 
        ## the text has been checked at least once. 
        "medium"
      | 
        ## the text has not been checked. 
        "low"
      | 
        ## the correction status of the text is unknown. 
        "unknown"
    }?,
    
    ## indicates the method adopted to indicate corrections within the text. 
    [ a:defaultValue = "silent" ]
    attribute method {
      
      ## corrections have been made silently 
      "silent"
      | 
        ## corrections have been represented using markup
        "markup"
    }?,
    empty
  }
tei_normalization =
  
  ## indicates the extent of normalization or regularization of the original source carried out
  ##     in converting it to electronic form.
  element ns1:normalization {
    tei_model.pLike+,
    tei_att.global.attributes,
    tei_att.declarable.attributes,
    
    ## indicates the authority for any normalization carried out. 
    attribute source { tei_data.pointer }?,
    
    ## indicates the method adopted to indicate normalizations within the text. 
    [ a:defaultValue = "silent" ]
    attribute method {
      
      ## normalization made silently 
      "silent"
      | 
        ## normalization represented using markup 
        "markup"
    }?,
    empty
  }
tei_quotation =
  
  ## specifies editorial practice adopted with respect to quotation marks in the original. 
  element ns1:quotation {
    tei_model.pLike+,
    tei_att.global.attributes,
    tei_att.declarable.attributes,
    
    ## (quotation marks) indicates whether or not quotation marks have been retained as content within the text. 
    [ a:defaultValue = "all" ]
    attribute marks {
      
      ## no quotation marks have been retained 
      "none"
      | 
        ## some quotation marks have been retained 
        "some"
      | 
        ## all quotation marks have been retained 
        "all"
    }?,
    
    ## specifies how quotation marks are indicated within the text.
    [ a:defaultValue = "unknown" ] attribute form { text }?,
    empty
  }
tei_hyphenation =
  
  ## summarizes the way in which hyphenation in a source text has been treated in an encoded
  ##     version of it.
  element ns1:hyphenation {
    tei_model.pLike+,
    tei_att.global.attributes,
    tei_att.declarable.attributes,
    
    ## (end-of-line) indicates whether or not end-of-line hyphenation has been retained in a text.
    [ a:defaultValue = "some" ]
    attribute eol {
      
      ## all end-of-line hyphenation has been retained, even though the lineation of the
      ##             original may not have been. 
      "all"
      | 
        ## end-of-line hyphenation has been retained in some cases. 
        "some"
      | 
        ## all soft end-of-line hyphenation has been removed: any remaining end-od-line
        ##             hyphenation should be retained. 
        "hard"
      | 
        ## all end-of-line hyphenation has been removed: any remaining hyphenation occurred
        ##             within the line. 
        "none"
    }?,
    empty
  }
tei_segmentation =
  
  ## describes the principles according to which the text has been segmented, for example into
  ##     sentences, tone-units, graphemic strata, etc.
  element ns1:segmentation {
    tei_model.pLike+,
    tei_att.global.attributes,
    tei_att.declarable.attributes,
    empty
  }
tei_stdVals =
  
  ## (standard values) specifies the format used when standardized date or number values are supplied.
  element ns1:stdVals {
    tei_model.pLike+,
    tei_att.global.attributes,
    tei_att.declarable.attributes,
    empty
  }
tei_interpretation =
  
  ## describes the scope of any analytic or interpretive information added to the text in
  ##     addition to the transcription. 
  element ns1:interpretation {
    tei_model.pLike+,
    tei_att.global.attributes,
    tei_att.declarable.attributes,
    empty
  }
tei_tagsDecl =
  
  ## (tagging declaration) provides detailed information about the tagging applied to a document.
  element ns1:tagsDecl {
    (tei_rendition*, tei_namespace*), tei_att.global.attributes, empty
  }
tei_tagUsage =
  
  ## supplies information about the usage of a specific element within a text. 
  element ns1:tagUsage {
    tei_macro.limitedContent,
    tei_att.global.attributes,
    
    ## (element name) the name (generic identifier) of the element indicated by the tag.
    attribute gi { tei_data.name },
    
    ## specifies the number of occurrences of this element within the text.
    attribute occurs { tei_data.count }?,
    
    ## (with unique identifier) specifies the number of occurrences of this element within the text which bear a
    ##         distinct value for the global xml:id attribute. 
    attribute withId { tei_data.count }?,
    
    ## specifies the identifier of a rendition element which defines how this element
    ##         is to be rendered.
    attribute render { tei_data.pointer }?,
    empty
  }
tei_namespace =
  
  ## supplies the formal name of the namespace to which the elements documented by its children
  ##     belong. 
  element ns1:namespace {
    tei_tagUsage+,
    tei_att.global.attributes,
    
    ## the full formal name of the namespace concerned.
    attribute name { tei_data.namespace },
    empty
  }
tei_rendition =
  
  ## supplies information about the rendition or appearance of one or more elements in the source
  ##     text.
  element ns1:rendition {
    tei_macro.limitedContent,
    tei_att.global.attributes,
    
    ## identifies the language used to describe the rendition.
    attribute scheme {
      
      ## Cascading Stylesheet Language
      "css"
      | 
        ## Extensible Stylesheet Language Formatting Objects
        "xslfo"
      | 
        ## Informal free text description
        "free"
      | 
        ## A user-defined rendition description language
        "other"
    }?,
    
    ## where CSS is used, provides a way of defining
    ## pseudo-elements, that is, styling rules
    ## applicable to specific sub-portions of an element.
    attribute scope { text }?,
    empty
  }
tei_refsDecl =
  
  ## (references declaration) specifies how canonical references are constructed for this
  ##   text.
  element ns1:refsDecl {
    (tei_model.pLike+ | tei_cRefPattern+ | tei_refState+),
    tei_att.global.attributes,
    tei_att.declarable.attributes,
    empty
  }
tei_cRefPattern =
  
  ## (canonical reference pattern) specifies an expression and replacement pattern for transforming a canonical reference into
  ##     a URI. 
  element ns1:cRefPattern {
    tei_model.pLike*,
    tei_att.global.attributes,
    
    ## specifies a regular expression against which the values of cRef attributes
    ##         can be matched.
    attribute matchPattern { tei_data.pattern },
    
    ## specifies a replacement pattern which, once subpattern substitution
    ##         has been performed, provides a URI.
    attribute replacementPattern { text },
    empty
  }
tei_refState =
  
  ## (reference state) specifies one component of a canonical reference defined by the milestone method.
  element ns1:refState {
    empty,
    tei_att.global.attributes,
    tei_att.sourced.attributes,
    
    ## indicates what kind of state is changing at this milestone.
    ## Suggested values include: 1] page; 2] column; 3] line; 4] book; 5] poem; 6] canto; 7] stanza; 8] act; 9] scene; 10] section; 11] absent
    attribute unit {
      
      ## page breaks in the reference edition. 
      "page"
      | 
        ## column breaks. 
        "column"
      | 
        ## line breaks. 
        "line"
      | 
        ## any units termed book, liber, etc. 
        "book"
      | 
        ## individual poems in a collection. 
        "poem"
      | 
        ## cantos or other major sections of a poem. 
        "canto"
      | 
        ## stanzas within a poem, book, or canto. 
        "stanza"
      | 
        ## acts within a play. 
        "act"
      | 
        ## scenes within a play or act. 
        "scene"
      | 
        ## sections of any kind. 
        "section"
      | 
        ## passages not present in the reference edition.
        "absent"
      | xsd:Name
    },
    
    ## specifies the fixed length of the reference component.
    attribute length { tei_data.count }?,
    
    ## (delimiter) supplies a delimiting string following the reference component.
    attribute delim { text }?,
    empty
  }
tei_classDecl =
  
  ## (classification declarations) contains one or more taxonomies defining any classificatory
  ## codes used elsewhere in the text.
  element ns1:classDecl {
    tei_taxonomy+, tei_att.global.attributes, empty
  }
tei_taxonomy =
  
  ## defines a typology used to classify texts either implicitly, by means of a bibliographic
  ##     citation, or explicitly by a structured taxonomy.
  element ns1:taxonomy {
    (tei_model.glossLike*
     | tei_category+
     | (tei_model.biblLike, tei_category*)),
    tei_att.global.attributes,
    empty
  }
tei_category =
  
  ## contains an individual descriptive category, possibly nested within a superordinate
  ##     category, within a user-defined taxonomy.
  element ns1:category {
    ((tei_catDesc+ | tei_model.glossLike*), tei_category*),
    tei_att.global.attributes,
    empty
  }
tei_catDesc =
  
  ## (category description) describes some category within a taxonomy or text typology, either in the form of a brief
  ##     prose description or in terms of the situational parameters used by the TEI formal textDesc.
  element ns1:catDesc {
    (text | tei_model.limitedPhrase | tei_model.catDescPart)*,
    tei_att.global.attributes,
    empty
  }
tei_appInfo =
  
  ## (application information) records information about an application which has
  ##   edited the TEI file. 
  element ns1:appInfo {
    tei_model.applicationLike+, tei_att.global.attributes, empty
  }
tei_application =
  
  ## provides information about an application which has acted upon the document.
  element ns1:application {
    (tei_model.labelLike+, (tei_model.ptrLike* | tei_model.pLike*)),
    tei_att.global.attributes,
    tei_att.typed.attributes,
    tei_att.datable.attributes,
    
    ## Supplies an identifier for the application, independent of its version number or display
    ##         name.
    attribute ident { tei_data.name },
    
    ## Supplies a version number for the application, independent of its identifier or display
    ##         name.
    attribute version {
      xsd:token {
        pattern = "[\d]+[a-z]*[\d]*(\.[\d]+[a-z]*[\d]*){0,3}"
      }
    },
    empty
  }
tei_profileDesc =
  
  ## (text-profile description) provides a detailed description of non-bibliographic aspects of a text, specifically the
  ##     languages and sublanguages used, the situation in which it was produced, the participants and
  ##     their setting.
  element ns1:profileDesc {
    tei_model.profileDescPart*, tei_att.global.attributes, empty
  }
tei_creation =
  
  ## contains information about the creation of a text.
  element ns1:creation {
    tei_macro.phraseSeq.limited, tei_att.global.attributes, empty
  }
tei_langUsage =
  
  ## (language usage) describes the languages, sublanguages, registers, dialects, etc.
  ## represented within a text.
  element ns1:langUsage {
    tei_language+,
    tei_att.global.attributes,
    tei_att.declarable.attributes,
    empty
  }
tei_language =
  
  ## characterizes a single language or sublanguage used within a text.
  element ns1:language {
    tei_macro.phraseSeq.limited,
    tei_att.global.attributes,
    
    ## (identifier) Supplies a language code constructed as defined in BCP 47 which is used to identify the
    ##         language documented by this element, and which is referenced by the global
    ##         xml:lang attribute.
    attribute ident { tei_data.language },
    
    ## specifies the approximate percentage (by volume) of the text which uses this language. 
    attribute usage {
      xsd:nonNegativeInteger { maxInclusive = "100" }
    }?,
    empty
  }
tei_textClass =
  
  ## (text classification) groups information which describes the nature or topic of a text in terms of a standard
  ##     classification scheme, thesaurus, etc.
  element ns1:textClass {
    (tei_classCode | tei_catRef | tei_keywords)*,
    tei_att.global.attributes,
    tei_att.declarable.attributes,
    empty
  }
tei_keywords =
  
  ## contains a list of keywords or phrases identifying the topic or nature of a text.
  element ns1:keywords {
    (tei_term+ | tei_list),
    tei_att.global.attributes,
    
    ## identifies the controlled vocabulary within which the set of keywords concerned is
    ##         defined. 
    attribute scheme { tei_data.pointer },
    empty
  }
tei_classCode =
  
  ## (classification code) contains the classification code used for this text in some standard classification system.
  element ns1:classCode {
    tei_macro.phraseSeq.limited,
    tei_att.global.attributes,
    
    ## identifies the classification system or taxonomy in use.
    attribute scheme { tei_data.pointer },
    empty
  }
tei_catRef =
  
  ## (category reference) specifies one or more defined categories within some taxonomy or text typology.
  element ns1:catRef {
    empty,
    tei_att.global.attributes,
    tei_att.pointing.attributes,
    
    ## identifies the classification scheme within which the set of categories concerned is
    ##         defined 
    attribute scheme { tei_data.pointer }?,
    empty
  }
tei_revisionDesc =
  
  ## (revision description) summarizes the revision history for a file.
  element ns1:revisionDesc {
    (tei_list | tei_change+),
    tei_att.global.attributes,
    tei_att.docStatus.attributes,
    empty
  }
tei_change =
  
  ## summarizes a particular change or correction made to a particular version of an electronic
  ##     text which is shared between several researchers.
  element ns1:change {
    (text
     | tei_model.limitedPhrase
     | tei_model.inter
     | tei_model.global)*,
    tei_att.global.attributes,
    tei_att.ascribed.attributes,
    tei_att.datable.attributes,
    tei_att.docStatus.attributes,
    empty
  }
tei_geoDecl =
  
  ## (geographic coordinates declaration) documents the notation and the datum used for geographic coordinates expressed as content of
  ##     the geo element elsewhere within the document.
  element ns1:geoDecl {
    tei_macro.phraseSeq,
    tei_att.global.attributes,
    tei_att.declarable.attributes,
    
    ## supplies a commonly used code name for the datum employed.
    ## Suggested values include: 1] WGS84(World Geodetic System) ; 2] MGRS(Military Grid Reference System) ; 3] OSGB36(ordnance survey great britain) ; 4] ED50(European Datum coordinate system) 
    [ a:defaultValue = "WGS84" ]
    attribute datum {
      
      ## (World Geodetic System) a pair of numbers to be interpreted as latitude followed by longitude according to
      ##             the World Geodetic System.
      "WGS84"
      | 
        ## (Military Grid Reference System) the values supplied are geospatial entity object codes, based on
        "MGRS"
      | 
        ## (ordnance survey great britain) the value supplied is to be interpreted as a British National Grid Reference.
        "OSGB36"
      | 
        ## (European Datum coordinate system) the value supplied is to be interpreted as latitude followed by longitude according
        ##             to the European Datum coordinate system.
        "ED50"
      | xsd:Name
    }?,
    empty
  }
tei_TEI =
  
  ## (TEI document) contains a single TEI-conformant document,
  ## comprising a TEI header and a text, either in isolation or as part of a
  ## teiCorpus element.
  element ns1:TEI {
    (tei_teiHeader,
     ((tei_model.resourceLike+, tei_text?) | tei_text))
    >> sch:ns [ prefix = "tei" uri = "http://www.tei-c.org/ns/1.0" ]
    >> sch:ns [
         prefix = "rng"
         uri = "http://relaxng.org/ns/structure/1.0"
       ],
    tei_att.global.attributes,
    
    ## specifies the version number of the TEI Guidelines against
    ##       which this document is valid.
    attribute version { tei_data.version }?,
    empty
  }
tei_text =
  
  ## contains a single text of any kind, whether unitary or composite, for example a poem or
  ##     drama, a collection of essays, a novel, a dictionary, or a corpus sample.
  element ns1:text {
    (tei_model.global*,
     (tei_front, tei_model.global*)?,
     (tei_body | tei_group),
     tei_model.global*,
     (tei_back, tei_model.global*)?),
    tei_att.global.attributes,
    tei_att.declaring.attributes,
    tei_att.typed.attributes,
    empty
  }
tei_body =
  
  ## (text body) contains the whole body of a single unitary text, excluding any front or back matter.
  element ns1:body {
    (tei_model.global*,
     (tei_model.divTop, (tei_model.global | tei_model.divTop)*)?,
     (tei_model.divGenLike,
      (tei_model.global | tei_model.divGenLike)*)?,
     ((tei_model.divLike, (tei_model.global | tei_model.divGenLike)*)+
      | (tei_model.div1Like,
         (tei_model.global | tei_model.divGenLike)*)+
      | ((tei_model.common, tei_model.global*)+,
         ((tei_model.divLike,
           (tei_model.global | tei_model.divGenLike)*)+
          | (tei_model.div1Like,
             (tei_model.global | tei_model.divGenLike)*)+)?)),
     (tei_model.divBottom, tei_model.global*)*),
    tei_att.global.attributes,
    tei_att.declaring.attributes,
    empty
  }
tei_group =
  
  ## contains the body of a composite text, grouping together a sequence of distinct texts (or
  ##     groups of such texts) which are regarded as a unit for some purpose, for example the collected
  ##     works of an author, a sequence of prose essays, etc.
  element ns1:group {
    ((tei_model.divTop | tei_model.global)*,
     ((tei_text | tei_group),
      (tei_text | tei_group | tei_model.global)*),
     tei_model.divBottom*),
    tei_att.global.attributes,
    tei_att.declaring.attributes,
    empty
  }
tei_floatingText =
  
  ## contains a single text of any kind, whether unitary or composite, which interrupts the text
  ##     containing it at any point and after which the surrounding text resumes.
  element ns1:floatingText {
    (tei_model.global*,
     (tei_front, tei_model.global*)?,
     (tei_body | tei_group),
     tei_model.global*,
     (tei_back, tei_model.global*)?),
    tei_att.global.attributes,
    tei_att.declaring.attributes,
    tei_att.typed.attributes,
    empty
  }
tei_div =
  
  ## (text division) contains a subdivision of the front, body, or back of a text.
  element ns1:div {
    ((tei_model.divTop | tei_model.global)*,
     ((((tei_model.divLike | tei_model.divGenLike), tei_model.global*)+
       | ((tei_model.common, tei_model.global*)+,
          ((tei_model.divLike | tei_model.divGenLike),
           tei_model.global*)*)),
      (tei_model.divBottom, tei_model.global*)*)?),
    tei_att.global.attributes,
    tei_att.divLike.attributes,
    tei_att.typed.attributes,
    tei_att.declaring.attributes,
    empty
  }
tei_div1 =
  
  ## (level-1 text division) contains a first-level subdivision of the front, body, or back of a text.
  element ns1:div1 {
    ((tei_model.divTop | tei_model.global)*,
     ((((tei_model.div2Like | tei_model.divGenLike), tei_model.global*)+
       | ((tei_model.common, tei_model.global*)+,
          ((tei_model.div2Like | tei_model.divGenLike),
           tei_model.global*)*)),
      (tei_model.divBottom, tei_model.global*)*)?),
    tei_att.global.attributes,
    tei_att.divLike.attributes,
    tei_att.typed.attributes,
    tei_att.declaring.attributes,
    empty
  }
tei_div2 =
  
  ## (level-2 text division) contains a second-level subdivision of the front, body, or back of a
  ##  text.
  element ns1:div2 {
    ((tei_model.divTop | tei_model.global)*,
     ((((tei_model.div3Like | tei_model.divGenLike), tei_model.global*)+
       | ((tei_model.common, tei_model.global*)+,
          ((tei_model.div3Like | tei_model.divGenLike),
           tei_model.global*)*)),
      (tei_model.divBottom, tei_model.global*)*)?),
    tei_att.global.attributes,
    tei_att.divLike.attributes,
    tei_att.typed.attributes,
    tei_att.declaring.attributes,
    empty
  }
tei_div3 =
  
  ## (level-3 text division) contains a third-level subdivision of the front, body, or back of a text.
  element ns1:div3 {
    ((tei_model.divTop | tei_model.global)*,
     ((((tei_model.div4Like | tei_model.divGenLike), tei_model.global*)+
       | ((tei_model.common, tei_model.global*)+,
          ((tei_model.div4Like | tei_model.divGenLike),
           tei_model.global*)*)),
      (tei_model.divBottom, tei_model.global*)*)?),
    tei_att.global.attributes,
    tei_att.divLike.attributes,
    tei_att.typed.attributes,
    tei_att.declaring.attributes,
    empty
  }
tei_div4 =
  
  ## (level-4 text division) contains a fourth-level subdivision of the front, body, or back of a text.
  element ns1:div4 {
    ((tei_model.divTop | tei_model.global)*,
     ((((tei_model.div5Like | tei_model.divGenLike), tei_model.global*)+
       | ((tei_model.common, tei_model.global*)+,
          ((tei_model.div5Like | tei_model.divGenLike),
           tei_model.global*)*)),
      (tei_model.divBottom, tei_model.global*)*)?),
    tei_att.global.attributes,
    tei_att.divLike.attributes,
    tei_att.typed.attributes,
    tei_att.declaring.attributes,
    empty
  }
tei_div5 =
  
  ## (level-5 text division) contains a fifth-level subdivision of the front, body, or back of a text.
  element ns1:div5 {
    ((tei_model.divTop | tei_model.global)*,
     ((((tei_model.div6Like | tei_model.divGenLike), tei_model.global*)+
       | ((tei_model.common, tei_model.global*)+,
          ((tei_model.div6Like | tei_model.divGenLike),
           tei_model.global*)*)),
      (tei_model.divBottom, tei_model.global*)*)?),
    tei_att.global.attributes,
    tei_att.divLike.attributes,
    tei_att.typed.attributes,
    tei_att.declaring.attributes,
    empty
  }
tei_div6 =
  
  ## (level-6 text division) contains a sixth-level subdivision of the front, body, or back of a text.
  element ns1:div6 {
    ((tei_model.divTop | tei_model.global)*,
     ((((tei_model.div7Like | tei_model.divGenLike), tei_model.global*)+
       | ((tei_model.common, tei_model.global*)+,
          ((tei_model.div7Like | tei_model.divGenLike),
           tei_model.global*)*)),
      (tei_model.divBottom, tei_model.global*)*)?),
    tei_att.global.attributes,
    tei_att.divLike.attributes,
    tei_att.typed.attributes,
    tei_att.declaring.attributes,
    empty
  }
tei_div7 =
  
  ## (level-7 text division) contains the smallest possible subdivision of the front, body or back of a text, larger than
  ##     a paragraph.
  element ns1:div7 {
    ((tei_model.divTop | tei_model.global)*,
     ((tei_model.common, tei_model.global*)+,
      (tei_model.divBottom, tei_model.global*)*)?),
    tei_att.global.attributes,
    tei_att.divLike.attributes,
    tei_att.typed.attributes,
    tei_att.declaring.attributes,
    empty
  }
tei_trailer =
  
  ## contains a closing title or footer appearing at the end of a division of a text. 
  element ns1:trailer {
    tei_macro.phraseSeq, tei_att.global.attributes, empty
  }
tei_byline =
  
  ## contains the primary statement of responsibility given for a work
  ## on its title page or at the head or end of the work.
  element ns1:byline {
    (text
     | tei_model.gLike
     | tei_model.phrase
     | tei_docAuthor
     | tei_model.global)*,
    tei_att.global.attributes,
    empty
  }
tei_dateline =
  
  ## contains a brief description of the place, date, time, etc. of production of a letter,
  ##     newspaper story, or other work, prefixed or suffixed to it as a kind of heading or trailer. 
  element ns1:dateline {
    tei_macro.phraseSeq, tei_att.global.attributes, empty
  }
tei_argument =
  
  ## A formal list or prose description of the topics addressed by
  ##	a subdivision of a text.
  element ns1:argument {
    ((tei_model.global | tei_model.headLike)*,
     (tei_model.common, tei_model.global*)+),
    tei_att.global.attributes,
    empty
  }
tei_epigraph =
  
  ## contains a quotation, anonymous or attributed, appearing at the start of a section or
  ##     chapter, or on a title page. 
  element ns1:epigraph {
    (tei_model.common | tei_model.global)*,
    tei_att.global.attributes,
    empty
  }
tei_opener =
  
  ## groups together dateline, byline, salutation, and similar phrases appearing as a preliminary
  ##     group at the start of a division, especially of a letter.
  element ns1:opener {
    (text
     | tei_model.gLike
     | tei_model.phrase
     | tei_argument
     | tei_byline
     | tei_dateline
     | tei_epigraph
     | tei_salute
     | tei_signed
     | tei_model.global)*,
    tei_att.global.attributes,
    empty
  }
tei_closer =
  
  ## groups together salutations, datelines, and similar phrases appearing as a final group at
  ##     the end of a division, especially of a letter.
  element ns1:closer {
    (text
     | tei_model.gLike
     | tei_signed
     | tei_dateline
     | tei_salute
     | tei_model.phrase
     | tei_model.global)*,
    tei_att.global.attributes,
    empty
  }
tei_salute =
  
  ## (salutation) contains a salutation or greeting prefixed to a foreword, dedicatory epistle, or other
  ##     division of a text, or the salutation in the closing of a letter, preface, etc.
  element ns1:salute {
    tei_macro.phraseSeq, tei_att.global.attributes, empty
  }
tei_signed =
  
  ## (signature) contains the closing salutation, etc., appended to a foreword,
  ## dedicatory epistle, or other division of a text. 
  element ns1:signed {
    tei_macro.phraseSeq, tei_att.global.attributes, empty
  }
tei_postscript =
  
  ## contains a postscript, e.g. to a letter.
  element ns1:postscript {
    (tei_model.common | tei_model.global)*,
    tei_att.global.attributes,
    empty
  }
tei_titlePage =
  
  ## (title page) contains the title page of a text, appearing within the front or back matter. 
  element ns1:titlePage {
    (tei_model.global*,
     tei_model.titlepagePart,
     (tei_model.titlepagePart | tei_model.global)*),
    tei_att.global.attributes,
    
    ## classifies the title page according to any convenient typology.
    attribute type { tei_data.enumerated }?,
    empty
  }
tei_docTitle =
  
  ## (document title) contains the title of a document, including all its
  ## constituents, as given on a title page.
  element ns1:docTitle {
    (tei_model.global*, (tei_titlePart, tei_model.global*)+),
    tei_att.global.attributes,
    tei_att.canonical.attributes,
    empty
  }
tei_titlePart =
  
  ## contains a subsection or division of the title of a work, as
  ## indicated on a title page.
  element ns1:titlePart {
    tei_macro.paraContent,
    tei_att.global.attributes,
    
    ## specifies the role of this subdivision of the title.
    ## Suggested values include: 1] main; 2] sub(subordinate) ; 3] alt(alternate) ; 4] short; 5] desc(descriptive) 
    [ a:defaultValue = "main" ]
    attribute type {
      
      ## main title of the work
      ##         
      "main"
      | 
        ## (subordinate) subtitle  of the work
        ##         
        "sub"
      | 
        ## (alternate) alternative title  of the work
        ##         
        "alt"
      | 
        ## abbreviated form of title
        "short"
      | 
        ## (descriptive) descriptive paraphrase of the work 
        ##    
        "desc"
      | xsd:Name
    }?,
    empty
  }
tei_docAuthor =
  
  ## (document author) contains the name of the author of the document, as given on the
  ## title page (often but not always contained in a byline).
  element ns1:docAuthor {
    tei_macro.phraseSeq,
    tei_att.global.attributes,
    tei_att.canonical.attributes,
    empty
  }
tei_imprimatur =
  
  ## contains a formal statement authorizing the publication of a work, sometimes required to
  ##     appear on a title page or its verso.
  element ns1:imprimatur {
    tei_macro.paraContent, tei_att.global.attributes, empty
  }
tei_docEdition =
  
  ## (document edition) contains an edition statement as presented on a title page of a
  ## document.
  element ns1:docEdition {
    tei_macro.paraContent, tei_att.global.attributes, empty
  }
tei_docImprint =
  
  ## (document imprint) contains the imprint statement (place and date of publication,
  ## publisher name), as given
  ## (usually) at the foot of a title page.
  element ns1:docImprint {
    (text
     | tei_model.gLike
     | tei_model.phrase
     | tei_pubPlace
     | tei_docDate
     | tei_publisher
     | tei_model.global)*,
    tei_att.global.attributes,
    empty
  }
tei_docDate =
  
  ## (document date) contains the date of a document, as given
  ## (usually) on a title page.
  element ns1:docDate {
    tei_macro.phraseSeq,
    tei_att.global.attributes,
    
    ## gives the value of the date in standard form, i.e. YYYY-MM-DD.
    attribute when { tei_data.temporal.w3c }?,
    empty
  }
tei_front =
  
  ## (front matter) contains any prefatory matter (headers,
  ## title page, prefaces, dedications, etc.)
  ## found  at the start of a document, before the main body.
  element ns1:front {
    ((tei_model.frontPart | tei_model.pLike.front | tei_model.global)*,
     ((tei_model.div1Like,
       (tei_model.frontPart | tei_model.div1Like | tei_model.global)*)
      | (tei_model.divLike,
         (tei_model.frontPart
          | tei_model.divLike
          | tei_model.global)*))?,
     (tei_model.divBottomPart,
      (tei_model.divBottomPart | tei_model.global)*)?),
    tei_att.global.attributes,
    tei_att.declaring.attributes,
    empty
  }
tei_back =
  
  ## (back matter) contains any appendixes, etc. following the main part of a text.
  element ns1:back {
    ((tei_model.frontPart | tei_model.pLike.front | tei_model.global)*,
     ((tei_model.div1Like,
       (tei_model.frontPart | tei_model.div1Like | tei_model.global)*)
      | (tei_model.divLike,
         (tei_model.frontPart
          | tei_model.divLike
          | tei_model.global)*))?,
     (tei_model.divBottomPart,
      (tei_model.divBottomPart | tei_model.global)*)?),
    tei_att.global.attributes,
    tei_att.declaring.attributes,
    empty
  }
tei_table =
  
  ## contains text displayed in tabular form, in rows and columns.
  element ns1:table {
    ((tei_model.headLike | tei_model.global)*,
     (tei_row, tei_model.global*)+),
    tei_att.global.attributes,
    
    ## indicates the number of rows in the table.
    attribute rows { tei_data.count }?,
    
    ## (columns) indicates the number of columns in each row of the table.
    attribute cols { tei_data.count }?,
    empty
  }
tei_row =
  
  ## contains one row of a table. 
  element ns1:row {
    tei_cell+,
    tei_att.global.attributes,
    tei_att.tableDecoration.attributes,
    empty
  }
tei_cell =
  
  ## contains one cell of a table. 
  element ns1:cell {
    tei_macro.paraContent,
    tei_att.global.attributes,
    tei_att.tableDecoration.attributes,
    empty
  }
tei_formula =
  
  ## contains a mathematical or other formula.
  element ns1:formula {
    (text | tei_model.graphicLike)*,
    tei_att.global.attributes,
    
    ## supplies the name of a previously defined notation used for the content of the element.
    attribute notation { tei_data.code }?,
    empty
  }
tei_figure =
  
  ## groups elements representing or containing graphic information such as an illustration or
  ##     figure.
  element ns1:figure {
    (tei_model.headLike
     | tei_model.pLike
     | tei_figDesc
     | tei_model.graphicLike
     | tei_model.egLike
     | tei_floatingText
     | tei_model.global)*,
    tei_att.global.attributes,
    tei_att.placement.attributes,
    tei_att.typed.attributes,
    empty
  }
tei_figDesc =
  
  ## (description of figure) contains a brief prose description of the appearance or content
  ## of a graphic figure, for use when documenting an image without
  ## displaying it.
  element ns1:figDesc {
    tei_macro.limitedContent, tei_att.global.attributes, empty
  }
start = tei_TEI | tei_teiCorpus
