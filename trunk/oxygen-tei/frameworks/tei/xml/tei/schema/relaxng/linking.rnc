namespace a = "http://relaxng.org/ns/compatibility/annotations/1.0"
namespace rng = "http://relaxng.org/ns/structure/1.0"
namespace sch = "http://purl.oclc.org/dsdl/schematron"

# Schema generated 2011-03-05T14:52:51Z
# Edition: 1.9.1. Last updated on March 5th 2011.
# 
# 
# Copyright 2011 TEI Consortium.
# 
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public License as
# published by the Free Software Foundation; either version 2.1 of the
# License, or (at your option) any later version. This library is
# distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
# without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
# PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
# details. You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
# 
# 
# 
# For information about the TEI, including contact
#		details, consult the TEI web
#	      site at http://www.tei-c.org/. 
# 
# 
#	 Linking, segmentation and alignment

# Definitions from module linking

# Set global predeclared macros

# Set predeclared macros

# 0. predeclared macros

# 1. classes
att.global.linking.attributes =
  att.global.linking.attribute.corresp,
  att.global.linking.attribute.synch,
  att.global.linking.attribute.sameAs,
  att.global.linking.attribute.copyOf,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  att.global.linking.attribute.exclude,
  att.global.linking.attribute.select
att.global.linking.attribute.corresp =
  
  ## (corresponds) points to elements that correspond to the current
  ##       element in some way.
  attribute corresp {
    list { data.pointer, data.pointer* }
  }?
att.global.linking.attribute.synch =
  
  ## (synchronous) points to elements that are synchronous with the current
  ##       element.
  attribute synch {
    list { data.pointer, data.pointer* }
  }?
att.global.linking.attribute.sameAs =
  
  ## points to an element that is the same as the current
  ##       element.
  attribute sameAs { data.pointer }?
att.global.linking.attribute.copyOf =
  
  ## points to an element of which the current element is a
  ##	copy.
  attribute copyOf { data.pointer }?
att.global.linking.attribute.next =
  
  ## points to the next element of a virtual aggregate of which
  ##       the current element is part.
  attribute next { data.pointer }?
att.global.linking.attribute.prev =
  
  ## (previous) points to the previous element of a virtual aggregate of
  ##       which the current element is part.
  attribute prev { data.pointer }?
att.global.linking.attribute.exclude =
  
  ## points to elements that are in exclusive alternation
  ##       with the current element.
  attribute exclude {
    list { data.pointer, data.pointer* }
  }?
att.global.linking.attribute.select =
  
  ## selects one or more alternants; if one alternant is
  ##       selected, the ambiguity or uncertainty is marked as resolved. If
  ##       more than one alternant is selected, the degree of ambiguity or
  ##       uncertainty is marked as reduced by the number of alternants not
  ##       selected.
  attribute select {
    list { data.pointer, data.pointer* }
  }?
# 2. elements
ab =
  
  ## (anonymous block) contains any arbitrary component-level unit of text, acting as an anonymous container for phrase or inter level elements analogous to, but without the semantic baggage of, a paragraph.
  element ab { ab.content, ab.localattributes }
ab.content = macro.paraContent
ab.localattributes =
  att.global.attributes,
  att.typed.attributes,
  att.declaring.attributes,
  
  ## specifies whether or not the block is complete. 
  [ a:defaultValue = "N" ]
  attribute part {
    
    ## (yes) the block is incomplete
    "Y"
    | 
      ## (no) either the block is complete, or no claim is made as to its completeness
      "N"
    | 
      ## (initial) the initial part of an incomplete block
      "I"
    | 
      ## (medial) a medial part of an incomplete block
      "M"
    | 
      ## (final) the final part of an incomplete block
      "F"
  }?,
  empty
alt =
  
  ## (alternation) identifies an alternation or a set of choices among elements or passages.
  element alt { alt.content, alt.localattributes }
alt.content =
  empty
  >> sch:pattern [
       id = "alt-constraint-altTargets1"
       "\x{a}" ~
       "         "
       sch:rule [
         context = "tei:alt"
         "\x{a}" ~
         "            "
         sch:report [
           test = "@target and @targets"
           "You may not supply both \x{a}" ~
           "	@target and @targets"
         ]
         "\x{a}" ~
         "         "
       ]
       "\x{a}" ~
       "      "
     ]
  >> sch:pattern [
       id = "alt-constraint-altTargets2"
       "\x{a}" ~
       "         "
       sch:rule [
         context = "tei:alt"
         "\x{a}" ~
         "            "
         sch:report [
           test = "not(@target) and not(@targets)"
           "You must\x{a}" ~
           "	supply either @target or @targets"
         ]
         "\x{a}" ~
         "         "
       ]
       "\x{a}" ~
       "      "
     ]
  >> sch:pattern [
       id = "alt-constraint-altTargets3"
       "\x{a}" ~
       "         "
       sch:rule [
         context = "tei:alt"
         "\x{a}" ~
         "            "
         sch:assert [
           test = "contains(@target,' ')"
           "You must supply at least two\x{a}" ~
           "values for @target"
         ]
         "\x{a}" ~
         "         "
       ]
       "\x{a}" ~
       "      "
     ]
alt.localattributes =
  att.global.attributes,
  att.pointing.attributes,
  att.typed.attributes,
  
  ## specifies the identifiers of the alternative elements or passages.
  attribute targets {
    list { data.pointer, data.pointer, data.pointer* }
  }?,
  
  ## states whether the alternations gathered in this collection are exclusive or
  ##                 inclusive.
  attribute mode {
    
    ## (exclusive) indicates that the alternation is exclusive, i.e. that at most one of the
    ##                         alternatives occurs.
    "excl"
    | 
      ## (inclusive) indicates that the alternation is not exclusive, i.e. that one or more of
      ##                         the alternatives occur.
      "incl"
  }?,
  
  ## If mode is , each weight states the probability that
  ##                 the corresponding alternative occurs. If mode is incl each
  ##                 weight states the probability that the corresponding alternative occurs given that
  ##                 at least one of the other alternatives occurs.
  attribute weights {
    list { data.probability, data.probability, data.probability* }
  }?,
  empty
altGrp =
  
  ## (alternation group) groups a collection of alt elements and possibly pointers.
  element altGrp { altGrp.content, altGrp.localattributes }
altGrp.content = (alt | ptr)*
altGrp.localattributes =
  att.global.attributes,
  att.pointing.group.attributes,
  
  ## states whether the alternations gathered in this collection are exclusive or
  ##                 inclusive.
  [ a:defaultValue = "excl" ]
  attribute mode {
    
    ## (exclusive) indicates that the alternation is exclusive, i.e. that at most one of the
    ##                         alternatives occurs.
    "excl"
    | 
      ## (inclusive) indicates that the alternation is not exclusive, i.e. that one or more of
      ##                         the alternatives occur.
      "incl"
  }?,
  empty
anchor =
  
  ## (anchor point) attaches an identifier to a point within a text, whether or not it corresponds with a textual element.
  element anchor { anchor.content, anchor.localattributes }
anchor.content = empty
anchor.localattributes =
  att.global.attributes, att.typed.attributes, empty
join =
  
  ## identifies a possibly fragmented segment of text, by pointing at the possibly discontiguous elements which compose it.
  element join { join.content, join.localattributes }
join.content =
  (model.glossLike*)
  >> sch:pattern [
       id = "join-constraint-joinTargets1"
       "\x{a}" ~
       "         "
       sch:rule [
         context = "tei:join"
         "\x{a}" ~
         "            "
         sch:report [
           test = "@target and @targets"
           "You may not supply both \x{a}" ~
           "	@target and @targets"
         ]
         "\x{a}" ~
         "         "
       ]
       "\x{a}" ~
       "      "
     ]
  >> sch:pattern [
       id = "join-constraint-joinTargets2"
       "\x{a}" ~
       "         "
       sch:rule [
         context = "tei:join"
         "\x{a}" ~
         "            "
         sch:report [
           test = "not(@target) and not(@targets)"
           "You must\x{a}" ~
           "	supply either @target or @targets"
         ]
         "\x{a}" ~
         "         "
       ]
       "\x{a}" ~
       "      "
     ]
  >> sch:pattern [
       id = "join-constraint-joinTargets3"
       "\x{a}" ~
       "         "
       sch:rule [
         context = "tei:join"
         "\x{a}" ~
         "            "
         sch:assert [
           test = "contains(@target,' ')"
           "You must supply at least two\x{a}" ~
           "values for @target"
         ]
         "\x{a}" ~
         "         "
       ]
       "\x{a}" ~
       "      "
     ]
join.localattributes =
  att.global.attributes,
  att.pointing.attributes,
  att.typed.attributes,
  
  ## specifies the identifiers of the elements or passages to be joined into a virtual element.
  attribute targets {
    list { data.pointer, data.pointer, data.pointer* }
  }?,
  
  ## specifies the name of an element which this aggregation may be understood to represent.
  attribute result { data.name }?,
  
  ## indicates whether the targets to be joined include the entire element indicated (the entire subtree including its root), or just the children of the target (the branches of the subtree).
  [ a:defaultValue = "root" ]
  attribute scope {
    
    ## the rooted subtrees indicated by the targets attribute are joined, each subtree become a child of the virtual element created by the join
    "root"
    | 
      ## the children of the subtrees indicated by the targets attribute become the children of the virtual element (i.e. the roots of the subtrees are discarded)
      "branches"
  }?,
  empty
joinGrp =
  
  ## (join group) groups a collection of join elements and possibly pointers.
  element joinGrp { joinGrp.content, joinGrp.localattributes }
joinGrp.content = model.glossLike*, (join | ptr)+
joinGrp.localattributes =
  att.global.attributes,
  att.pointing.group.attributes,
  
  ## describes the result of the joins gathered in this collection.
  attribute result { data.name }?,
  empty
link =
  
  ## defines an association or hypertextual link among elements or passages, of some type not more precisely specifiable by other elements.
  element link { link.content, link.localattributes }
link.content =
  empty
  >> sch:pattern [
       id = "link-constraint-linkTargets1"
       "\x{a}" ~
       "         "
       sch:rule [
         context = "tei:link"
         "\x{a}" ~
         "            "
         sch:report [
           test = "@target and @targets"
           "You may not supply both \x{a}" ~
           "	@target and @targets"
         ]
         "\x{a}" ~
         "         "
       ]
       "\x{a}" ~
       "      "
     ]
  >> sch:pattern [
       id = "link-constraint-linkTargets2"
       "\x{a}" ~
       "         "
       sch:rule [
         context = "tei:link"
         "\x{a}" ~
         "            "
         sch:report [
           test = "not(@target) and not(@targets)"
           "You must\x{a}" ~
           "	supply either @target or @targets"
         ]
         "\x{a}" ~
         "         "
       ]
       "\x{a}" ~
       "      "
     ]
  >> sch:pattern [
       id = "link-constraint-linkTargets3"
       "\x{a}" ~
       "         "
       sch:rule [
         context = "tei:link"
         "\x{a}" ~
         "            "
         sch:assert [
           test = "contains(@target,' ')"
           "You must supply at least two\x{a}" ~
           "values for @target"
         ]
         "\x{a}" ~
         "         "
       ]
       "\x{a}" ~
       "      "
     ]
link.localattributes =
  att.global.attributes,
  att.pointing.attributes,
  att.typed.attributes,
  
  ## specifies the identifiers of the elements or passages to be linked or associated. 
  attribute targets {
    list { data.pointer, data.pointer, data.pointer* }
  }?,
  empty
linkGrp =
  
  ## (link group) defines a collection of associations or hypertextual links.
  element linkGrp { linkGrp.content, linkGrp.localattributes }
linkGrp.content = (link | ptr)+
linkGrp.localattributes =
  att.global.attributes, att.pointing.group.attributes, empty
seg =
  
  ## (arbitrary segment) represents any segmentation of text below the chunk level.
  element seg { seg.content, seg.localattributes }
seg.content = macro.paraContent
seg.localattributes =
  att.global.attributes,
  att.segLike.attributes,
  att.typed.attributes,
  att.responsibility.attributes,
  empty
timeline =
  
  ## (timeline) provides a set of ordered points in time which can be linked to elements of a spoken text to create a temporal alignment of that text.
  element timeline { timeline.content, timeline.localattributes }
timeline.content = when+
timeline.localattributes =
  att.global.attributes,
  
  ## designates the origin of the timeline, i.e. the time at which it begins.
  attribute origin { data.pointer }?,
  
  ## specifies the unit of time corresponding to the interval value of the timeline or of its constituent points in time.
  ## Suggested values include: 1] d(days) ; 2] h(hours) ; 3] min(minutes) ; 4] s(seconds) ; 5] ms(milliseconds) 
  attribute unit {
    
    ## (days) 
    "d"
    | 
      ## (hours) 
      "h"
    | 
      ## (minutes) 
      "min"
    | 
      ## (seconds) 
      "s"
    | 
      ## (milliseconds) 
      "ms"
    | xsd:Name
  }?,
  
  ## specifies the numeric portion of a time interval
  attribute interval {
    xsd:float { minExclusive = "0" }
    | "regular"
    | "irregular"
  }?,
  empty
when =
  
  ## indicates a point in time either relative to other elements in the same timeline tag, or absolutely.
  element when { when.content, when.localattributes }
when.content = empty
when.localattributes =
  att.global.attributes,
  
  ## supplies an absolute value for the time.
  attribute absolute { data.temporal.w3c }?,
  
  ## specifies the unit of time in which the interval value is expressed, if this is not inherited from the parent timeline.
  ## Suggested values include: 1] d(days) ; 2] h(hours) ; 3] min(minutes) ; 4] s(seconds) ; 5] ms(milliseconds) 
  attribute unit {
    
    ## (days) 
    "d"
    | 
      ## (hours) 
      "h"
    | 
      ## (minutes) 
      "min"
    | 
      ## (seconds) 
      "s"
    | 
      ## (milliseconds) 
      "ms"
    | xsd:Name
  }?,
  
  ## specifies the numeric portion of a time interval
  attribute interval {
    xsd:float { minExclusive = "0" }
    | "unknown"
  }?,
  
  ## identifies the reference point for determining the time of the current when element, which is obtained by adding the interval to the time of the reference point.
  attribute since { data.pointer }?,
  empty
# 3. macros
